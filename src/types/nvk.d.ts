/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.7.8
 */
declare module 'nvk' {
  type BigUint64Array = Float32Array
  declare const BigUint64Array: typeof Float32Array

  export interface ObjectConstructor {
    assign(...objects: Object[]): Object
  }

  export interface CustomArrayBufferConstructor extends ArrayBufferConstructor {
    fromAddress: (ptr: bigint, size: number) => ArrayBuffer
    getAddress: (data: ArrayBuffer) => bigint
  }
  declare var ArrayBuffer: CustomArrayBufferConstructor

  declare var VkInout: { $: number | boolean }
  export interface VkInout {
    $: number | boolean
  }

  declare var VkInoutAddress: { $: bigint }
  export interface VkInoutAddress {
    $: bigint
  }

  /**
   *
   * @member VK_KHR_SURFACE_EXTENSION_NAME
   * @member VK_KHR_SWAPCHAIN_EXTENSION_NAME
   * @member VK_KHR_DISPLAY_EXTENSION_NAME
   * @member VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME
   * @member VK_KHR_XLIB_SURFACE_EXTENSION_NAME
   * @member VK_KHR_XCB_SURFACE_EXTENSION_NAME
   * @member VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
   * @member VK_KHR_MIR_SURFACE_EXTENSION_NAME
   * @member VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
   * @member VK_KHR_WIN32_SURFACE_EXTENSION_NAME
   * @member VK_ANDROID_NATIVE_BUFFER_NAME
   * @member VK_EXT_DEBUG_REPORT_EXTENSION_NAME
   * @member VK_NV_GLSL_SHADER_EXTENSION_NAME
   * @member VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME
   * @member VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME
   * @member VK_IMG_FILTER_CUBIC_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_17_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_18_EXTENSION_NAME
   * @member VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_20_EXTENSION_NAME
   * @member VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME
   * @member VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME
   * @member VK_EXT_DEBUG_MARKER_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_24_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_25_EXTENSION_NAME
   * @member VK_AMD_GCN_SHADER_EXTENSION_NAME
   * @member VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_28_EXTENSION_NAME
   * @member VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
   * @member VK_NVX_EXTENSION_30_EXTENSION_NAME
   * @member VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_32_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_33_EXTENSION_NAME
   * @member VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_35_EXTENSION_NAME
   * @member VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME
   * @member VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME
   * @member VK_AMD_SHADER_BALLOT_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_39_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_40_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_41_EXTENSION_NAME
   * @member VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME
   * @member VK_AMD_SHADER_INFO_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_44_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_45_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_46_EXTENSION_NAME
   * @member VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME
   * @member VK_NVX_EXTENSION_48_EXTENSION_NAME
   * @member VK_GOOGLE_EXTENSION_49_EXTENSION_NAME
   * @member VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME
   * @member VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME
   * @member VK_NV_EXTENSION_52_EXTENSION_NAME
   * @member VK_NV_EXTENSION_53_EXTENSION_NAME
   * @member VK_KHR_MULTIVIEW_EXTENSION_NAME
   * @member VK_IMG_FORMAT_PVRTC_EXTENSION_NAME
   * @member VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
   * @member VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME
   * @member VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
   * @member VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME
   * @member VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
   * @member VK_KHR_DEVICE_GROUP_EXTENSION_NAME
   * @member VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME
   * @member VK_NN_VI_SURFACE_EXTENSION_NAME
   * @member VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME
   * @member VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME
   * @member VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME
   * @member VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME
   * @member VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME
   * @member VK_IMG_EXTENSION_69_EXTENSION_NAME
   * @member VK_KHR_MAINTENANCE1_EXTENSION_NAME
   * @member VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME
   * @member VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME
   * @member VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME
   * @member VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
   * @member VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME
   * @member VK_KHR_16BIT_STORAGE_EXTENSION_NAME
   * @member VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME
   * @member VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME
   * @member VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
   * @member VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME
   * @member VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME
   * @member VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME
   * @member VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME
   * @member VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
   * @member VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME
   * @member VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME
   * @member VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME
   * @member VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME
   * @member VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME
   * @member VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
   * @member VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
   * @member VK_NV_EXTENSION_101_EXTENSION_NAME
   * @member VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
   * @member VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
   * @member VK_NV_EXTENSION_104_EXTENSION_NAME
   * @member VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME
   * @member VK_EXT_HDR_METADATA_EXTENSION_NAME
   * @member VK_IMG_EXTENSION_107_EXTENSION_NAME
   * @member VK_IMG_EXTENSION_108_EXTENSION_NAME
   * @member VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME
   * @member VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME
   * @member VK_IMG_EXTENSION_111_EXTENSION_NAME
   * @member VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME
   * @member VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_117_EXTENSION_NAME
   * @member VK_KHR_MAINTENANCE2_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_119_EXTENSION_NAME
   * @member VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME
   * @member VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME
   * @member VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME
   * @member VK_MVK_IOS_SURFACE_EXTENSION_NAME
   * @member VK_MVK_MACOS_SURFACE_EXTENSION_NAME
   * @member VK_MVK_MOLTENVK_EXTENSION_NAME
   * @member VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME
   * @member VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME
   * @member VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
   * @member VK_EXT_DEBUG_UTILS_EXTENSION_NAME
   * @member VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
   * @member VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME
   * @member VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME
   * @member VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_134_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_135_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_136_EXTENSION_NAME
   * @member VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME
   * @member VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME
   * @member VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_140_EXTENSION_NAME
   * @member VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_142_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_143_EXTENSION_NAME
   * @member VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME
   * @member VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME
   * @member VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
   * @member VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME
   * @member VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
   * @member VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME
   * @member VK_NV_EXTENSION_151_EXTENSION_NAME
   * @member VK_NV_EXTENSION_152_EXTENSION_NAME
   * @member VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
   * @member VK_NV_FILL_RECTANGLE_EXTENSION_NAME
   * @member VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME
   * @member VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME
   * @member VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
   * @member VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
   * @member VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_160_EXTENSION_NAME
   * @member VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
   * @member VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME
   * @member VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_164_EXTENSION_NAME
   * @member VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
   * @member VK_NV_RAY_TRACING_EXTENSION_NAME
   * @member VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_168_EXTENSION_NAME
   * @member VK_KHR_MAINTENANCE3_EXTENSION_NAME
   * @member VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME
   * @member VK_EXT_FILTER_CUBIC_EXTENSION_NAME
   * @member VK_QCOM_extension_172_EXTENSION_NAME
   * @member VK_QCOM_extension_173_EXTENSION_NAME
   * @member VK_QCOM_extension_174_EXTENSION_NAME
   * @member VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME
   * @member VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_177_EXTENSION_NAME
   * @member VK_KHR_8BIT_STORAGE_EXTENSION_NAME
   * @member VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME
   * @member VK_AMD_BUFFER_MARKER_EXTENSION_NAME
   * @member VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME
   * @member VK_KHR_SHADER_CLOCK_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_183_EXTENSION_NAME
   * @member VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME
   * @member VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
   * @member VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_187_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_188_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_189_EXTENSION_NAME
   * @member VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME
   * @member VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
   * @member VK_GGP_FRAME_TOKEN_EXTENSION_NAME
   * @member VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME
   * @member VK_GOOGLE_EXTENSION_194_EXTENSION_NAME
   * @member VK_GOOGLE_EXTENSION_195_EXTENSION_NAME
   * @member VK_GOOGLE_EXTENSION_196_EXTENSION_NAME
   * @member VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME
   * @member VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME
   * @member VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME
   * @member VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME
   * @member VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME
   * @member VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
   * @member VK_NV_MESH_SHADER_EXTENSION_NAME
   * @member VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
   * @member VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME
   * @member VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME
   * @member VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME
   * @member VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_209_EXTENSION_NAME
   * @member VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME
   * @member VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
   * @member VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME
   * @member VK_EXT_PCI_BUS_INFO_EXTENSION_NAME
   * @member VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME
   * @member VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_216_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_217_EXTENSION_NAME
   * @member VK_EXT_METAL_SURFACE_EXTENSION_NAME
   * @member VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_220_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_221_EXTENSION_NAME
   * @member VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_223_EXTENSION_NAME
   * @member VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME
   * @member VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME
   * @member VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_227_EXTENSION_NAME
   * @member VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_229_EXTENSION_NAME
   * @member VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_231_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_232_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_233_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_234_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_235_EXTENSION_NAME
   * @member VK_AMD_EXTENSION_236_EXTENSION_NAME
   * @member VK_KHR_SPIRV_1_4_EXTENSION_NAME
   * @member VK_EXT_MEMORY_BUDGET_EXTENSION_NAME
   * @member VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME
   * @member VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME
   * @member VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME
   * @member VK_NV_EXTENSION_242_EXTENSION_NAME
   * @member VK_INTEL_EXTENSION_243_EXTENSION_NAME
   * @member VK_MESA_EXTENSION_244_EXTENSION_NAME
   * @member VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_246_EXTENSION_NAME
   * @member VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME
   * @member VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_249_EXTENSION_NAME
   * @member VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
   * @member VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
   * @member VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME
   * @member VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME
   * @member VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_255_EXTENSION_NAME
   * @member VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME
   * @member VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_258_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_259_EXTENSION_NAME
   * @member VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME
   * @member VK_NV_EXTENSION_261_EXTENSION_NAME
   * @member VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME
   * @member VK_GOOGLE_EXTENSION_263_EXTENSION_NAME
   * @member VK_BRCM_EXTENSION_264_EXTENSION_NAME
   * @member VK_BRCM_EXTENSION_265_EXTENSION_NAME
   * @member VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME
   * @member VK_EXT_extension_267
   * @member VK_EXT_extension_268
   * @member VK_KHR_extension_269
   * @member VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
   * @member VK_INTEL_extension_271
   * @member VK_INTEL_extension_272
   * @member VK_INTEL_extension_273
   * @member VK_INTEL_extension_274
   * @member VK_KHR_extension_275
   * @member VK_KHR_extension_276
   * @member VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME
   * @member VK_NV_extension_278
   * @member VK_NV_extension_279
   * @member VK_KHR_extension_280
   * @member VK_ARM_extension_281
   * @member VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME
   * @member VK_QCOM_extension_283
   * @member VK_EXT_extension_284
   * @member VK_EXT_extension_285
   * @member VK_EXT_extension_286
   * @member VK_NVX_EXTENSION_287_EXTENSION_NAME
   * @member VK_NVX_EXTENSION_288_EXTENSION_NAME
   * @member VK_EXT_EXTENSION_289_EXTENSION_NAME
   * @member VK_GOOGLE_USER_TYPE_EXTENSION_NAME
   * @member VK_NV_EXTENSION_291_EXTENSION_NAME
   * @member VK_NV_EXTENSION_292_EXTENSION_NAME
   * @member VK_NV_EXTENSION_293_EXTENSION_NAME
   * @member VK_KHR_EXTENSION_294_EXTENSION_NAME
   */
  export enum API_Extensions_Strings {
    VK_KHR_SURFACE_EXTENSION_NAME,
    VK_KHR_SWAPCHAIN_EXTENSION_NAME,
    VK_KHR_DISPLAY_EXTENSION_NAME,
    VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME,
    VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
    VK_KHR_XCB_SURFACE_EXTENSION_NAME,
    VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
    VK_KHR_MIR_SURFACE_EXTENSION_NAME,
    VK_KHR_ANDROID_SURFACE_EXTENSION_NAME,
    VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
    VK_ANDROID_NATIVE_BUFFER_NAME,
    VK_EXT_DEBUG_REPORT_EXTENSION_NAME,
    VK_NV_GLSL_SHADER_EXTENSION_NAME,
    VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME,
    VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME,
    VK_IMG_FILTER_CUBIC_EXTENSION_NAME,
    VK_AMD_EXTENSION_17_EXTENSION_NAME,
    VK_AMD_EXTENSION_18_EXTENSION_NAME,
    VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME,
    VK_AMD_EXTENSION_20_EXTENSION_NAME,
    VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME,
    VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME,
    VK_EXT_DEBUG_MARKER_EXTENSION_NAME,
    VK_AMD_EXTENSION_24_EXTENSION_NAME,
    VK_AMD_EXTENSION_25_EXTENSION_NAME,
    VK_AMD_GCN_SHADER_EXTENSION_NAME,
    VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME,
    VK_EXT_EXTENSION_28_EXTENSION_NAME,
    VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME,
    VK_NVX_EXTENSION_30_EXTENSION_NAME,
    VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,
    VK_AMD_EXTENSION_32_EXTENSION_NAME,
    VK_AMD_EXTENSION_33_EXTENSION_NAME,
    VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME,
    VK_AMD_EXTENSION_35_EXTENSION_NAME,
    VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME,
    VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME,
    VK_AMD_SHADER_BALLOT_EXTENSION_NAME,
    VK_AMD_EXTENSION_39_EXTENSION_NAME,
    VK_AMD_EXTENSION_40_EXTENSION_NAME,
    VK_AMD_EXTENSION_41_EXTENSION_NAME,
    VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME,
    VK_AMD_SHADER_INFO_EXTENSION_NAME,
    VK_AMD_EXTENSION_44_EXTENSION_NAME,
    VK_AMD_EXTENSION_45_EXTENSION_NAME,
    VK_AMD_EXTENSION_46_EXTENSION_NAME,
    VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME,
    VK_NVX_EXTENSION_48_EXTENSION_NAME,
    VK_GOOGLE_EXTENSION_49_EXTENSION_NAME,
    VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME,
    VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME,
    VK_NV_EXTENSION_52_EXTENSION_NAME,
    VK_NV_EXTENSION_53_EXTENSION_NAME,
    VK_KHR_MULTIVIEW_EXTENSION_NAME,
    VK_IMG_FORMAT_PVRTC_EXTENSION_NAME,
    VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME,
    VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME,
    VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,
    VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME,
    VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
    VK_KHR_DEVICE_GROUP_EXTENSION_NAME,
    VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME,
    VK_NN_VI_SURFACE_EXTENSION_NAME,
    VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME,
    VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME,
    VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME,
    VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME,
    VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME,
    VK_IMG_EXTENSION_69_EXTENSION_NAME,
    VK_KHR_MAINTENANCE1_EXTENSION_NAME,
    VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME,
    VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME,
    VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME,
    VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,
    VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
    VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME,
    VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME,
    VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,
    VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME,
    VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
    VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME,
    VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME,
    VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME,
    VK_KHR_16BIT_STORAGE_EXTENSION_NAME,
    VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME,
    VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME,
    VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME,
    VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME,
    VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME,
    VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME,
    VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME,
    VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME,
    VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME,
    VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME,
    VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME,
    VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME,
    VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME,
    VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME,
    VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME,
    VK_NV_EXTENSION_101_EXTENSION_NAME,
    VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME,
    VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME,
    VK_NV_EXTENSION_104_EXTENSION_NAME,
    VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME,
    VK_EXT_HDR_METADATA_EXTENSION_NAME,
    VK_IMG_EXTENSION_107_EXTENSION_NAME,
    VK_IMG_EXTENSION_108_EXTENSION_NAME,
    VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME,
    VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME,
    VK_IMG_EXTENSION_111_EXTENSION_NAME,
    VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME,
    VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME,
    VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME,
    VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME,
    VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME,
    VK_KHR_EXTENSION_117_EXTENSION_NAME,
    VK_KHR_MAINTENANCE2_EXTENSION_NAME,
    VK_KHR_EXTENSION_119_EXTENSION_NAME,
    VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME,
    VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME,
    VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME,
    VK_MVK_IOS_SURFACE_EXTENSION_NAME,
    VK_MVK_MACOS_SURFACE_EXTENSION_NAME,
    VK_MVK_MOLTENVK_EXTENSION_NAME,
    VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME,
    VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME,
    VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME,
    VK_EXT_DEBUG_UTILS_EXTENSION_NAME,
    VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,
    VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME,
    VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME,
    VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME,
    VK_AMD_EXTENSION_134_EXTENSION_NAME,
    VK_AMD_EXTENSION_135_EXTENSION_NAME,
    VK_AMD_EXTENSION_136_EXTENSION_NAME,
    VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME,
    VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME,
    VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME,
    VK_AMD_EXTENSION_140_EXTENSION_NAME,
    VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME,
    VK_AMD_EXTENSION_142_EXTENSION_NAME,
    VK_AMD_EXTENSION_143_EXTENSION_NAME,
    VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME,
    VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME,
    VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME,
    VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME,
    VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME,
    VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME,
    VK_NV_EXTENSION_151_EXTENSION_NAME,
    VK_NV_EXTENSION_152_EXTENSION_NAME,
    VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME,
    VK_NV_FILL_RECTANGLE_EXTENSION_NAME,
    VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME,
    VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME,
    VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME,
    VK_KHR_BIND_MEMORY_2_EXTENSION_NAME,
    VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME,
    VK_EXT_EXTENSION_160_EXTENSION_NAME,
    VK_EXT_VALIDATION_CACHE_EXTENSION_NAME,
    VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME,
    VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME,
    VK_EXT_EXTENSION_164_EXTENSION_NAME,
    VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME,
    VK_NV_RAY_TRACING_EXTENSION_NAME,
    VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME,
    VK_EXT_EXTENSION_168_EXTENSION_NAME,
    VK_KHR_MAINTENANCE3_EXTENSION_NAME,
    VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME,
    VK_EXT_FILTER_CUBIC_EXTENSION_NAME,
    VK_QCOM_extension_172_EXTENSION_NAME,
    VK_QCOM_extension_173_EXTENSION_NAME,
    VK_QCOM_extension_174_EXTENSION_NAME,
    VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME,
    VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME,
    VK_KHR_EXTENSION_177_EXTENSION_NAME,
    VK_KHR_8BIT_STORAGE_EXTENSION_NAME,
    VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME,
    VK_AMD_BUFFER_MARKER_EXTENSION_NAME,
    VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME,
    VK_KHR_SHADER_CLOCK_EXTENSION_NAME,
    VK_KHR_EXTENSION_183_EXTENSION_NAME,
    VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME,
    VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME,
    VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME,
    VK_KHR_EXTENSION_187_EXTENSION_NAME,
    VK_KHR_EXTENSION_188_EXTENSION_NAME,
    VK_KHR_EXTENSION_189_EXTENSION_NAME,
    VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME,
    VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME,
    VK_GGP_FRAME_TOKEN_EXTENSION_NAME,
    VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME,
    VK_GOOGLE_EXTENSION_194_EXTENSION_NAME,
    VK_GOOGLE_EXTENSION_195_EXTENSION_NAME,
    VK_GOOGLE_EXTENSION_196_EXTENSION_NAME,
    VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME,
    VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME,
    VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME,
    VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME,
    VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME,
    VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME,
    VK_NV_MESH_SHADER_EXTENSION_NAME,
    VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME,
    VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME,
    VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME,
    VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME,
    VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME,
    VK_KHR_EXTENSION_209_EXTENSION_NAME,
    VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME,
    VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME,
    VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME,
    VK_EXT_PCI_BUS_INFO_EXTENSION_NAME,
    VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME,
    VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME,
    VK_KHR_EXTENSION_216_EXTENSION_NAME,
    VK_KHR_EXTENSION_217_EXTENSION_NAME,
    VK_EXT_METAL_SURFACE_EXTENSION_NAME,
    VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME,
    VK_EXT_EXTENSION_220_EXTENSION_NAME,
    VK_KHR_EXTENSION_221_EXTENSION_NAME,
    VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME,
    VK_EXT_EXTENSION_223_EXTENSION_NAME,
    VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME,
    VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME,
    VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME,
    VK_AMD_EXTENSION_227_EXTENSION_NAME,
    VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME,
    VK_AMD_EXTENSION_229_EXTENSION_NAME,
    VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME,
    VK_AMD_EXTENSION_231_EXTENSION_NAME,
    VK_AMD_EXTENSION_232_EXTENSION_NAME,
    VK_AMD_EXTENSION_233_EXTENSION_NAME,
    VK_AMD_EXTENSION_234_EXTENSION_NAME,
    VK_AMD_EXTENSION_235_EXTENSION_NAME,
    VK_AMD_EXTENSION_236_EXTENSION_NAME,
    VK_KHR_SPIRV_1_4_EXTENSION_NAME,
    VK_EXT_MEMORY_BUDGET_EXTENSION_NAME,
    VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME,
    VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME,
    VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME,
    VK_NV_EXTENSION_242_EXTENSION_NAME,
    VK_INTEL_EXTENSION_243_EXTENSION_NAME,
    VK_MESA_EXTENSION_244_EXTENSION_NAME,
    VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME,
    VK_EXT_EXTENSION_246_EXTENSION_NAME,
    VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME,
    VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME,
    VK_KHR_EXTENSION_249_EXTENSION_NAME,
    VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME,
    VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME,
    VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME,
    VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME,
    VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME,
    VK_EXT_EXTENSION_255_EXTENSION_NAME,
    VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME,
    VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME,
    VK_EXT_EXTENSION_258_EXTENSION_NAME,
    VK_EXT_EXTENSION_259_EXTENSION_NAME,
    VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME,
    VK_NV_EXTENSION_261_EXTENSION_NAME,
    VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME,
    VK_GOOGLE_EXTENSION_263_EXTENSION_NAME,
    VK_BRCM_EXTENSION_264_EXTENSION_NAME,
    VK_BRCM_EXTENSION_265_EXTENSION_NAME,
    VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME,
    VK_EXT_extension_267,
    VK_EXT_extension_268,
    VK_KHR_extension_269,
    VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME,
    VK_INTEL_extension_271,
    VK_INTEL_extension_272,
    VK_INTEL_extension_273,
    VK_INTEL_extension_274,
    VK_KHR_extension_275,
    VK_KHR_extension_276,
    VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME,
    VK_NV_extension_278,
    VK_NV_extension_279,
    VK_KHR_extension_280,
    VK_ARM_extension_281,
    VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME,
    VK_QCOM_extension_283,
    VK_EXT_extension_284,
    VK_EXT_extension_285,
    VK_EXT_extension_286,
    VK_NVX_EXTENSION_287_EXTENSION_NAME,
    VK_NVX_EXTENSION_288_EXTENSION_NAME,
    VK_EXT_EXTENSION_289_EXTENSION_NAME,
    VK_GOOGLE_USER_TYPE_EXTENSION_NAME,
    VK_NV_EXTENSION_291_EXTENSION_NAME,
    VK_NV_EXTENSION_292_EXTENSION_NAME,
    VK_NV_EXTENSION_293_EXTENSION_NAME,
    VK_KHR_EXTENSION_294_EXTENSION_NAME,
  }

  declare const VK_KHR_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SWAPCHAIN_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DISPLAY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_XLIB_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_XCB_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_MIR_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_ANDROID_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_WIN32_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_ANDROID_NATIVE_BUFFER_NAME: API_Extensions_Strings
  declare const VK_EXT_DEBUG_REPORT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_GLSL_SHADER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_IMG_FILTER_CUBIC_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_17_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_18_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_20_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DEBUG_MARKER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_24_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_25_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_GCN_SHADER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_28_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NVX_EXTENSION_30_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_32_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_33_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_35_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_BALLOT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_39_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_40_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_41_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_INFO_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_44_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_45_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_46_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NVX_EXTENSION_48_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_EXTENSION_49_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_52_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_53_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_MULTIVIEW_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_IMG_FORMAT_PVRTC_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DEVICE_GROUP_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NN_VI_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_IMG_EXTENSION_69_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_MAINTENANCE1_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_16BIT_STORAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_101_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_104_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_HDR_METADATA_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_IMG_EXTENSION_107_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_IMG_EXTENSION_108_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_IMG_EXTENSION_111_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_117_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_MAINTENANCE2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_119_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_MVK_IOS_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_MVK_MACOS_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_MVK_MOLTENVK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DEBUG_UTILS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_134_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_135_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_136_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_140_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_142_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_143_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_151_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_152_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_FILL_RECTANGLE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_BIND_MEMORY_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_160_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_VALIDATION_CACHE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_164_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_RAY_TRACING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_168_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_MAINTENANCE3_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_FILTER_CUBIC_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_QCOM_extension_172_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_QCOM_extension_173_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_QCOM_extension_174_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_177_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_8BIT_STORAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_BUFFER_MARKER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHADER_CLOCK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_183_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_187_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_188_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_189_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GGP_FRAME_TOKEN_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_EXTENSION_194_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_EXTENSION_195_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_EXTENSION_196_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_MESH_SHADER_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_209_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_PCI_BUS_INFO_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_216_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_217_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_METAL_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_220_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_221_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_223_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_227_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_229_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_231_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_232_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_233_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_234_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_235_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_AMD_EXTENSION_236_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SPIRV_1_4_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_MEMORY_BUDGET_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_242_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_INTEL_EXTENSION_243_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_MESA_EXTENSION_244_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_246_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_249_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_255_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_258_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_259_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_261_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_EXTENSION_263_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_BRCM_EXTENSION_264_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_BRCM_EXTENSION_265_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_extension_267: API_Extensions_Strings
  declare const VK_EXT_extension_268: API_Extensions_Strings
  declare const VK_KHR_extension_269: API_Extensions_Strings
  declare const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_INTEL_extension_271: API_Extensions_Strings
  declare const VK_INTEL_extension_272: API_Extensions_Strings
  declare const VK_INTEL_extension_273: API_Extensions_Strings
  declare const VK_INTEL_extension_274: API_Extensions_Strings
  declare const VK_KHR_extension_275: API_Extensions_Strings
  declare const VK_KHR_extension_276: API_Extensions_Strings
  declare const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_extension_278: API_Extensions_Strings
  declare const VK_NV_extension_279: API_Extensions_Strings
  declare const VK_KHR_extension_280: API_Extensions_Strings
  declare const VK_ARM_extension_281: API_Extensions_Strings
  declare const VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_QCOM_extension_283: API_Extensions_Strings
  declare const VK_EXT_extension_284: API_Extensions_Strings
  declare const VK_EXT_extension_285: API_Extensions_Strings
  declare const VK_EXT_extension_286: API_Extensions_Strings
  declare const VK_NVX_EXTENSION_287_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NVX_EXTENSION_288_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_EXT_EXTENSION_289_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_GOOGLE_USER_TYPE_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_291_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_292_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_NV_EXTENSION_293_EXTENSION_NAME: API_Extensions_Strings
  declare const VK_KHR_EXTENSION_294_EXTENSION_NAME: API_Extensions_Strings

  /**
   *
   * @member VK_KHR_SURFACE_SPEC_VERSION
   * @member VK_KHR_SWAPCHAIN_SPEC_VERSION
   * @member VK_KHR_DISPLAY_SPEC_VERSION
   * @member VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION
   * @member VK_KHR_XLIB_SURFACE_SPEC_VERSION
   * @member VK_KHR_XCB_SURFACE_SPEC_VERSION
   * @member VK_KHR_WAYLAND_SURFACE_SPEC_VERSION
   * @member VK_KHR_MIR_SURFACE_SPEC_VERSION
   * @member VK_KHR_ANDROID_SURFACE_SPEC_VERSION
   * @member VK_KHR_WIN32_SURFACE_SPEC_VERSION
   * @member VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION
   * @member VK_ANDROID_NATIVE_BUFFER_NUMBER
   * @member VK_EXT_DEBUG_REPORT_SPEC_VERSION
   * @member VK_NV_GLSL_SHADER_SPEC_VERSION
   * @member VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION
   * @member VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION
   * @member VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
   * @member VK_IMG_FILTER_CUBIC_SPEC_VERSION
   * @member VK_AMD_EXTENSION_17_SPEC_VERSION
   * @member VK_AMD_EXTENSION_18_SPEC_VERSION
   * @member VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION
   * @member VK_AMD_EXTENSION_20_SPEC_VERSION
   * @member VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION
   * @member VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION
   * @member VK_EXT_DEBUG_MARKER_SPEC_VERSION
   * @member VK_AMD_EXTENSION_24_SPEC_VERSION
   * @member VK_AMD_EXTENSION_25_SPEC_VERSION
   * @member VK_AMD_GCN_SHADER_SPEC_VERSION
   * @member VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION
   * @member VK_EXT_EXTENSION_28_SPEC_VERSION
   * @member VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION
   * @member VK_NVX_EXTENSION_30_SPEC_VERSION
   * @member VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION
   * @member VK_AMD_EXTENSION_32_SPEC_VERSION
   * @member VK_AMD_EXTENSION_33_SPEC_VERSION
   * @member VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION
   * @member VK_AMD_EXTENSION_35_SPEC_VERSION
   * @member VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION
   * @member VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION
   * @member VK_AMD_SHADER_BALLOT_SPEC_VERSION
   * @member VK_AMD_EXTENSION_39_SPEC_VERSION
   * @member VK_AMD_EXTENSION_40_SPEC_VERSION
   * @member VK_AMD_EXTENSION_41_SPEC_VERSION
   * @member VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION
   * @member VK_AMD_SHADER_INFO_SPEC_VERSION
   * @member VK_AMD_EXTENSION_44_SPEC_VERSION
   * @member VK_AMD_EXTENSION_45_SPEC_VERSION
   * @member VK_AMD_EXTENSION_46_SPEC_VERSION
   * @member VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION
   * @member VK_NVX_EXTENSION_48_SPEC_VERSION
   * @member VK_GOOGLE_EXTENSION_49_SPEC_VERSION
   * @member VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION
   * @member VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION
   * @member VK_NV_EXTENSION_52_SPEC_VERSION
   * @member VK_NV_EXTENSION_53_SPEC_VERSION
   * @member VK_KHR_MULTIVIEW_SPEC_VERSION
   * @member VK_IMG_FORMAT_PVRTC_SPEC_VERSION
   * @member VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
   * @member VK_NV_EXTERNAL_MEMORY_SPEC_VERSION
   * @member VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
   * @member VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION
   * @member VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION
   * @member VK_KHR_DEVICE_GROUP_SPEC_VERSION
   * @member VK_EXT_VALIDATION_FLAGS_SPEC_VERSION
   * @member VK_NN_VI_SURFACE_SPEC_VERSION
   * @member VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION
   * @member VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION
   * @member VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION
   * @member VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION
   * @member VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION
   * @member VK_IMG_EXTENSION_69_SPEC_VERSION
   * @member VK_KHR_MAINTENANCE1_SPEC_VERSION
   * @member VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION
   * @member VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION
   * @member VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION
   * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
   * @member VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION
   * @member VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION
   * @member VK_KHR_16BIT_STORAGE_SPEC_VERSION
   * @member VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION
   * @member VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION
   * @member VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
   * @member VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION
   * @member VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION
   * @member VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION
   * @member VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION
   * @member VK_EXT_DISPLAY_CONTROL_SPEC_VERSION
   * @member VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION
   * @member VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION
   * @member VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION
   * @member VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION
   * @member VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION
   * @member VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION
   * @member VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION
   * @member VK_NV_EXTENSION_101_SPEC_VERSION
   * @member VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION
   * @member VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION
   * @member VK_NV_EXTENSION_104_SPEC_VERSION
   * @member VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION
   * @member VK_EXT_HDR_METADATA_SPEC_VERSION
   * @member VK_IMG_EXTENSION_107_SPEC_VERSION
   * @member VK_IMG_EXTENSION_108_SPEC_VERSION
   * @member VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION
   * @member VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION
   * @member VK_IMG_EXTENSION_111_SPEC_VERSION
   * @member VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_FENCE_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION
   * @member VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION
   * @member VK_KHR_EXTENSION_117_SPEC_VERSION
   * @member VK_KHR_MAINTENANCE2_SPEC_VERSION
   * @member VK_KHR_EXTENSION_119_SPEC_VERSION
   * @member VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION
   * @member VK_KHR_VARIABLE_POINTERS_SPEC_VERSION
   * @member VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION
   * @member VK_MVK_IOS_SURFACE_SPEC_VERSION
   * @member VK_MVK_MACOS_SURFACE_SPEC_VERSION
   * @member VK_MVK_MOLTENVK_SPEC_VERSION
   * @member VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION
   * @member VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION
   * @member VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION
   * @member VK_EXT_DEBUG_UTILS_SPEC_VERSION
   * @member VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION
   * @member VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION
   * @member VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION
   * @member VK_AMD_GPU_SHADER_INT16_SPEC_VERSION
   * @member VK_AMD_EXTENSION_134_SPEC_VERSION
   * @member VK_AMD_EXTENSION_135_SPEC_VERSION
   * @member VK_AMD_EXTENSION_136_SPEC_VERSION
   * @member VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION
   * @member VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION
   * @member VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION
   * @member VK_AMD_EXTENSION_140_SPEC_VERSION
   * @member VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION
   * @member VK_AMD_EXTENSION_142_SPEC_VERSION
   * @member VK_AMD_EXTENSION_143_SPEC_VERSION
   * @member VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION
   * @member VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION
   * @member VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION
   * @member VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION
   * @member VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION
   * @member VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION
   * @member VK_NV_EXTENSION_151_SPEC_VERSION
   * @member VK_NV_EXTENSION_152_SPEC_VERSION
   * @member VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION
   * @member VK_NV_FILL_RECTANGLE_SPEC_VERSION
   * @member VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION
   * @member VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION
   * @member VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION
   * @member VK_KHR_BIND_MEMORY_2_SPEC_VERSION
   * @member VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION
   * @member VK_EXT_EXTENSION_160_SPEC_VERSION
   * @member VK_EXT_VALIDATION_CACHE_SPEC_VERSION
   * @member VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION
   * @member VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION
   * @member VK_EXT_EXTENSION_164_SPEC_VERSION
   * @member VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION
   * @member VK_NV_RAY_TRACING_SPEC_VERSION
   * @member VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION
   * @member VK_EXT_EXTENSION_168_SPEC_VERSION
   * @member VK_KHR_MAINTENANCE3_SPEC_VERSION
   * @member VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION
   * @member VK_EXT_FILTER_CUBIC_SPEC_VERSION
   * @member VK_QCOM_extension_172_SPEC_VERSION
   * @member VK_QCOM_extension_173_SPEC_VERSION
   * @member VK_QCOM_extension_174_SPEC_VERSION
   * @member VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION
   * @member VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION
   * @member VK_KHR_EXTENSION_177_SPEC_VERSION
   * @member VK_KHR_8BIT_STORAGE_SPEC_VERSION
   * @member VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION
   * @member VK_AMD_BUFFER_MARKER_SPEC_VERSION
   * @member VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION
   * @member VK_KHR_SHADER_CLOCK_SPEC_VERSION
   * @member VK_KHR_EXTENSION_183_SPEC_VERSION
   * @member VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION
   * @member VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION
   * @member VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION
   * @member VK_KHR_EXTENSION_187_SPEC_VERSION
   * @member VK_KHR_EXTENSION_188_SPEC_VERSION
   * @member VK_KHR_EXTENSION_189_SPEC_VERSION
   * @member VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION
   * @member VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION
   * @member VK_GGP_FRAME_TOKEN_SPEC_VERSION
   * @member VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION
   * @member VK_GOOGLE_EXTENSION_194_SPEC_VERSION
   * @member VK_GOOGLE_EXTENSION_195_SPEC_VERSION
   * @member VK_GOOGLE_EXTENSION_196_SPEC_VERSION
   * @member VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION
   * @member VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION
   * @member VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION
   * @member VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION
   * @member VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION
   * @member VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION
   * @member VK_NV_MESH_SHADER_SPEC_VERSION
   * @member VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION
   * @member VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION
   * @member VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION
   * @member VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION
   * @member VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION
   * @member VK_KHR_EXTENSION_209_SPEC_VERSION
   * @member VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION
   * @member VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION
   * @member VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION
   * @member VK_EXT_PCI_BUS_INFO_SPEC_VERSION
   * @member VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION
   * @member VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION
   * @member VK_KHR_EXTENSION_216_SPEC_VERSION
   * @member VK_KHR_EXTENSION_217_SPEC_VERSION
   * @member VK_EXT_METAL_SURFACE_SPEC_VERSION
   * @member VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION
   * @member VK_EXT_EXTENSION_220_SPEC_VERSION
   * @member VK_KHR_EXTENSION_221_SPEC_VERSION
   * @member VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION
   * @member VK_EXT_EXTENSION_223_SPEC_VERSION
   * @member VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION
   * @member VK_GOOGLE_DECORATE_STRING_SPEC_VERSION
   * @member VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION
   * @member VK_AMD_EXTENSION_227_SPEC_VERSION
   * @member VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION
   * @member VK_AMD_EXTENSION_229_SPEC_VERSION
   * @member VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION
   * @member VK_AMD_EXTENSION_231_SPEC_VERSION
   * @member VK_AMD_EXTENSION_232_SPEC_VERSION
   * @member VK_AMD_EXTENSION_233_SPEC_VERSION
   * @member VK_AMD_EXTENSION_234_SPEC_VERSION
   * @member VK_AMD_EXTENSION_235_SPEC_VERSION
   * @member VK_AMD_EXTENSION_236_SPEC_VERSION
   * @member VK_KHR_SPIRV_1_4_SPEC_VERSION
   * @member VK_EXT_MEMORY_BUDGET_SPEC_VERSION
   * @member VK_EXT_MEMORY_PRIORITY_SPEC_VERSION
   * @member VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION
   * @member VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION
   * @member VK_NV_EXTENSION_242_SPEC_VERSION
   * @member VK_INTEL_EXTENSION_243_SPEC_VERSION
   * @member VK_MESA_EXTENSION_244_SPEC_VERSION
   * @member VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
   * @member VK_EXT_EXTENSION_246_SPEC_VERSION
   * @member VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION
   * @member VK_EXT_VALIDATION_FEATURES_SPEC_VERSION
   * @member VK_KHR_EXTENSION_249_SPEC_VERSION
   * @member VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION
   * @member VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION
   * @member VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION
   * @member VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION
   * @member VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION
   * @member VK_EXT_EXTENSION_255_SPEC_VERSION
   * @member VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION
   * @member VK_EXT_HEADLESS_SURFACE_SPEC_VERSION
   * @member VK_EXT_EXTENSION_258_SPEC_VERSION
   * @member VK_EXT_EXTENSION_259_SPEC_VERSION
   * @member VK_EXT_LINE_RASTERIZATION_SPEC_VERSION
   * @member VK_NV_EXTENSION_261_SPEC_VERSION
   * @member VK_EXT_HOST_QUERY_RESET_SPEC_VERSION
   * @member VK_GOOGLE_EXTENSION_263_SPEC_VERSION
   * @member VK_BRCM_EXTENSION_264_SPEC_VERSION
   * @member VK_BRCM_EXTENSION_265_SPEC_VERSION
   * @member VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION
   * @member VK_EXT_EXTENSION_267_SPEC_VERSION
   * @member VK_EXT_EXTENSION_268_SPEC_VERSION
   * @member VK_KHR_EXTENSION_269_SPEC_VERSION
   * @member VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION
   * @member VK_INTEL_EXTENSION_271_SPEC_VERSION
   * @member VK_INTEL_EXTENSION_272_SPEC_VERSION
   * @member VK_INTEL_EXTENSION_273_SPEC_VERSION
   * @member VK_INTEL_EXTENSION_274_SPEC_VERSION
   * @member VK_KHR_EXTENSION_275_SPEC_VERSION
   * @member VK_KHR_EXTENSION_276_SPEC_VERSION
   * @member VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION
   * @member VK_NV_EXTENSION_278_SPEC_VERSION
   * @member VK_NV_EXTENSION_279_SPEC_VERSION
   * @member VK_KHR_EXTENSION_280_SPEC_VERSION
   * @member VK_ARM_EXTENSION_281_SPEC_VERSION
   * @member VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION
   * @member VK_QCOM_EXTENSION_283_SPEC_VERSION
   * @member VK_EXT_EXTENSION_284_SPEC_VERSION
   * @member VK_EXT_EXTENSION_285_SPEC_VERSION
   * @member VK_EXT_EXTENSION_286_SPEC_VERSION
   * @member VK_NVX_EXTENSION_287_SPEC_VERSION
   * @member VK_NVX_EXTENSION_288_SPEC_VERSION
   * @member VK_EXT_EXTENSION_289_SPEC_VERSION
   * @member VK_GOOGLE_USER_TYPE_SPEC_VERSION
   * @member VK_NV_EXTENSION_291_SPEC_VERSION
   * @member VK_NV_EXTENSION_292_SPEC_VERSION
   * @member VK_NV_EXTENSION_293_SPEC_VERSION
   * @member VK_KHR_EXTENSION_294_SPEC_VERSION
   */
  export enum API_Extensions {
    VK_KHR_SURFACE_SPEC_VERSION,
    VK_KHR_SWAPCHAIN_SPEC_VERSION,
    VK_KHR_DISPLAY_SPEC_VERSION,
    VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION,
    VK_KHR_XLIB_SURFACE_SPEC_VERSION,
    VK_KHR_XCB_SURFACE_SPEC_VERSION,
    VK_KHR_WAYLAND_SURFACE_SPEC_VERSION,
    VK_KHR_MIR_SURFACE_SPEC_VERSION,
    VK_KHR_ANDROID_SURFACE_SPEC_VERSION,
    VK_KHR_WIN32_SURFACE_SPEC_VERSION,
    VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION,
    VK_ANDROID_NATIVE_BUFFER_NUMBER,
    VK_EXT_DEBUG_REPORT_SPEC_VERSION,
    VK_NV_GLSL_SHADER_SPEC_VERSION,
    VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION,
    VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
    VK_IMG_FILTER_CUBIC_SPEC_VERSION,
    VK_AMD_EXTENSION_17_SPEC_VERSION,
    VK_AMD_EXTENSION_18_SPEC_VERSION,
    VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION,
    VK_AMD_EXTENSION_20_SPEC_VERSION,
    VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION,
    VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION,
    VK_EXT_DEBUG_MARKER_SPEC_VERSION,
    VK_AMD_EXTENSION_24_SPEC_VERSION,
    VK_AMD_EXTENSION_25_SPEC_VERSION,
    VK_AMD_GCN_SHADER_SPEC_VERSION,
    VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION,
    VK_EXT_EXTENSION_28_SPEC_VERSION,
    VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION,
    VK_NVX_EXTENSION_30_SPEC_VERSION,
    VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION,
    VK_AMD_EXTENSION_32_SPEC_VERSION,
    VK_AMD_EXTENSION_33_SPEC_VERSION,
    VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION,
    VK_AMD_EXTENSION_35_SPEC_VERSION,
    VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION,
    VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION,
    VK_AMD_SHADER_BALLOT_SPEC_VERSION,
    VK_AMD_EXTENSION_39_SPEC_VERSION,
    VK_AMD_EXTENSION_40_SPEC_VERSION,
    VK_AMD_EXTENSION_41_SPEC_VERSION,
    VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION,
    VK_AMD_SHADER_INFO_SPEC_VERSION,
    VK_AMD_EXTENSION_44_SPEC_VERSION,
    VK_AMD_EXTENSION_45_SPEC_VERSION,
    VK_AMD_EXTENSION_46_SPEC_VERSION,
    VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION,
    VK_NVX_EXTENSION_48_SPEC_VERSION,
    VK_GOOGLE_EXTENSION_49_SPEC_VERSION,
    VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION,
    VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION,
    VK_NV_EXTENSION_52_SPEC_VERSION,
    VK_NV_EXTENSION_53_SPEC_VERSION,
    VK_KHR_MULTIVIEW_SPEC_VERSION,
    VK_IMG_FORMAT_PVRTC_SPEC_VERSION,
    VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION,
    VK_NV_EXTERNAL_MEMORY_SPEC_VERSION,
    VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION,
    VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION,
    VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION,
    VK_KHR_DEVICE_GROUP_SPEC_VERSION,
    VK_EXT_VALIDATION_FLAGS_SPEC_VERSION,
    VK_NN_VI_SURFACE_SPEC_VERSION,
    VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION,
    VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION,
    VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION,
    VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION,
    VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION,
    VK_IMG_EXTENSION_69_SPEC_VERSION,
    VK_KHR_MAINTENANCE1_SPEC_VERSION,
    VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION,
    VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION,
    VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION,
    VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION,
    VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION,
    VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION,
    VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION,
    VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION,
    VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION,
    VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION,
    VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
    VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION,
    VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION,
    VK_KHR_16BIT_STORAGE_SPEC_VERSION,
    VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION,
    VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION,
    VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION,
    VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION,
    VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION,
    VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION,
    VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION,
    VK_EXT_DISPLAY_CONTROL_SPEC_VERSION,
    VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION,
    VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION,
    VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION,
    VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION,
    VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION,
    VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION,
    VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION,
    VK_NV_EXTENSION_101_SPEC_VERSION,
    VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION,
    VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION,
    VK_NV_EXTENSION_104_SPEC_VERSION,
    VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION,
    VK_EXT_HDR_METADATA_SPEC_VERSION,
    VK_IMG_EXTENSION_107_SPEC_VERSION,
    VK_IMG_EXTENSION_108_SPEC_VERSION,
    VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION,
    VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION,
    VK_IMG_EXTENSION_111_SPEC_VERSION,
    VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION,
    VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION,
    VK_KHR_EXTERNAL_FENCE_SPEC_VERSION,
    VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION,
    VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION,
    VK_KHR_EXTENSION_117_SPEC_VERSION,
    VK_KHR_MAINTENANCE2_SPEC_VERSION,
    VK_KHR_EXTENSION_119_SPEC_VERSION,
    VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION,
    VK_KHR_VARIABLE_POINTERS_SPEC_VERSION,
    VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION,
    VK_MVK_IOS_SURFACE_SPEC_VERSION,
    VK_MVK_MACOS_SURFACE_SPEC_VERSION,
    VK_MVK_MOLTENVK_SPEC_VERSION,
    VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION,
    VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION,
    VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION,
    VK_EXT_DEBUG_UTILS_SPEC_VERSION,
    VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION,
    VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION,
    VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION,
    VK_AMD_GPU_SHADER_INT16_SPEC_VERSION,
    VK_AMD_EXTENSION_134_SPEC_VERSION,
    VK_AMD_EXTENSION_135_SPEC_VERSION,
    VK_AMD_EXTENSION_136_SPEC_VERSION,
    VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION,
    VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION,
    VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION,
    VK_AMD_EXTENSION_140_SPEC_VERSION,
    VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION,
    VK_AMD_EXTENSION_142_SPEC_VERSION,
    VK_AMD_EXTENSION_143_SPEC_VERSION,
    VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION,
    VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION,
    VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION,
    VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION,
    VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION,
    VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION,
    VK_NV_EXTENSION_151_SPEC_VERSION,
    VK_NV_EXTENSION_152_SPEC_VERSION,
    VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION,
    VK_NV_FILL_RECTANGLE_SPEC_VERSION,
    VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION,
    VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION,
    VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION,
    VK_KHR_BIND_MEMORY_2_SPEC_VERSION,
    VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION,
    VK_EXT_EXTENSION_160_SPEC_VERSION,
    VK_EXT_VALIDATION_CACHE_SPEC_VERSION,
    VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION,
    VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION,
    VK_EXT_EXTENSION_164_SPEC_VERSION,
    VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION,
    VK_NV_RAY_TRACING_SPEC_VERSION,
    VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION,
    VK_EXT_EXTENSION_168_SPEC_VERSION,
    VK_KHR_MAINTENANCE3_SPEC_VERSION,
    VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION,
    VK_EXT_FILTER_CUBIC_SPEC_VERSION,
    VK_QCOM_extension_172_SPEC_VERSION,
    VK_QCOM_extension_173_SPEC_VERSION,
    VK_QCOM_extension_174_SPEC_VERSION,
    VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION,
    VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION,
    VK_KHR_EXTENSION_177_SPEC_VERSION,
    VK_KHR_8BIT_STORAGE_SPEC_VERSION,
    VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION,
    VK_AMD_BUFFER_MARKER_SPEC_VERSION,
    VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION,
    VK_KHR_SHADER_CLOCK_SPEC_VERSION,
    VK_KHR_EXTENSION_183_SPEC_VERSION,
    VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION,
    VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION,
    VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION,
    VK_KHR_EXTENSION_187_SPEC_VERSION,
    VK_KHR_EXTENSION_188_SPEC_VERSION,
    VK_KHR_EXTENSION_189_SPEC_VERSION,
    VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION,
    VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION,
    VK_GGP_FRAME_TOKEN_SPEC_VERSION,
    VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION,
    VK_GOOGLE_EXTENSION_194_SPEC_VERSION,
    VK_GOOGLE_EXTENSION_195_SPEC_VERSION,
    VK_GOOGLE_EXTENSION_196_SPEC_VERSION,
    VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION,
    VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION,
    VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION,
    VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION,
    VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION,
    VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION,
    VK_NV_MESH_SHADER_SPEC_VERSION,
    VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION,
    VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION,
    VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION,
    VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION,
    VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION,
    VK_KHR_EXTENSION_209_SPEC_VERSION,
    VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION,
    VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION,
    VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION,
    VK_EXT_PCI_BUS_INFO_SPEC_VERSION,
    VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION,
    VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION,
    VK_KHR_EXTENSION_216_SPEC_VERSION,
    VK_KHR_EXTENSION_217_SPEC_VERSION,
    VK_EXT_METAL_SURFACE_SPEC_VERSION,
    VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION,
    VK_EXT_EXTENSION_220_SPEC_VERSION,
    VK_KHR_EXTENSION_221_SPEC_VERSION,
    VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION,
    VK_EXT_EXTENSION_223_SPEC_VERSION,
    VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION,
    VK_GOOGLE_DECORATE_STRING_SPEC_VERSION,
    VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION,
    VK_AMD_EXTENSION_227_SPEC_VERSION,
    VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION,
    VK_AMD_EXTENSION_229_SPEC_VERSION,
    VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION,
    VK_AMD_EXTENSION_231_SPEC_VERSION,
    VK_AMD_EXTENSION_232_SPEC_VERSION,
    VK_AMD_EXTENSION_233_SPEC_VERSION,
    VK_AMD_EXTENSION_234_SPEC_VERSION,
    VK_AMD_EXTENSION_235_SPEC_VERSION,
    VK_AMD_EXTENSION_236_SPEC_VERSION,
    VK_KHR_SPIRV_1_4_SPEC_VERSION,
    VK_EXT_MEMORY_BUDGET_SPEC_VERSION,
    VK_EXT_MEMORY_PRIORITY_SPEC_VERSION,
    VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION,
    VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION,
    VK_NV_EXTENSION_242_SPEC_VERSION,
    VK_INTEL_EXTENSION_243_SPEC_VERSION,
    VK_MESA_EXTENSION_244_SPEC_VERSION,
    VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION,
    VK_EXT_EXTENSION_246_SPEC_VERSION,
    VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION,
    VK_EXT_VALIDATION_FEATURES_SPEC_VERSION,
    VK_KHR_EXTENSION_249_SPEC_VERSION,
    VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION,
    VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION,
    VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION,
    VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION,
    VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION,
    VK_EXT_EXTENSION_255_SPEC_VERSION,
    VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION,
    VK_EXT_HEADLESS_SURFACE_SPEC_VERSION,
    VK_EXT_EXTENSION_258_SPEC_VERSION,
    VK_EXT_EXTENSION_259_SPEC_VERSION,
    VK_EXT_LINE_RASTERIZATION_SPEC_VERSION,
    VK_NV_EXTENSION_261_SPEC_VERSION,
    VK_EXT_HOST_QUERY_RESET_SPEC_VERSION,
    VK_GOOGLE_EXTENSION_263_SPEC_VERSION,
    VK_BRCM_EXTENSION_264_SPEC_VERSION,
    VK_BRCM_EXTENSION_265_SPEC_VERSION,
    VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION,
    VK_EXT_EXTENSION_267_SPEC_VERSION,
    VK_EXT_EXTENSION_268_SPEC_VERSION,
    VK_KHR_EXTENSION_269_SPEC_VERSION,
    VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION,
    VK_INTEL_EXTENSION_271_SPEC_VERSION,
    VK_INTEL_EXTENSION_272_SPEC_VERSION,
    VK_INTEL_EXTENSION_273_SPEC_VERSION,
    VK_INTEL_EXTENSION_274_SPEC_VERSION,
    VK_KHR_EXTENSION_275_SPEC_VERSION,
    VK_KHR_EXTENSION_276_SPEC_VERSION,
    VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION,
    VK_NV_EXTENSION_278_SPEC_VERSION,
    VK_NV_EXTENSION_279_SPEC_VERSION,
    VK_KHR_EXTENSION_280_SPEC_VERSION,
    VK_ARM_EXTENSION_281_SPEC_VERSION,
    VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION,
    VK_QCOM_EXTENSION_283_SPEC_VERSION,
    VK_EXT_EXTENSION_284_SPEC_VERSION,
    VK_EXT_EXTENSION_285_SPEC_VERSION,
    VK_EXT_EXTENSION_286_SPEC_VERSION,
    VK_NVX_EXTENSION_287_SPEC_VERSION,
    VK_NVX_EXTENSION_288_SPEC_VERSION,
    VK_EXT_EXTENSION_289_SPEC_VERSION,
    VK_GOOGLE_USER_TYPE_SPEC_VERSION,
    VK_NV_EXTENSION_291_SPEC_VERSION,
    VK_NV_EXTENSION_292_SPEC_VERSION,
    VK_NV_EXTENSION_293_SPEC_VERSION,
    VK_KHR_EXTENSION_294_SPEC_VERSION,
  }

  declare const VK_KHR_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SWAPCHAIN_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DISPLAY_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION: API_Extensions
  declare const VK_KHR_XLIB_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_XCB_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_WAYLAND_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_MIR_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_ANDROID_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_WIN32_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION: API_Extensions
  declare const VK_ANDROID_NATIVE_BUFFER_NUMBER: API_Extensions
  declare const VK_EXT_DEBUG_REPORT_SPEC_VERSION: API_Extensions
  declare const VK_NV_GLSL_SHADER_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION: API_Extensions
  declare const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: API_Extensions
  declare const VK_IMG_FILTER_CUBIC_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_17_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_18_SPEC_VERSION: API_Extensions
  declare const VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_20_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DEBUG_MARKER_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_24_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_25_SPEC_VERSION: API_Extensions
  declare const VK_AMD_GCN_SHADER_SPEC_VERSION: API_Extensions
  declare const VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_28_SPEC_VERSION: API_Extensions
  declare const VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION: API_Extensions
  declare const VK_NVX_EXTENSION_30_SPEC_VERSION: API_Extensions
  declare const VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_32_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_33_SPEC_VERSION: API_Extensions
  declare const VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_35_SPEC_VERSION: API_Extensions
  declare const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION: API_Extensions
  declare const VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_BALLOT_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_39_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_40_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_41_SPEC_VERSION: API_Extensions
  declare const VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_INFO_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_44_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_45_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_46_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION: API_Extensions
  declare const VK_NVX_EXTENSION_48_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_EXTENSION_49_SPEC_VERSION: API_Extensions
  declare const VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_52_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_53_SPEC_VERSION: API_Extensions
  declare const VK_KHR_MULTIVIEW_SPEC_VERSION: API_Extensions
  declare const VK_IMG_FORMAT_PVRTC_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTERNAL_MEMORY_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION: API_Extensions
  declare const VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION: API_Extensions
  declare const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DEVICE_GROUP_SPEC_VERSION: API_Extensions
  declare const VK_EXT_VALIDATION_FLAGS_SPEC_VERSION: API_Extensions
  declare const VK_NN_VI_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION: API_Extensions
  declare const VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION: API_Extensions
  declare const VK_IMG_EXTENSION_69_SPEC_VERSION: API_Extensions
  declare const VK_KHR_MAINTENANCE1_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION: API_Extensions
  declare const VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION: API_Extensions
  declare const VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION: API_Extensions
  declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR: API_Extensions
  declare const VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION: API_Extensions
  declare const VK_KHR_16BIT_STORAGE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION: API_Extensions
  declare const VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION: API_Extensions
  declare const VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION: API_Extensions
  declare const VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DISPLAY_CONTROL_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION: API_Extensions
  declare const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION: API_Extensions
  declare const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION: API_Extensions
  declare const VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION: API_Extensions
  declare const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION: API_Extensions
  declare const VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_101_SPEC_VERSION: API_Extensions
  declare const VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_104_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_HDR_METADATA_SPEC_VERSION: API_Extensions
  declare const VK_IMG_EXTENSION_107_SPEC_VERSION: API_Extensions
  declare const VK_IMG_EXTENSION_108_SPEC_VERSION: API_Extensions
  declare const VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION: API_Extensions
  declare const VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION: API_Extensions
  declare const VK_IMG_EXTENSION_111_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_FENCE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_117_SPEC_VERSION: API_Extensions
  declare const VK_KHR_MAINTENANCE2_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_119_SPEC_VERSION: API_Extensions
  declare const VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION: API_Extensions
  declare const VK_KHR_VARIABLE_POINTERS_SPEC_VERSION: API_Extensions
  declare const VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION: API_Extensions
  declare const VK_MVK_IOS_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_MVK_MACOS_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_MVK_MOLTENVK_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION: API_Extensions
  declare const VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DEBUG_UTILS_SPEC_VERSION: API_Extensions
  declare const VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION: API_Extensions
  declare const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION: API_Extensions
  declare const VK_AMD_GPU_SHADER_INT16_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_134_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_135_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_136_SPEC_VERSION: API_Extensions
  declare const VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION: API_Extensions
  declare const VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_140_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_142_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_143_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION: API_Extensions
  declare const VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION: API_Extensions
  declare const VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION: API_Extensions
  declare const VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION: API_Extensions
  declare const VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION: API_Extensions
  declare const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_151_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_152_SPEC_VERSION: API_Extensions
  declare const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION: API_Extensions
  declare const VK_NV_FILL_RECTANGLE_SPEC_VERSION: API_Extensions
  declare const VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION: API_Extensions
  declare const VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION: API_Extensions
  declare const VK_KHR_BIND_MEMORY_2_SPEC_VERSION: API_Extensions
  declare const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_160_SPEC_VERSION: API_Extensions
  declare const VK_EXT_VALIDATION_CACHE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_164_SPEC_VERSION: API_Extensions
  declare const VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION: API_Extensions
  declare const VK_NV_RAY_TRACING_SPEC_VERSION: API_Extensions
  declare const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_168_SPEC_VERSION: API_Extensions
  declare const VK_KHR_MAINTENANCE3_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION: API_Extensions
  declare const VK_EXT_FILTER_CUBIC_SPEC_VERSION: API_Extensions
  declare const VK_QCOM_extension_172_SPEC_VERSION: API_Extensions
  declare const VK_QCOM_extension_173_SPEC_VERSION: API_Extensions
  declare const VK_QCOM_extension_174_SPEC_VERSION: API_Extensions
  declare const VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_177_SPEC_VERSION: API_Extensions
  declare const VK_KHR_8BIT_STORAGE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION: API_Extensions
  declare const VK_AMD_BUFFER_MARKER_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHADER_CLOCK_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_183_SPEC_VERSION: API_Extensions
  declare const VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION: API_Extensions
  declare const VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_187_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_188_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_189_SPEC_VERSION: API_Extensions
  declare const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION: API_Extensions
  declare const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION: API_Extensions
  declare const VK_GGP_FRAME_TOKEN_SPEC_VERSION: API_Extensions
  declare const VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_EXTENSION_194_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_EXTENSION_195_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_EXTENSION_196_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION: API_Extensions
  declare const VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION: API_Extensions
  declare const VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION: API_Extensions
  declare const VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION: API_Extensions
  declare const VK_NV_MESH_SHADER_SPEC_VERSION: API_Extensions
  declare const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION: API_Extensions
  declare const VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION: API_Extensions
  declare const VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION: API_Extensions
  declare const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION: API_Extensions
  declare const VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_209_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION: API_Extensions
  declare const VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION: API_Extensions
  declare const VK_EXT_PCI_BUS_INFO_SPEC_VERSION: API_Extensions
  declare const VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION: API_Extensions
  declare const VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_216_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_217_SPEC_VERSION: API_Extensions
  declare const VK_EXT_METAL_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_220_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_221_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_223_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_DECORATE_STRING_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_227_SPEC_VERSION: API_Extensions
  declare const VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_229_SPEC_VERSION: API_Extensions
  declare const VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_231_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_232_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_233_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_234_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_235_SPEC_VERSION: API_Extensions
  declare const VK_AMD_EXTENSION_236_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SPIRV_1_4_SPEC_VERSION: API_Extensions
  declare const VK_EXT_MEMORY_BUDGET_SPEC_VERSION: API_Extensions
  declare const VK_EXT_MEMORY_PRIORITY_SPEC_VERSION: API_Extensions
  declare const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION: API_Extensions
  declare const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_242_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_EXTENSION_243_SPEC_VERSION: API_Extensions
  declare const VK_MESA_EXTENSION_244_SPEC_VERSION: API_Extensions
  declare const VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_246_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_VALIDATION_FEATURES_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_249_SPEC_VERSION: API_Extensions
  declare const VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION: API_Extensions
  declare const VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION: API_Extensions
  declare const VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION: API_Extensions
  declare const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_255_SPEC_VERSION: API_Extensions
  declare const VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_HEADLESS_SURFACE_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_258_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_259_SPEC_VERSION: API_Extensions
  declare const VK_EXT_LINE_RASTERIZATION_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_261_SPEC_VERSION: API_Extensions
  declare const VK_EXT_HOST_QUERY_RESET_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_EXTENSION_263_SPEC_VERSION: API_Extensions
  declare const VK_BRCM_EXTENSION_264_SPEC_VERSION: API_Extensions
  declare const VK_BRCM_EXTENSION_265_SPEC_VERSION: API_Extensions
  declare const VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_267_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_268_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_269_SPEC_VERSION: API_Extensions
  declare const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_EXTENSION_271_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_EXTENSION_272_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_EXTENSION_273_SPEC_VERSION: API_Extensions
  declare const VK_INTEL_EXTENSION_274_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_275_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_276_SPEC_VERSION: API_Extensions
  declare const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_278_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_279_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_280_SPEC_VERSION: API_Extensions
  declare const VK_ARM_EXTENSION_281_SPEC_VERSION: API_Extensions
  declare const VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION: API_Extensions
  declare const VK_QCOM_EXTENSION_283_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_284_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_285_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_286_SPEC_VERSION: API_Extensions
  declare const VK_NVX_EXTENSION_287_SPEC_VERSION: API_Extensions
  declare const VK_NVX_EXTENSION_288_SPEC_VERSION: API_Extensions
  declare const VK_EXT_EXTENSION_289_SPEC_VERSION: API_Extensions
  declare const VK_GOOGLE_USER_TYPE_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_291_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_292_SPEC_VERSION: API_Extensions
  declare const VK_NV_EXTENSION_293_SPEC_VERSION: API_Extensions
  declare const VK_KHR_EXTENSION_294_SPEC_VERSION: API_Extensions

  /**
   *
   * @member VK_MAX_PHYSICAL_DEVICE_NAME_SIZE
   * @member VK_UUID_SIZE
   * @member VK_LUID_SIZE
   * @member VK_LUID_SIZE_KHR
   * @member VK_MAX_EXTENSION_NAME_SIZE
   * @member VK_MAX_DESCRIPTION_SIZE
   * @member VK_MAX_MEMORY_TYPES
   * @member VK_MAX_MEMORY_HEAPS
   * @member VK_LOD_CLAMP_NONE
   * @member VK_REMAINING_MIP_LEVELS
   * @member VK_REMAINING_ARRAY_LAYERS
   * @member VK_WHOLE_SIZE
   * @member VK_ATTACHMENT_UNUSED
   * @member VK_TRUE
   * @member VK_FALSE
   * @member VK_QUEUE_FAMILY_IGNORED
   * @member VK_QUEUE_FAMILY_EXTERNAL
   * @member VK_QUEUE_FAMILY_EXTERNAL_KHR
   * @member VK_QUEUE_FAMILY_FOREIGN_EXT
   * @member VK_SUBPASS_EXTERNAL
   * @member VK_MAX_DEVICE_GROUP_SIZE
   * @member VK_MAX_DEVICE_GROUP_SIZE_KHR
   * @member VK_MAX_DRIVER_NAME_SIZE_KHR
   * @member VK_MAX_DRIVER_INFO_SIZE_KHR
   * @member VK_SHADER_UNUSED_NV
   * @member VK_NULL_HANDLE
   */
  export enum API_Constants {
    VK_MAX_PHYSICAL_DEVICE_NAME_SIZE,
    VK_UUID_SIZE,
    VK_LUID_SIZE,
    VK_LUID_SIZE_KHR,
    VK_MAX_EXTENSION_NAME_SIZE,
    VK_MAX_DESCRIPTION_SIZE,
    VK_MAX_MEMORY_TYPES,
    VK_MAX_MEMORY_HEAPS,
    VK_LOD_CLAMP_NONE,
    VK_REMAINING_MIP_LEVELS,
    VK_REMAINING_ARRAY_LAYERS,
    VK_WHOLE_SIZE,
    VK_ATTACHMENT_UNUSED,
    VK_TRUE,
    VK_FALSE,
    VK_QUEUE_FAMILY_IGNORED,
    VK_QUEUE_FAMILY_EXTERNAL,
    VK_QUEUE_FAMILY_EXTERNAL_KHR,
    VK_QUEUE_FAMILY_FOREIGN_EXT,
    VK_SUBPASS_EXTERNAL,
    VK_MAX_DEVICE_GROUP_SIZE,
    VK_MAX_DEVICE_GROUP_SIZE_KHR,
    VK_MAX_DRIVER_NAME_SIZE_KHR,
    VK_MAX_DRIVER_INFO_SIZE_KHR,
    VK_SHADER_UNUSED_NV,
    VK_NULL_HANDLE,
  }

  declare const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: API_Constants
  declare const VK_UUID_SIZE: API_Constants
  declare const VK_LUID_SIZE: API_Constants
  declare const VK_LUID_SIZE_KHR: API_Constants
  declare const VK_MAX_EXTENSION_NAME_SIZE: API_Constants
  declare const VK_MAX_DESCRIPTION_SIZE: API_Constants
  declare const VK_MAX_MEMORY_TYPES: API_Constants
  declare const VK_MAX_MEMORY_HEAPS: API_Constants
  declare const VK_LOD_CLAMP_NONE: API_Constants
  declare const VK_REMAINING_MIP_LEVELS: API_Constants
  declare const VK_REMAINING_ARRAY_LAYERS: API_Constants
  declare const VK_WHOLE_SIZE: API_Constants
  declare const VK_ATTACHMENT_UNUSED: API_Constants
  declare const VK_TRUE: API_Constants
  declare const VK_FALSE: API_Constants
  declare const VK_QUEUE_FAMILY_IGNORED: API_Constants
  declare const VK_QUEUE_FAMILY_EXTERNAL: API_Constants
  declare const VK_QUEUE_FAMILY_EXTERNAL_KHR: API_Constants
  declare const VK_QUEUE_FAMILY_FOREIGN_EXT: API_Constants
  declare const VK_SUBPASS_EXTERNAL: API_Constants
  declare const VK_MAX_DEVICE_GROUP_SIZE: API_Constants
  declare const VK_MAX_DEVICE_GROUP_SIZE_KHR: API_Constants
  declare const VK_MAX_DRIVER_NAME_SIZE_KHR: API_Constants
  declare const VK_MAX_DRIVER_INFO_SIZE_KHR: API_Constants
  declare const VK_SHADER_UNUSED_NV: API_Constants
  declare const VK_NULL_HANDLE: API_Constants

  /**
   * Layout of image and image subresources
   * @member VK_IMAGE_LAYOUT_UNDEFINED does not support device access. This layout 'must' only be used as the 'initialLayout' member of 'VkImageCreateInfo' or 'VkAttachmentDescription', or as the 'oldLayout' in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.
   * @member VK_IMAGE_LAYOUT_GENERAL supports all types of device access.
   * @member VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL 'must' only be used as a color or resolve attachment in a 'VkFramebuffer'. This layout is valid only for image subresources of images created with the 'VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT' usage bit enabled.
   * @member VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL 'must' only be used as a depth/stencil or depth/stencil resolve
   * @member VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL
   * @member VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
   * @member VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
   * @member VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
   * @member VK_IMAGE_LAYOUT_PREINITIALIZED does not support device access. This layout 'must' only be used as the 'initialLayout' member of 'VkImageCreateInfo' or 'VkAttachmentDescription', or as the 'oldLayout' in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data 'can' be written to memory immediately, without first executing a layout transition. Currently, 'VK_IMAGE_LAYOUT_PREINITIALIZED' is only useful with <<glossary-linear-resource,linear>> images because there is not a standard layout defined for 'VK_IMAGE_TILING_OPTIMAL' images.
   * @member VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
   * @member VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
   * @member VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
   * @member VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
   * @member VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV
   * @member VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT
   * @member VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR
   * @member VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR
   */
  export enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_GENERAL,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV,
    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
  }

  declare const VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout
  declare const VK_IMAGE_LAYOUT_GENERAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout
  declare const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout
  declare const VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout
  declare const VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout
  declare const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout
  declare const VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout
  declare const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout
  declare const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout

  /**
   * Specify how contents of an attachment are treated at the beginning of a subpass
   * @member VK_ATTACHMENT_LOAD_OP_LOAD specifies that the previous contents of the image within the render area will be preserved. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_READ_BIT'.
   * @member VK_ATTACHMENT_LOAD_OP_CLEAR specifies that the contents within the render area will be cleared to a uniform value, which is specified when a render pass instance is begun. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
   * @member VK_ATTACHMENT_LOAD_OP_DONT_CARE specifies that the previous contents within the area need not be preserved; the contents of the attachment will be 'undefined' inside the render area. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
   */
  export enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_CLEAR,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE,
  }

  declare const VK_ATTACHMENT_LOAD_OP_LOAD: VkAttachmentLoadOp
  declare const VK_ATTACHMENT_LOAD_OP_CLEAR: VkAttachmentLoadOp
  declare const VK_ATTACHMENT_LOAD_OP_DONT_CARE: VkAttachmentLoadOp

  /**
   * Specify how contents of an attachment are treated at the end of a subpass
   * @member VK_ATTACHMENT_STORE_OP_STORE specifies the contents generated during the render pass and within the render area are written to memory. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
   * @member VK_ATTACHMENT_STORE_OP_DONT_CARE specifies the contents within the render area are not needed after rendering, and 'may' be discarded; the contents of the attachment will be 'undefined' inside the render area. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
   */
  export enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_DONT_CARE,
  }

  declare const VK_ATTACHMENT_STORE_OP_STORE: VkAttachmentStoreOp
  declare const VK_ATTACHMENT_STORE_OP_DONT_CARE: VkAttachmentStoreOp

  /**
   * Specifies the type of an image object
   * @member VK_IMAGE_TYPE_1D specifies a one-dimensional image.
   * @member VK_IMAGE_TYPE_2D specifies a two-dimensional image.
   * @member VK_IMAGE_TYPE_3D specifies a three-dimensional image.
   */
  export enum VkImageType {
    VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_2D,
    VK_IMAGE_TYPE_3D,
  }

  declare const VK_IMAGE_TYPE_1D: VkImageType
  declare const VK_IMAGE_TYPE_2D: VkImageType
  declare const VK_IMAGE_TYPE_3D: VkImageType

  /**
   * Specifies the tiling arrangement of data in an image
   * @member VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more optimal memory access).
   * @member VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row).
   * @member VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT indicates that the image's tiling is defined by a <<glossary-drm-format-modifier,Linux DRM format modifier>>. The modifier is specified at image creation with 'VkImageDrmFormatModifierListCreateInfoEXT' or 'VkImageDrmFormatModifierExplicitCreateInfoEXT', and 'can' be queried with 'vkGetImageDrmFormatModifierPropertiesEXT'.
   */
  export enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
  }

  declare const VK_IMAGE_TILING_OPTIMAL: VkImageTiling
  declare const VK_IMAGE_TILING_LINEAR: VkImageTiling
  declare const VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: VkImageTiling

  /**
   * Image view types
   * @member VK_IMAGE_VIEW_TYPE_1D
   * @member VK_IMAGE_VIEW_TYPE_2D
   * @member VK_IMAGE_VIEW_TYPE_3D
   * @member VK_IMAGE_VIEW_TYPE_CUBE
   * @member VK_IMAGE_VIEW_TYPE_1D_ARRAY
   * @member VK_IMAGE_VIEW_TYPE_2D_ARRAY
   * @member VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
   */
  export enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_2D,
    VK_IMAGE_VIEW_TYPE_3D,
    VK_IMAGE_VIEW_TYPE_CUBE,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
  }

  declare const VK_IMAGE_VIEW_TYPE_1D: VkImageViewType
  declare const VK_IMAGE_VIEW_TYPE_2D: VkImageViewType
  declare const VK_IMAGE_VIEW_TYPE_3D: VkImageViewType
  declare const VK_IMAGE_VIEW_TYPE_CUBE: VkImageViewType
  declare const VK_IMAGE_VIEW_TYPE_1D_ARRAY: VkImageViewType
  declare const VK_IMAGE_VIEW_TYPE_2D_ARRAY: VkImageViewType
  declare const VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: VkImageViewType

  /**
   * Enumerant specifying a command buffer level
   * @member VK_COMMAND_BUFFER_LEVEL_PRIMARY specifies a primary command buffer.
   * @member VK_COMMAND_BUFFER_LEVEL_SECONDARY specifies a secondary command buffer.
   */
  export enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY,
  }

  declare const VK_COMMAND_BUFFER_LEVEL_PRIMARY: VkCommandBufferLevel
  declare const VK_COMMAND_BUFFER_LEVEL_SECONDARY: VkCommandBufferLevel

  /**
   * Specify how a component is swizzled
   * @member VK_COMPONENT_SWIZZLE_IDENTITY specifies that the component is set to the identity swizzle.
   * @member VK_COMPONENT_SWIZZLE_ZERO specifies that the component is set to zero.
   * @member VK_COMPONENT_SWIZZLE_ONE specifies that the component is set to either 1 or 1.0, depending on whether the type of the image view format is integer or floating-point respectively, as determined by the <<formats-definition,Format Definition>> section for each 'VkFormat'.
   * @member VK_COMPONENT_SWIZZLE_R specifies that the component is set to the value of the R component of the image.
   * @member VK_COMPONENT_SWIZZLE_G specifies that the component is set to the value of the G component of the image.
   * @member VK_COMPONENT_SWIZZLE_B specifies that the component is set to the value of the B component of the image.
   * @member VK_COMPONENT_SWIZZLE_A specifies that the component is set to the value of the A component of the image.
   */
  export enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_ZERO,
    VK_COMPONENT_SWIZZLE_ONE,
    VK_COMPONENT_SWIZZLE_R,
    VK_COMPONENT_SWIZZLE_G,
    VK_COMPONENT_SWIZZLE_B,
    VK_COMPONENT_SWIZZLE_A,
  }

  declare const VK_COMPONENT_SWIZZLE_IDENTITY: VkComponentSwizzle
  declare const VK_COMPONENT_SWIZZLE_ZERO: VkComponentSwizzle
  declare const VK_COMPONENT_SWIZZLE_ONE: VkComponentSwizzle
  declare const VK_COMPONENT_SWIZZLE_R: VkComponentSwizzle
  declare const VK_COMPONENT_SWIZZLE_G: VkComponentSwizzle
  declare const VK_COMPONENT_SWIZZLE_B: VkComponentSwizzle
  declare const VK_COMPONENT_SWIZZLE_A: VkComponentSwizzle

  /**
   * Specifies the type of a descriptor in a descriptor set
   * @member VK_DESCRIPTOR_TYPE_SAMPLER specifies a <<descriptorsets-sampler, sampler descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER specifies a <<descriptorsets-combinedimagesampler, combined image sampler descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE specifies a <<descriptorsets-sampledimage, sampled image descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_STORAGE_IMAGE specifies a <<descriptorsets-storageimage, storage image descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER specifies a <<descriptorsets-uniformtexelbuffer, uniform texel buffer descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER specifies a <<descriptorsets-storagetexelbuffer, storage texel buffer descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER specifies a <<descriptorsets-uniformbuffer, uniform buffer descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_STORAGE_BUFFER specifies a <<descriptorsets-storagebuffer, storage buffer descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC specifies a <<descriptorsets-uniformbufferdynamic, dynamic uniform buffer descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC specifies a <<descriptorsets-storagebufferdynamic, dynamic storage buffer descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT specifies an <<descriptorsets-inputattachment, input attachment descriptor>>.
   * @member VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT specifies an <<descriptorsets-inlineuniformblock, inline uniform block>>.
   * @member VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
   */
  export enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
  }

  declare const VK_DESCRIPTOR_TYPE_SAMPLER: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: VkDescriptorType
  declare const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV: VkDescriptorType

  /**
   * Specify the type of queries managed by a query pool
   * @member VK_QUERY_TYPE_OCCLUSION specifies an <<queries-occlusion, occlusion query>>.
   * @member VK_QUERY_TYPE_PIPELINE_STATISTICS specifies a <<queries-pipestats, pipeline statistics query>>.
   * @member VK_QUERY_TYPE_TIMESTAMP specifies a <<queries-timestamps, timestamp query>>.
   * @member VK_QUERY_TYPE_RESERVED_8
   * @member VK_QUERY_TYPE_RESERVED_4
   * @member VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT specifies a <<queries-transform-feedback, transform feedback query>>.
   * @member VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
   * @member VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL
   */
  export enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_PIPELINE_STATISTICS,
    VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RESERVED_8,
    VK_QUERY_TYPE_RESERVED_4,
    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT,
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV,
    VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL,
  }

  declare const VK_QUERY_TYPE_OCCLUSION: VkQueryType
  declare const VK_QUERY_TYPE_PIPELINE_STATISTICS: VkQueryType
  declare const VK_QUERY_TYPE_TIMESTAMP: VkQueryType
  declare const VK_QUERY_TYPE_RESERVED_8: VkQueryType
  declare const VK_QUERY_TYPE_RESERVED_4: VkQueryType
  declare const VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT: VkQueryType
  declare const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: VkQueryType
  declare const VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL: VkQueryType

  /**
   * Specify border color used for texture lookups
   * @member VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK specifies a transparent, floating-point format, black color.
   * @member VK_BORDER_COLOR_INT_TRANSPARENT_BLACK specifies a transparent, integer format, black color.
   * @member VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK specifies an opaque, floating-point format, black color.
   * @member VK_BORDER_COLOR_INT_OPAQUE_BLACK specifies an opaque, integer format, black color.
   * @member VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE specifies an opaque, floating-point format, white color.
   * @member VK_BORDER_COLOR_INT_OPAQUE_WHITE specifies an opaque, integer format, white color.
   */
  export enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE,
  }

  declare const VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: VkBorderColor
  declare const VK_BORDER_COLOR_INT_TRANSPARENT_BLACK: VkBorderColor
  declare const VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK: VkBorderColor
  declare const VK_BORDER_COLOR_INT_OPAQUE_BLACK: VkBorderColor
  declare const VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE: VkBorderColor
  declare const VK_BORDER_COLOR_INT_OPAQUE_WHITE: VkBorderColor

  /**
   * Specify the bind point of a pipeline object to a command buffer
   * @member VK_PIPELINE_BIND_POINT_GRAPHICS specifies binding as a graphics pipeline.
   * @member VK_PIPELINE_BIND_POINT_COMPUTE specifies binding as a compute pipeline.
   * @member VK_PIPELINE_BIND_POINT_RAY_TRACING_NV specifies binding as a ray tracing pipeline.
   */
  export enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV,
  }

  declare const VK_PIPELINE_BIND_POINT_GRAPHICS: VkPipelineBindPoint
  declare const VK_PIPELINE_BIND_POINT_COMPUTE: VkPipelineBindPoint
  declare const VK_PIPELINE_BIND_POINT_RAY_TRACING_NV: VkPipelineBindPoint

  /**
   * Encode pipeline cache version
   * @member VK_PIPELINE_CACHE_HEADER_VERSION_ONE
   */
  export enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
  }

  declare const VK_PIPELINE_CACHE_HEADER_VERSION_ONE: VkPipelineCacheHeaderVersion

  /**
   * Supported primitive topologies
   * @member VK_PRIMITIVE_TOPOLOGY_POINT_LIST specifies a series of <<drawing-point-lists,separate point primitives>>.
   * @member VK_PRIMITIVE_TOPOLOGY_LINE_LIST specifies a series of <<drawing-line-lists,separate line primitives>>.
   * @member VK_PRIMITIVE_TOPOLOGY_LINE_STRIP specifies a series of <<drawing-line-strips,connected line primitives>> with consecutive lines sharing a vertex.
   * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST specifies a series of <<drawing-triangle-lists,separate triangle primitives>>.
   * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP specifies a series of <<drawing-triangle-strips,connected triangle primitives>> with consecutive triangles sharing an edge.
   * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN specifies a series of <<drawing-triangle-fans,connected triangle primitives>> with all triangles sharing a common vertex.
   * @member VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY specifies a series <<drawing-line-lists-with-adjacency,separate line primitives with adjacency>>.
   * @member VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY specifies a series <<drawing-line-strips-with-adjacency,connected line primitives with adjacency>>, with consecutive primitives sharing three vertices.
   * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY specifies a series <<drawing-line-lists-with-adjacency,separate triangle primitives with adjacency>>.
   * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY specifies <<drawing-line-lists-with-adjacency,connected triangle primitives with adjacency>>, with consecutive triangles sharing an edge.
   * @member VK_PRIMITIVE_TOPOLOGY_PATCH_LIST specifies <<drawing-patch-lists,separate patch primitives>>.
   */
  export enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
  }

  declare const VK_PRIMITIVE_TOPOLOGY_POINT_LIST: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_LINE_LIST: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology
  declare const VK_PRIMITIVE_TOPOLOGY_PATCH_LIST: VkPrimitiveTopology

  /**
   * Buffer and image sharing modes
   * @member VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.
   * @member VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.
   */
  export enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_CONCURRENT,
  }

  declare const VK_SHARING_MODE_EXCLUSIVE: VkSharingMode
  declare const VK_SHARING_MODE_CONCURRENT: VkSharingMode

  /**
   * Type of index buffer indices
   * @member VK_INDEX_TYPE_UINT16 specifies that indices are 16-bit unsigned integer values.
   * @member VK_INDEX_TYPE_UINT32 specifies that indices are 32-bit unsigned integer values.
   * @member VK_INDEX_TYPE_NONE_NV specifies that no indices are provided.
   * @member VK_INDEX_TYPE_UINT8_EXT
   */
  export enum VkIndexType {
    VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_NONE_NV,
    VK_INDEX_TYPE_UINT8_EXT,
  }

  declare const VK_INDEX_TYPE_UINT16: VkIndexType
  declare const VK_INDEX_TYPE_UINT32: VkIndexType
  declare const VK_INDEX_TYPE_NONE_NV: VkIndexType
  declare const VK_INDEX_TYPE_UINT8_EXT: VkIndexType

  /**
   * Specify filters used for texture lookups
   * @member VK_FILTER_NEAREST specifies nearest filtering.
   * @member VK_FILTER_LINEAR specifies linear filtering.
   * @member VK_FILTER_CUBIC_IMG
   * @member VK_FILTER_CUBIC_EXT
   */
  export enum VkFilter {
    VK_FILTER_NEAREST,
    VK_FILTER_LINEAR,
    VK_FILTER_CUBIC_IMG,
    VK_FILTER_CUBIC_EXT,
  }

  declare const VK_FILTER_NEAREST: VkFilter
  declare const VK_FILTER_LINEAR: VkFilter
  declare const VK_FILTER_CUBIC_IMG: VkFilter
  declare const VK_FILTER_CUBIC_EXT: VkFilter

  /**
   * Specify mipmap mode used for texture lookups
   * @member VK_SAMPLER_MIPMAP_MODE_NEAREST specifies nearest filtering.
   * @member VK_SAMPLER_MIPMAP_MODE_LINEAR specifies linear filtering.
   */
  export enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_LINEAR,
  }

  declare const VK_SAMPLER_MIPMAP_MODE_NEAREST: VkSamplerMipmapMode
  declare const VK_SAMPLER_MIPMAP_MODE_LINEAR: VkSamplerMipmapMode

  /**
   * Specify behavior of sampling with texture coordinates outside an image
   * @member VK_SAMPLER_ADDRESS_MODE_REPEAT specifies that the repeat wrap mode will be used.
   * @member VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT specifies that the mirrored repeat wrap mode will be used.
   * @member VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE specifies that the clamp to edge wrap mode will be used.
   * @member VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER specifies that the clamp to border wrap mode will be used.
   * @member VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR
   */
  export enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR,
  }

  declare const VK_SAMPLER_ADDRESS_MODE_REPEAT: VkSamplerAddressMode
  declare const VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: VkSamplerAddressMode
  declare const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: VkSamplerAddressMode
  declare const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: VkSamplerAddressMode
  declare const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR: VkSamplerAddressMode

  /**
   * Stencil comparison function
   * @member VK_COMPARE_OP_NEVER
   * @member VK_COMPARE_OP_LESS
   * @member VK_COMPARE_OP_EQUAL
   * @member VK_COMPARE_OP_LESS_OR_EQUAL
   * @member VK_COMPARE_OP_GREATER
   * @member VK_COMPARE_OP_NOT_EQUAL
   * @member VK_COMPARE_OP_GREATER_OR_EQUAL
   * @member VK_COMPARE_OP_ALWAYS specifies that the test always passes.
   */
  export enum VkCompareOp {
    VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_LESS,
    VK_COMPARE_OP_EQUAL,
    VK_COMPARE_OP_LESS_OR_EQUAL,
    VK_COMPARE_OP_GREATER,
    VK_COMPARE_OP_NOT_EQUAL,
    VK_COMPARE_OP_GREATER_OR_EQUAL,
    VK_COMPARE_OP_ALWAYS,
  }

  declare const VK_COMPARE_OP_NEVER: VkCompareOp
  declare const VK_COMPARE_OP_LESS: VkCompareOp
  declare const VK_COMPARE_OP_EQUAL: VkCompareOp
  declare const VK_COMPARE_OP_LESS_OR_EQUAL: VkCompareOp
  declare const VK_COMPARE_OP_GREATER: VkCompareOp
  declare const VK_COMPARE_OP_NOT_EQUAL: VkCompareOp
  declare const VK_COMPARE_OP_GREATER_OR_EQUAL: VkCompareOp
  declare const VK_COMPARE_OP_ALWAYS: VkCompareOp

  /**
   * Control polygon rasterization mode
   * @member VK_POLYGON_MODE_FILL specifies that polygons are rendered using the polygon rasterization rules in this section.
   * @member VK_POLYGON_MODE_LINE specifies that polygon edges are drawn as line segments.
   * @member VK_POLYGON_MODE_POINT specifies that polygon vertices are drawn as reference.
   * @member VK_POLYGON_MODE_FILL_RECTANGLE_NV specifies that polygons are rendered using polygon rasterization rules, modified to consider a sample within the primitive if the sample location is inside the axis-aligned bounding box of the triangle after projection. Note that the barycentric weights used in attribute interpolation 'can' extend outside the range [eq]#[0,1]# when these primitives are shaded. Special treatment is given to a sample position on the boundary edge of the bounding box. In such a case, if two rectangles lie on either side of a common edge (with identical endreference) on which a sample position lies, then exactly one of the triangles 'must' produce a fragment that covers that sample during rasterization.+Polygons rendered in 'VK_POLYGON_MODE_FILL_RECTANGLE_NV' mode 'may' be clipped by the frustum or by user clip planes. If clipping is applied, the triangle is culled rather than clipped.+Area calculation and facingness are determined for 'VK_POLYGON_MODE_FILL_RECTANGLE_NV' mode using the triangle's vertices.
   */
  export enum VkPolygonMode {
    VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_LINE,
    VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_FILL_RECTANGLE_NV,
  }

  declare const VK_POLYGON_MODE_FILL: VkPolygonMode
  declare const VK_POLYGON_MODE_LINE: VkPolygonMode
  declare const VK_POLYGON_MODE_POINT: VkPolygonMode
  declare const VK_POLYGON_MODE_FILL_RECTANGLE_NV: VkPolygonMode

  /**
   * Interpret polygon front-facing orientation
   * @member VK_FRONT_FACE_COUNTER_CLOCKWISE specifies that a triangle with positive area is considered front-facing.
   * @member VK_FRONT_FACE_CLOCKWISE specifies that a triangle with negative area is considered front-facing.
   */
  export enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_CLOCKWISE,
  }

  declare const VK_FRONT_FACE_COUNTER_CLOCKWISE: VkFrontFace
  declare const VK_FRONT_FACE_CLOCKWISE: VkFrontFace

  /**
   * Framebuffer blending factors
   * @member VK_BLEND_FACTOR_ZERO
   * @member VK_BLEND_FACTOR_ONE
   * @member VK_BLEND_FACTOR_SRC_COLOR
   * @member VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR
   * @member VK_BLEND_FACTOR_DST_COLOR
   * @member VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR
   * @member VK_BLEND_FACTOR_SRC_ALPHA
   * @member VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA
   * @member VK_BLEND_FACTOR_DST_ALPHA
   * @member VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA
   * @member VK_BLEND_FACTOR_CONSTANT_COLOR
   * @member VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR
   * @member VK_BLEND_FACTOR_CONSTANT_ALPHA
   * @member VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA
   * @member VK_BLEND_FACTOR_SRC_ALPHA_SATURATE
   * @member VK_BLEND_FACTOR_SRC1_COLOR
   * @member VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR
   * @member VK_BLEND_FACTOR_SRC1_ALPHA
   * @member VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
   */
  export enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_ONE,
    VK_BLEND_FACTOR_SRC_COLOR,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    VK_BLEND_FACTOR_DST_COLOR,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    VK_BLEND_FACTOR_SRC_ALPHA,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    VK_BLEND_FACTOR_DST_ALPHA,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    VK_BLEND_FACTOR_CONSTANT_COLOR,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
    VK_BLEND_FACTOR_CONSTANT_ALPHA,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    VK_BLEND_FACTOR_SRC1_COLOR,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    VK_BLEND_FACTOR_SRC1_ALPHA,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
  }

  declare const VK_BLEND_FACTOR_ZERO: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE: VkBlendFactor
  declare const VK_BLEND_FACTOR_SRC_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_DST_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_SRC_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_DST_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_CONSTANT_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_CONSTANT_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_SRC_ALPHA_SATURATE: VkBlendFactor
  declare const VK_BLEND_FACTOR_SRC1_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: VkBlendFactor
  declare const VK_BLEND_FACTOR_SRC1_ALPHA: VkBlendFactor
  declare const VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: VkBlendFactor

  /**
   * Framebuffer blending operations
   * @member VK_BLEND_OP_ADD
   * @member VK_BLEND_OP_SUBTRACT
   * @member VK_BLEND_OP_REVERSE_SUBTRACT
   * @member VK_BLEND_OP_MIN
   * @member VK_BLEND_OP_MAX
   * @member VK_BLEND_OP_ZERO_EXT
   * @member VK_BLEND_OP_SRC_EXT
   * @member VK_BLEND_OP_DST_EXT
   * @member VK_BLEND_OP_SRC_OVER_EXT
   * @member VK_BLEND_OP_DST_OVER_EXT
   * @member VK_BLEND_OP_SRC_IN_EXT
   * @member VK_BLEND_OP_DST_IN_EXT
   * @member VK_BLEND_OP_SRC_OUT_EXT
   * @member VK_BLEND_OP_DST_OUT_EXT
   * @member VK_BLEND_OP_SRC_ATOP_EXT
   * @member VK_BLEND_OP_DST_ATOP_EXT
   * @member VK_BLEND_OP_XOR_EXT
   * @member VK_BLEND_OP_MULTIPLY_EXT
   * @member VK_BLEND_OP_SCREEN_EXT
   * @member VK_BLEND_OP_OVERLAY_EXT
   * @member VK_BLEND_OP_DARKEN_EXT
   * @member VK_BLEND_OP_LIGHTEN_EXT
   * @member VK_BLEND_OP_COLORDODGE_EXT
   * @member VK_BLEND_OP_COLORBURN_EXT
   * @member VK_BLEND_OP_HARDLIGHT_EXT
   * @member VK_BLEND_OP_SOFTLIGHT_EXT
   * @member VK_BLEND_OP_DIFFERENCE_EXT
   * @member VK_BLEND_OP_EXCLUSION_EXT
   * @member VK_BLEND_OP_INVERT_EXT
   * @member VK_BLEND_OP_INVERT_RGB_EXT
   * @member VK_BLEND_OP_LINEARDODGE_EXT
   * @member VK_BLEND_OP_LINEARBURN_EXT
   * @member VK_BLEND_OP_VIVIDLIGHT_EXT
   * @member VK_BLEND_OP_LINEARLIGHT_EXT
   * @member VK_BLEND_OP_PINLIGHT_EXT
   * @member VK_BLEND_OP_HARDMIX_EXT
   * @member VK_BLEND_OP_HSL_HUE_EXT
   * @member VK_BLEND_OP_HSL_SATURATION_EXT
   * @member VK_BLEND_OP_HSL_COLOR_EXT
   * @member VK_BLEND_OP_HSL_LUMINOSITY_EXT
   * @member VK_BLEND_OP_PLUS_EXT
   * @member VK_BLEND_OP_PLUS_CLAMPED_EXT
   * @member VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT
   * @member VK_BLEND_OP_PLUS_DARKER_EXT
   * @member VK_BLEND_OP_MINUS_EXT
   * @member VK_BLEND_OP_MINUS_CLAMPED_EXT
   * @member VK_BLEND_OP_CONTRAST_EXT
   * @member VK_BLEND_OP_INVERT_OVG_EXT
   * @member VK_BLEND_OP_RED_EXT
   * @member VK_BLEND_OP_GREEN_EXT
   * @member VK_BLEND_OP_BLUE_EXT
   */
  export enum VkBlendOp {
    VK_BLEND_OP_ADD,
    VK_BLEND_OP_SUBTRACT,
    VK_BLEND_OP_REVERSE_SUBTRACT,
    VK_BLEND_OP_MIN,
    VK_BLEND_OP_MAX,
    VK_BLEND_OP_ZERO_EXT,
    VK_BLEND_OP_SRC_EXT,
    VK_BLEND_OP_DST_EXT,
    VK_BLEND_OP_SRC_OVER_EXT,
    VK_BLEND_OP_DST_OVER_EXT,
    VK_BLEND_OP_SRC_IN_EXT,
    VK_BLEND_OP_DST_IN_EXT,
    VK_BLEND_OP_SRC_OUT_EXT,
    VK_BLEND_OP_DST_OUT_EXT,
    VK_BLEND_OP_SRC_ATOP_EXT,
    VK_BLEND_OP_DST_ATOP_EXT,
    VK_BLEND_OP_XOR_EXT,
    VK_BLEND_OP_MULTIPLY_EXT,
    VK_BLEND_OP_SCREEN_EXT,
    VK_BLEND_OP_OVERLAY_EXT,
    VK_BLEND_OP_DARKEN_EXT,
    VK_BLEND_OP_LIGHTEN_EXT,
    VK_BLEND_OP_COLORDODGE_EXT,
    VK_BLEND_OP_COLORBURN_EXT,
    VK_BLEND_OP_HARDLIGHT_EXT,
    VK_BLEND_OP_SOFTLIGHT_EXT,
    VK_BLEND_OP_DIFFERENCE_EXT,
    VK_BLEND_OP_EXCLUSION_EXT,
    VK_BLEND_OP_INVERT_EXT,
    VK_BLEND_OP_INVERT_RGB_EXT,
    VK_BLEND_OP_LINEARDODGE_EXT,
    VK_BLEND_OP_LINEARBURN_EXT,
    VK_BLEND_OP_VIVIDLIGHT_EXT,
    VK_BLEND_OP_LINEARLIGHT_EXT,
    VK_BLEND_OP_PINLIGHT_EXT,
    VK_BLEND_OP_HARDMIX_EXT,
    VK_BLEND_OP_HSL_HUE_EXT,
    VK_BLEND_OP_HSL_SATURATION_EXT,
    VK_BLEND_OP_HSL_COLOR_EXT,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT,
    VK_BLEND_OP_PLUS_EXT,
    VK_BLEND_OP_PLUS_CLAMPED_EXT,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
    VK_BLEND_OP_PLUS_DARKER_EXT,
    VK_BLEND_OP_MINUS_EXT,
    VK_BLEND_OP_MINUS_CLAMPED_EXT,
    VK_BLEND_OP_CONTRAST_EXT,
    VK_BLEND_OP_INVERT_OVG_EXT,
    VK_BLEND_OP_RED_EXT,
    VK_BLEND_OP_GREEN_EXT,
    VK_BLEND_OP_BLUE_EXT,
  }

  declare const VK_BLEND_OP_ADD: VkBlendOp
  declare const VK_BLEND_OP_SUBTRACT: VkBlendOp
  declare const VK_BLEND_OP_REVERSE_SUBTRACT: VkBlendOp
  declare const VK_BLEND_OP_MIN: VkBlendOp
  declare const VK_BLEND_OP_MAX: VkBlendOp
  declare const VK_BLEND_OP_ZERO_EXT: VkBlendOp
  declare const VK_BLEND_OP_SRC_EXT: VkBlendOp
  declare const VK_BLEND_OP_DST_EXT: VkBlendOp
  declare const VK_BLEND_OP_SRC_OVER_EXT: VkBlendOp
  declare const VK_BLEND_OP_DST_OVER_EXT: VkBlendOp
  declare const VK_BLEND_OP_SRC_IN_EXT: VkBlendOp
  declare const VK_BLEND_OP_DST_IN_EXT: VkBlendOp
  declare const VK_BLEND_OP_SRC_OUT_EXT: VkBlendOp
  declare const VK_BLEND_OP_DST_OUT_EXT: VkBlendOp
  declare const VK_BLEND_OP_SRC_ATOP_EXT: VkBlendOp
  declare const VK_BLEND_OP_DST_ATOP_EXT: VkBlendOp
  declare const VK_BLEND_OP_XOR_EXT: VkBlendOp
  declare const VK_BLEND_OP_MULTIPLY_EXT: VkBlendOp
  declare const VK_BLEND_OP_SCREEN_EXT: VkBlendOp
  declare const VK_BLEND_OP_OVERLAY_EXT: VkBlendOp
  declare const VK_BLEND_OP_DARKEN_EXT: VkBlendOp
  declare const VK_BLEND_OP_LIGHTEN_EXT: VkBlendOp
  declare const VK_BLEND_OP_COLORDODGE_EXT: VkBlendOp
  declare const VK_BLEND_OP_COLORBURN_EXT: VkBlendOp
  declare const VK_BLEND_OP_HARDLIGHT_EXT: VkBlendOp
  declare const VK_BLEND_OP_SOFTLIGHT_EXT: VkBlendOp
  declare const VK_BLEND_OP_DIFFERENCE_EXT: VkBlendOp
  declare const VK_BLEND_OP_EXCLUSION_EXT: VkBlendOp
  declare const VK_BLEND_OP_INVERT_EXT: VkBlendOp
  declare const VK_BLEND_OP_INVERT_RGB_EXT: VkBlendOp
  declare const VK_BLEND_OP_LINEARDODGE_EXT: VkBlendOp
  declare const VK_BLEND_OP_LINEARBURN_EXT: VkBlendOp
  declare const VK_BLEND_OP_VIVIDLIGHT_EXT: VkBlendOp
  declare const VK_BLEND_OP_LINEARLIGHT_EXT: VkBlendOp
  declare const VK_BLEND_OP_PINLIGHT_EXT: VkBlendOp
  declare const VK_BLEND_OP_HARDMIX_EXT: VkBlendOp
  declare const VK_BLEND_OP_HSL_HUE_EXT: VkBlendOp
  declare const VK_BLEND_OP_HSL_SATURATION_EXT: VkBlendOp
  declare const VK_BLEND_OP_HSL_COLOR_EXT: VkBlendOp
  declare const VK_BLEND_OP_HSL_LUMINOSITY_EXT: VkBlendOp
  declare const VK_BLEND_OP_PLUS_EXT: VkBlendOp
  declare const VK_BLEND_OP_PLUS_CLAMPED_EXT: VkBlendOp
  declare const VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT: VkBlendOp
  declare const VK_BLEND_OP_PLUS_DARKER_EXT: VkBlendOp
  declare const VK_BLEND_OP_MINUS_EXT: VkBlendOp
  declare const VK_BLEND_OP_MINUS_CLAMPED_EXT: VkBlendOp
  declare const VK_BLEND_OP_CONTRAST_EXT: VkBlendOp
  declare const VK_BLEND_OP_INVERT_OVG_EXT: VkBlendOp
  declare const VK_BLEND_OP_RED_EXT: VkBlendOp
  declare const VK_BLEND_OP_GREEN_EXT: VkBlendOp
  declare const VK_BLEND_OP_BLUE_EXT: VkBlendOp

  /**
   * Stencil comparison function
   * @member VK_STENCIL_OP_KEEP keeps the current value.
   * @member VK_STENCIL_OP_ZERO sets the value to 0.
   * @member VK_STENCIL_OP_REPLACE
   * @member VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.
   * @member VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.
   * @member VK_STENCIL_OP_INVERT bitwise-inverts the current value.
   * @member VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.
   * @member VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.
   */
  export enum VkStencilOp {
    VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_ZERO,
    VK_STENCIL_OP_REPLACE,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP,
    VK_STENCIL_OP_INVERT,
    VK_STENCIL_OP_INCREMENT_AND_WRAP,
    VK_STENCIL_OP_DECREMENT_AND_WRAP,
  }

  declare const VK_STENCIL_OP_KEEP: VkStencilOp
  declare const VK_STENCIL_OP_ZERO: VkStencilOp
  declare const VK_STENCIL_OP_REPLACE: VkStencilOp
  declare const VK_STENCIL_OP_INCREMENT_AND_CLAMP: VkStencilOp
  declare const VK_STENCIL_OP_DECREMENT_AND_CLAMP: VkStencilOp
  declare const VK_STENCIL_OP_INVERT: VkStencilOp
  declare const VK_STENCIL_OP_INCREMENT_AND_WRAP: VkStencilOp
  declare const VK_STENCIL_OP_DECREMENT_AND_WRAP: VkStencilOp

  /**
   * Framebuffer logical operations
   * @member VK_LOGIC_OP_CLEAR
   * @member VK_LOGIC_OP_AND
   * @member VK_LOGIC_OP_AND_REVERSE
   * @member VK_LOGIC_OP_COPY
   * @member VK_LOGIC_OP_AND_INVERTED
   * @member VK_LOGIC_OP_NO_OP
   * @member VK_LOGIC_OP_XOR
   * @member VK_LOGIC_OP_OR
   * @member VK_LOGIC_OP_NOR
   * @member VK_LOGIC_OP_EQUIVALENT
   * @member VK_LOGIC_OP_INVERT
   * @member VK_LOGIC_OP_OR_REVERSE
   * @member VK_LOGIC_OP_COPY_INVERTED
   * @member VK_LOGIC_OP_OR_INVERTED
   * @member VK_LOGIC_OP_NAND
   * @member VK_LOGIC_OP_SET
   */
  export enum VkLogicOp {
    VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_AND,
    VK_LOGIC_OP_AND_REVERSE,
    VK_LOGIC_OP_COPY,
    VK_LOGIC_OP_AND_INVERTED,
    VK_LOGIC_OP_NO_OP,
    VK_LOGIC_OP_XOR,
    VK_LOGIC_OP_OR,
    VK_LOGIC_OP_NOR,
    VK_LOGIC_OP_EQUIVALENT,
    VK_LOGIC_OP_INVERT,
    VK_LOGIC_OP_OR_REVERSE,
    VK_LOGIC_OP_COPY_INVERTED,
    VK_LOGIC_OP_OR_INVERTED,
    VK_LOGIC_OP_NAND,
    VK_LOGIC_OP_SET,
  }

  declare const VK_LOGIC_OP_CLEAR: VkLogicOp
  declare const VK_LOGIC_OP_AND: VkLogicOp
  declare const VK_LOGIC_OP_AND_REVERSE: VkLogicOp
  declare const VK_LOGIC_OP_COPY: VkLogicOp
  declare const VK_LOGIC_OP_AND_INVERTED: VkLogicOp
  declare const VK_LOGIC_OP_NO_OP: VkLogicOp
  declare const VK_LOGIC_OP_XOR: VkLogicOp
  declare const VK_LOGIC_OP_OR: VkLogicOp
  declare const VK_LOGIC_OP_NOR: VkLogicOp
  declare const VK_LOGIC_OP_EQUIVALENT: VkLogicOp
  declare const VK_LOGIC_OP_INVERT: VkLogicOp
  declare const VK_LOGIC_OP_OR_REVERSE: VkLogicOp
  declare const VK_LOGIC_OP_COPY_INVERTED: VkLogicOp
  declare const VK_LOGIC_OP_OR_INVERTED: VkLogicOp
  declare const VK_LOGIC_OP_NAND: VkLogicOp
  declare const VK_LOGIC_OP_SET: VkLogicOp

  /**
   * Allocation type
   * @member VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE specifies that the allocation is intended for execution by the host.
   */
  export enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
  }

  declare const VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE: VkInternalAllocationType

  /**
   * Allocation scope
   * @member VK_SYSTEM_ALLOCATION_SCOPE_COMMAND specifies that the allocation is scoped to the duration of the Vulkan command.
   * @member VK_SYSTEM_ALLOCATION_SCOPE_OBJECT specifies that the allocation is scoped to the lifetime of the Vulkan object that is being created or used.
   * @member VK_SYSTEM_ALLOCATION_SCOPE_CACHE specifies that the allocation is scoped to the lifetime of a 'VkPipelineCache' or 'VkValidationCacheEXT'
   * @member VK_SYSTEM_ALLOCATION_SCOPE_DEVICE
   * @member VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE
   */
  export enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
  }

  declare const VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: VkSystemAllocationScope
  declare const VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: VkSystemAllocationScope
  declare const VK_SYSTEM_ALLOCATION_SCOPE_CACHE: VkSystemAllocationScope
  declare const VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: VkSystemAllocationScope
  declare const VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: VkSystemAllocationScope

  /**
   * Supported physical device types
   * @member VK_PHYSICAL_DEVICE_TYPE_OTHER - the device does not match any other available types.
   * @member VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU - the device is typically one embedded in or tightly coupled with the host.
   * @member VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU - the device is typically a separate processor connected to the host via an interlink.
   * @member VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU - the device is typically a virtual node in a virtualization environment.
   * @member VK_PHYSICAL_DEVICE_TYPE_CPU - the device is typically running on the same processors as the host.
   */
  export enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    VK_PHYSICAL_DEVICE_TYPE_CPU,
  }

  declare const VK_PHYSICAL_DEVICE_TYPE_OTHER: VkPhysicalDeviceType
  declare const VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: VkPhysicalDeviceType
  declare const VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: VkPhysicalDeviceType
  declare const VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: VkPhysicalDeviceType
  declare const VK_PHYSICAL_DEVICE_TYPE_CPU: VkPhysicalDeviceType

  /**
   * Specify rate at which vertex attributes are pulled from buffers
   * @member VK_VERTEX_INPUT_RATE_VERTEX specifies that vertex attribute addressing is a function of the vertex index.
   * @member VK_VERTEX_INPUT_RATE_INSTANCE specifies that vertex attribute addressing is a function of the instance index.
   */
  export enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_INSTANCE,
  }

  declare const VK_VERTEX_INPUT_RATE_VERTEX: VkVertexInputRate
  declare const VK_VERTEX_INPUT_RATE_INSTANCE: VkVertexInputRate

  /**
   * Available image formats
   * @member VK_FORMAT_UNDEFINED
   * @member VK_FORMAT_R4G4_UNORM_PACK8
   * @member VK_FORMAT_R4G4B4A4_UNORM_PACK16
   * @member VK_FORMAT_B4G4R4A4_UNORM_PACK16
   * @member VK_FORMAT_R5G6B5_UNORM_PACK16
   * @member VK_FORMAT_B5G6R5_UNORM_PACK16
   * @member VK_FORMAT_R5G5B5A1_UNORM_PACK16
   * @member VK_FORMAT_B5G5R5A1_UNORM_PACK16
   * @member VK_FORMAT_A1R5G5B5_UNORM_PACK16
   * @member VK_FORMAT_R8_UNORM
   * @member VK_FORMAT_R8_SNORM
   * @member VK_FORMAT_R8_USCALED
   * @member VK_FORMAT_R8_SSCALED
   * @member VK_FORMAT_R8_UINT
   * @member VK_FORMAT_R8_SINT
   * @member VK_FORMAT_R8_SRGB
   * @member VK_FORMAT_R8G8_UNORM
   * @member VK_FORMAT_R8G8_SNORM
   * @member VK_FORMAT_R8G8_USCALED
   * @member VK_FORMAT_R8G8_SSCALED
   * @member VK_FORMAT_R8G8_UINT
   * @member VK_FORMAT_R8G8_SINT
   * @member VK_FORMAT_R8G8_SRGB
   * @member VK_FORMAT_R8G8B8_UNORM
   * @member VK_FORMAT_R8G8B8_SNORM
   * @member VK_FORMAT_R8G8B8_USCALED
   * @member VK_FORMAT_R8G8B8_SSCALED
   * @member VK_FORMAT_R8G8B8_UINT
   * @member VK_FORMAT_R8G8B8_SINT
   * @member VK_FORMAT_R8G8B8_SRGB
   * @member VK_FORMAT_B8G8R8_UNORM
   * @member VK_FORMAT_B8G8R8_SNORM
   * @member VK_FORMAT_B8G8R8_USCALED
   * @member VK_FORMAT_B8G8R8_SSCALED
   * @member VK_FORMAT_B8G8R8_UINT
   * @member VK_FORMAT_B8G8R8_SINT
   * @member VK_FORMAT_B8G8R8_SRGB
   * @member VK_FORMAT_R8G8B8A8_UNORM
   * @member VK_FORMAT_R8G8B8A8_SNORM
   * @member VK_FORMAT_R8G8B8A8_USCALED
   * @member VK_FORMAT_R8G8B8A8_SSCALED
   * @member VK_FORMAT_R8G8B8A8_UINT
   * @member VK_FORMAT_R8G8B8A8_SINT
   * @member VK_FORMAT_R8G8B8A8_SRGB
   * @member VK_FORMAT_B8G8R8A8_UNORM
   * @member VK_FORMAT_B8G8R8A8_SNORM
   * @member VK_FORMAT_B8G8R8A8_USCALED
   * @member VK_FORMAT_B8G8R8A8_SSCALED
   * @member VK_FORMAT_B8G8R8A8_UINT
   * @member VK_FORMAT_B8G8R8A8_SINT
   * @member VK_FORMAT_B8G8R8A8_SRGB
   * @member VK_FORMAT_A8B8G8R8_UNORM_PACK32
   * @member VK_FORMAT_A8B8G8R8_SNORM_PACK32
   * @member VK_FORMAT_A8B8G8R8_USCALED_PACK32
   * @member VK_FORMAT_A8B8G8R8_SSCALED_PACK32
   * @member VK_FORMAT_A8B8G8R8_UINT_PACK32
   * @member VK_FORMAT_A8B8G8R8_SINT_PACK32
   * @member VK_FORMAT_A8B8G8R8_SRGB_PACK32
   * @member VK_FORMAT_A2R10G10B10_UNORM_PACK32
   * @member VK_FORMAT_A2R10G10B10_SNORM_PACK32
   * @member VK_FORMAT_A2R10G10B10_USCALED_PACK32
   * @member VK_FORMAT_A2R10G10B10_SSCALED_PACK32
   * @member VK_FORMAT_A2R10G10B10_UINT_PACK32
   * @member VK_FORMAT_A2R10G10B10_SINT_PACK32
   * @member VK_FORMAT_A2B10G10R10_UNORM_PACK32
   * @member VK_FORMAT_A2B10G10R10_SNORM_PACK32
   * @member VK_FORMAT_A2B10G10R10_USCALED_PACK32
   * @member VK_FORMAT_A2B10G10R10_SSCALED_PACK32
   * @member VK_FORMAT_A2B10G10R10_UINT_PACK32
   * @member VK_FORMAT_A2B10G10R10_SINT_PACK32
   * @member VK_FORMAT_R16_UNORM
   * @member VK_FORMAT_R16_SNORM
   * @member VK_FORMAT_R16_USCALED
   * @member VK_FORMAT_R16_SSCALED
   * @member VK_FORMAT_R16_UINT
   * @member VK_FORMAT_R16_SINT
   * @member VK_FORMAT_R16_SFLOAT
   * @member VK_FORMAT_R16G16_UNORM
   * @member VK_FORMAT_R16G16_SNORM
   * @member VK_FORMAT_R16G16_USCALED
   * @member VK_FORMAT_R16G16_SSCALED
   * @member VK_FORMAT_R16G16_UINT
   * @member VK_FORMAT_R16G16_SINT
   * @member VK_FORMAT_R16G16_SFLOAT
   * @member VK_FORMAT_R16G16B16_UNORM
   * @member VK_FORMAT_R16G16B16_SNORM
   * @member VK_FORMAT_R16G16B16_USCALED
   * @member VK_FORMAT_R16G16B16_SSCALED
   * @member VK_FORMAT_R16G16B16_UINT
   * @member VK_FORMAT_R16G16B16_SINT
   * @member VK_FORMAT_R16G16B16_SFLOAT
   * @member VK_FORMAT_R16G16B16A16_UNORM
   * @member VK_FORMAT_R16G16B16A16_SNORM
   * @member VK_FORMAT_R16G16B16A16_USCALED
   * @member VK_FORMAT_R16G16B16A16_SSCALED
   * @member VK_FORMAT_R16G16B16A16_UINT
   * @member VK_FORMAT_R16G16B16A16_SINT
   * @member VK_FORMAT_R16G16B16A16_SFLOAT
   * @member VK_FORMAT_R32_UINT
   * @member VK_FORMAT_R32_SINT
   * @member VK_FORMAT_R32_SFLOAT
   * @member VK_FORMAT_R32G32_UINT
   * @member VK_FORMAT_R32G32_SINT
   * @member VK_FORMAT_R32G32_SFLOAT
   * @member VK_FORMAT_R32G32B32_UINT
   * @member VK_FORMAT_R32G32B32_SINT
   * @member VK_FORMAT_R32G32B32_SFLOAT
   * @member VK_FORMAT_R32G32B32A32_UINT
   * @member VK_FORMAT_R32G32B32A32_SINT
   * @member VK_FORMAT_R32G32B32A32_SFLOAT
   * @member VK_FORMAT_R64_UINT
   * @member VK_FORMAT_R64_SINT
   * @member VK_FORMAT_R64_SFLOAT
   * @member VK_FORMAT_R64G64_UINT
   * @member VK_FORMAT_R64G64_SINT
   * @member VK_FORMAT_R64G64_SFLOAT
   * @member VK_FORMAT_R64G64B64_UINT
   * @member VK_FORMAT_R64G64B64_SINT
   * @member VK_FORMAT_R64G64B64_SFLOAT
   * @member VK_FORMAT_R64G64B64A64_UINT
   * @member VK_FORMAT_R64G64B64A64_SINT
   * @member VK_FORMAT_R64G64B64A64_SFLOAT
   * @member VK_FORMAT_B10G11R11_UFLOAT_PACK32
   * @member VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
   * @member VK_FORMAT_D16_UNORM
   * @member VK_FORMAT_X8_D24_UNORM_PACK32
   * @member VK_FORMAT_D32_SFLOAT
   * @member VK_FORMAT_S8_UINT
   * @member VK_FORMAT_D16_UNORM_S8_UINT
   * @member VK_FORMAT_D24_UNORM_S8_UINT
   * @member VK_FORMAT_D32_SFLOAT_S8_UINT
   * @member VK_FORMAT_BC1_RGB_UNORM_BLOCK
   * @member VK_FORMAT_BC1_RGB_SRGB_BLOCK
   * @member VK_FORMAT_BC1_RGBA_UNORM_BLOCK
   * @member VK_FORMAT_BC1_RGBA_SRGB_BLOCK
   * @member VK_FORMAT_BC2_UNORM_BLOCK
   * @member VK_FORMAT_BC2_SRGB_BLOCK
   * @member VK_FORMAT_BC3_UNORM_BLOCK
   * @member VK_FORMAT_BC3_SRGB_BLOCK
   * @member VK_FORMAT_BC4_UNORM_BLOCK
   * @member VK_FORMAT_BC4_SNORM_BLOCK
   * @member VK_FORMAT_BC5_UNORM_BLOCK
   * @member VK_FORMAT_BC5_SNORM_BLOCK
   * @member VK_FORMAT_BC6H_UFLOAT_BLOCK
   * @member VK_FORMAT_BC6H_SFLOAT_BLOCK
   * @member VK_FORMAT_BC7_UNORM_BLOCK
   * @member VK_FORMAT_BC7_SRGB_BLOCK
   * @member VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
   * @member VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
   * @member VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
   * @member VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
   * @member VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
   * @member VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
   * @member VK_FORMAT_EAC_R11_UNORM_BLOCK
   * @member VK_FORMAT_EAC_R11_SNORM_BLOCK
   * @member VK_FORMAT_EAC_R11G11_UNORM_BLOCK
   * @member VK_FORMAT_EAC_R11G11_SNORM_BLOCK
   * @member VK_FORMAT_ASTC_4x4_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_4x4_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_5x4_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_5x4_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_5x5_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_5x5_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_6x5_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_6x5_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_6x6_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_6x6_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_8x5_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_8x5_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_8x6_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_8x6_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_8x8_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_8x8_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_10x5_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_10x5_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_10x6_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_10x6_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_10x8_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_10x8_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_10x10_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_10x10_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_12x10_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_12x10_SRGB_BLOCK
   * @member VK_FORMAT_ASTC_12x12_UNORM_BLOCK
   * @member VK_FORMAT_ASTC_12x12_SRGB_BLOCK
   * @member VK_FORMAT_G8B8G8R8_422_UNORM
   * @member VK_FORMAT_B8G8R8G8_422_UNORM
   * @member VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
   * @member VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
   * @member VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM
   * @member VK_FORMAT_G8_B8R8_2PLANE_422_UNORM
   * @member VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM
   * @member VK_FORMAT_R10X6_UNORM_PACK16
   * @member VK_FORMAT_R10X6G10X6_UNORM_2PACK16
   * @member VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
   * @member VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
   * @member VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
   * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
   * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
   * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
   * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
   * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
   * @member VK_FORMAT_R12X4_UNORM_PACK16
   * @member VK_FORMAT_R12X4G12X4_UNORM_2PACK16
   * @member VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
   * @member VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
   * @member VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
   * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
   * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
   * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
   * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
   * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
   * @member VK_FORMAT_G16B16G16R16_422_UNORM
   * @member VK_FORMAT_B16G16R16G16_422_UNORM
   * @member VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM
   * @member VK_FORMAT_G16_B16R16_2PLANE_420_UNORM
   * @member VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM
   * @member VK_FORMAT_G16_B16R16_2PLANE_422_UNORM
   * @member VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
   * @member VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG
   * @member VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG
   * @member VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG
   * @member VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG
   * @member VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG
   * @member VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG
   * @member VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG
   * @member VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG
   * @member VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
   * @member VK_FORMAT_G8B8G8R8_422_UNORM_KHR
   * @member VK_FORMAT_B8G8R8G8_422_UNORM_KHR
   * @member VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR
   * @member VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR
   * @member VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR
   * @member VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR
   * @member VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR
   * @member VK_FORMAT_R10X6_UNORM_PACK16_KHR
   * @member VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR
   * @member VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR
   * @member VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR
   * @member VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR
   * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR
   * @member VK_FORMAT_R12X4_UNORM_PACK16_KHR
   * @member VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR
   * @member VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR
   * @member VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR
   * @member VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR
   * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR
   * @member VK_FORMAT_G16B16G16R16_422_UNORM_KHR
   * @member VK_FORMAT_B16G16R16G16_422_UNORM_KHR
   * @member VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR
   * @member VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR
   * @member VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR
   * @member VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR
   * @member VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR
   */
  export enum VkFormat {
    VK_FORMAT_UNDEFINED,
    VK_FORMAT_R4G4_UNORM_PACK8,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16,
    VK_FORMAT_R5G6B5_UNORM_PACK16,
    VK_FORMAT_B5G6R5_UNORM_PACK16,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    VK_FORMAT_R8_UNORM,
    VK_FORMAT_R8_SNORM,
    VK_FORMAT_R8_USCALED,
    VK_FORMAT_R8_SSCALED,
    VK_FORMAT_R8_UINT,
    VK_FORMAT_R8_SINT,
    VK_FORMAT_R8_SRGB,
    VK_FORMAT_R8G8_UNORM,
    VK_FORMAT_R8G8_SNORM,
    VK_FORMAT_R8G8_USCALED,
    VK_FORMAT_R8G8_SSCALED,
    VK_FORMAT_R8G8_UINT,
    VK_FORMAT_R8G8_SINT,
    VK_FORMAT_R8G8_SRGB,
    VK_FORMAT_R8G8B8_UNORM,
    VK_FORMAT_R8G8B8_SNORM,
    VK_FORMAT_R8G8B8_USCALED,
    VK_FORMAT_R8G8B8_SSCALED,
    VK_FORMAT_R8G8B8_UINT,
    VK_FORMAT_R8G8B8_SINT,
    VK_FORMAT_R8G8B8_SRGB,
    VK_FORMAT_B8G8R8_UNORM,
    VK_FORMAT_B8G8R8_SNORM,
    VK_FORMAT_B8G8R8_USCALED,
    VK_FORMAT_B8G8R8_SSCALED,
    VK_FORMAT_B8G8R8_UINT,
    VK_FORMAT_B8G8R8_SINT,
    VK_FORMAT_B8G8R8_SRGB,
    VK_FORMAT_R8G8B8A8_UNORM,
    VK_FORMAT_R8G8B8A8_SNORM,
    VK_FORMAT_R8G8B8A8_USCALED,
    VK_FORMAT_R8G8B8A8_SSCALED,
    VK_FORMAT_R8G8B8A8_UINT,
    VK_FORMAT_R8G8B8A8_SINT,
    VK_FORMAT_R8G8B8A8_SRGB,
    VK_FORMAT_B8G8R8A8_UNORM,
    VK_FORMAT_B8G8R8A8_SNORM,
    VK_FORMAT_B8G8R8A8_USCALED,
    VK_FORMAT_B8G8R8A8_SSCALED,
    VK_FORMAT_B8G8R8A8_UINT,
    VK_FORMAT_B8G8R8A8_SINT,
    VK_FORMAT_B8G8R8A8_SRGB,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
    VK_FORMAT_A8B8G8R8_UINT_PACK32,
    VK_FORMAT_A8B8G8R8_SINT_PACK32,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
    VK_FORMAT_A2R10G10B10_UINT_PACK32,
    VK_FORMAT_A2R10G10B10_SINT_PACK32,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
    VK_FORMAT_A2B10G10R10_UINT_PACK32,
    VK_FORMAT_A2B10G10R10_SINT_PACK32,
    VK_FORMAT_R16_UNORM,
    VK_FORMAT_R16_SNORM,
    VK_FORMAT_R16_USCALED,
    VK_FORMAT_R16_SSCALED,
    VK_FORMAT_R16_UINT,
    VK_FORMAT_R16_SINT,
    VK_FORMAT_R16_SFLOAT,
    VK_FORMAT_R16G16_UNORM,
    VK_FORMAT_R16G16_SNORM,
    VK_FORMAT_R16G16_USCALED,
    VK_FORMAT_R16G16_SSCALED,
    VK_FORMAT_R16G16_UINT,
    VK_FORMAT_R16G16_SINT,
    VK_FORMAT_R16G16_SFLOAT,
    VK_FORMAT_R16G16B16_UNORM,
    VK_FORMAT_R16G16B16_SNORM,
    VK_FORMAT_R16G16B16_USCALED,
    VK_FORMAT_R16G16B16_SSCALED,
    VK_FORMAT_R16G16B16_UINT,
    VK_FORMAT_R16G16B16_SINT,
    VK_FORMAT_R16G16B16_SFLOAT,
    VK_FORMAT_R16G16B16A16_UNORM,
    VK_FORMAT_R16G16B16A16_SNORM,
    VK_FORMAT_R16G16B16A16_USCALED,
    VK_FORMAT_R16G16B16A16_SSCALED,
    VK_FORMAT_R16G16B16A16_UINT,
    VK_FORMAT_R16G16B16A16_SINT,
    VK_FORMAT_R16G16B16A16_SFLOAT,
    VK_FORMAT_R32_UINT,
    VK_FORMAT_R32_SINT,
    VK_FORMAT_R32_SFLOAT,
    VK_FORMAT_R32G32_UINT,
    VK_FORMAT_R32G32_SINT,
    VK_FORMAT_R32G32_SFLOAT,
    VK_FORMAT_R32G32B32_UINT,
    VK_FORMAT_R32G32B32_SINT,
    VK_FORMAT_R32G32B32_SFLOAT,
    VK_FORMAT_R32G32B32A32_UINT,
    VK_FORMAT_R32G32B32A32_SINT,
    VK_FORMAT_R32G32B32A32_SFLOAT,
    VK_FORMAT_R64_UINT,
    VK_FORMAT_R64_SINT,
    VK_FORMAT_R64_SFLOAT,
    VK_FORMAT_R64G64_UINT,
    VK_FORMAT_R64G64_SINT,
    VK_FORMAT_R64G64_SFLOAT,
    VK_FORMAT_R64G64B64_UINT,
    VK_FORMAT_R64G64B64_SINT,
    VK_FORMAT_R64G64B64_SFLOAT,
    VK_FORMAT_R64G64B64A64_UINT,
    VK_FORMAT_R64G64B64A64_SINT,
    VK_FORMAT_R64G64B64A64_SFLOAT,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    VK_FORMAT_D16_UNORM,
    VK_FORMAT_X8_D24_UNORM_PACK32,
    VK_FORMAT_D32_SFLOAT,
    VK_FORMAT_S8_UINT,
    VK_FORMAT_D16_UNORM_S8_UINT,
    VK_FORMAT_D24_UNORM_S8_UINT,
    VK_FORMAT_D32_SFLOAT_S8_UINT,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
    VK_FORMAT_BC2_UNORM_BLOCK,
    VK_FORMAT_BC2_SRGB_BLOCK,
    VK_FORMAT_BC3_UNORM_BLOCK,
    VK_FORMAT_BC3_SRGB_BLOCK,
    VK_FORMAT_BC4_UNORM_BLOCK,
    VK_FORMAT_BC4_SNORM_BLOCK,
    VK_FORMAT_BC5_UNORM_BLOCK,
    VK_FORMAT_BC5_SNORM_BLOCK,
    VK_FORMAT_BC6H_UFLOAT_BLOCK,
    VK_FORMAT_BC6H_SFLOAT_BLOCK,
    VK_FORMAT_BC7_UNORM_BLOCK,
    VK_FORMAT_BC7_SRGB_BLOCK,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    VK_FORMAT_EAC_R11_UNORM_BLOCK,
    VK_FORMAT_EAC_R11_SNORM_BLOCK,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_G8B8G8R8_422_UNORM,
    VK_FORMAT_B8G8R8G8_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    VK_FORMAT_R10X6_UNORM_PACK16,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_R12X4_UNORM_PACK16,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_G16B16G16R16_422_UNORM,
    VK_FORMAT_B16G16R16G16_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT,
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR,
  }

  declare const VK_FORMAT_UNDEFINED: VkFormat
  declare const VK_FORMAT_R4G4_UNORM_PACK8: VkFormat
  declare const VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_R8_UNORM: VkFormat
  declare const VK_FORMAT_R8_SNORM: VkFormat
  declare const VK_FORMAT_R8_USCALED: VkFormat
  declare const VK_FORMAT_R8_SSCALED: VkFormat
  declare const VK_FORMAT_R8_UINT: VkFormat
  declare const VK_FORMAT_R8_SINT: VkFormat
  declare const VK_FORMAT_R8_SRGB: VkFormat
  declare const VK_FORMAT_R8G8_UNORM: VkFormat
  declare const VK_FORMAT_R8G8_SNORM: VkFormat
  declare const VK_FORMAT_R8G8_USCALED: VkFormat
  declare const VK_FORMAT_R8G8_SSCALED: VkFormat
  declare const VK_FORMAT_R8G8_UINT: VkFormat
  declare const VK_FORMAT_R8G8_SINT: VkFormat
  declare const VK_FORMAT_R8G8_SRGB: VkFormat
  declare const VK_FORMAT_R8G8B8_UNORM: VkFormat
  declare const VK_FORMAT_R8G8B8_SNORM: VkFormat
  declare const VK_FORMAT_R8G8B8_USCALED: VkFormat
  declare const VK_FORMAT_R8G8B8_SSCALED: VkFormat
  declare const VK_FORMAT_R8G8B8_UINT: VkFormat
  declare const VK_FORMAT_R8G8B8_SINT: VkFormat
  declare const VK_FORMAT_R8G8B8_SRGB: VkFormat
  declare const VK_FORMAT_B8G8R8_UNORM: VkFormat
  declare const VK_FORMAT_B8G8R8_SNORM: VkFormat
  declare const VK_FORMAT_B8G8R8_USCALED: VkFormat
  declare const VK_FORMAT_B8G8R8_SSCALED: VkFormat
  declare const VK_FORMAT_B8G8R8_UINT: VkFormat
  declare const VK_FORMAT_B8G8R8_SINT: VkFormat
  declare const VK_FORMAT_B8G8R8_SRGB: VkFormat
  declare const VK_FORMAT_R8G8B8A8_UNORM: VkFormat
  declare const VK_FORMAT_R8G8B8A8_SNORM: VkFormat
  declare const VK_FORMAT_R8G8B8A8_USCALED: VkFormat
  declare const VK_FORMAT_R8G8B8A8_SSCALED: VkFormat
  declare const VK_FORMAT_R8G8B8A8_UINT: VkFormat
  declare const VK_FORMAT_R8G8B8A8_SINT: VkFormat
  declare const VK_FORMAT_R8G8B8A8_SRGB: VkFormat
  declare const VK_FORMAT_B8G8R8A8_UNORM: VkFormat
  declare const VK_FORMAT_B8G8R8A8_SNORM: VkFormat
  declare const VK_FORMAT_B8G8R8A8_USCALED: VkFormat
  declare const VK_FORMAT_B8G8R8A8_SSCALED: VkFormat
  declare const VK_FORMAT_B8G8R8A8_UINT: VkFormat
  declare const VK_FORMAT_B8G8R8A8_SINT: VkFormat
  declare const VK_FORMAT_B8G8R8A8_SRGB: VkFormat
  declare const VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat
  declare const VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat
  declare const VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat
  declare const VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat
  declare const VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat
  declare const VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat
  declare const VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat
  declare const VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat
  declare const VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat
  declare const VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat
  declare const VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat
  declare const VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat
  declare const VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat
  declare const VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat
  declare const VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat
  declare const VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat
  declare const VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat
  declare const VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat
  declare const VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat
  declare const VK_FORMAT_R16_UNORM: VkFormat
  declare const VK_FORMAT_R16_SNORM: VkFormat
  declare const VK_FORMAT_R16_USCALED: VkFormat
  declare const VK_FORMAT_R16_SSCALED: VkFormat
  declare const VK_FORMAT_R16_UINT: VkFormat
  declare const VK_FORMAT_R16_SINT: VkFormat
  declare const VK_FORMAT_R16_SFLOAT: VkFormat
  declare const VK_FORMAT_R16G16_UNORM: VkFormat
  declare const VK_FORMAT_R16G16_SNORM: VkFormat
  declare const VK_FORMAT_R16G16_USCALED: VkFormat
  declare const VK_FORMAT_R16G16_SSCALED: VkFormat
  declare const VK_FORMAT_R16G16_UINT: VkFormat
  declare const VK_FORMAT_R16G16_SINT: VkFormat
  declare const VK_FORMAT_R16G16_SFLOAT: VkFormat
  declare const VK_FORMAT_R16G16B16_UNORM: VkFormat
  declare const VK_FORMAT_R16G16B16_SNORM: VkFormat
  declare const VK_FORMAT_R16G16B16_USCALED: VkFormat
  declare const VK_FORMAT_R16G16B16_SSCALED: VkFormat
  declare const VK_FORMAT_R16G16B16_UINT: VkFormat
  declare const VK_FORMAT_R16G16B16_SINT: VkFormat
  declare const VK_FORMAT_R16G16B16_SFLOAT: VkFormat
  declare const VK_FORMAT_R16G16B16A16_UNORM: VkFormat
  declare const VK_FORMAT_R16G16B16A16_SNORM: VkFormat
  declare const VK_FORMAT_R16G16B16A16_USCALED: VkFormat
  declare const VK_FORMAT_R16G16B16A16_SSCALED: VkFormat
  declare const VK_FORMAT_R16G16B16A16_UINT: VkFormat
  declare const VK_FORMAT_R16G16B16A16_SINT: VkFormat
  declare const VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat
  declare const VK_FORMAT_R32_UINT: VkFormat
  declare const VK_FORMAT_R32_SINT: VkFormat
  declare const VK_FORMAT_R32_SFLOAT: VkFormat
  declare const VK_FORMAT_R32G32_UINT: VkFormat
  declare const VK_FORMAT_R32G32_SINT: VkFormat
  declare const VK_FORMAT_R32G32_SFLOAT: VkFormat
  declare const VK_FORMAT_R32G32B32_UINT: VkFormat
  declare const VK_FORMAT_R32G32B32_SINT: VkFormat
  declare const VK_FORMAT_R32G32B32_SFLOAT: VkFormat
  declare const VK_FORMAT_R32G32B32A32_UINT: VkFormat
  declare const VK_FORMAT_R32G32B32A32_SINT: VkFormat
  declare const VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat
  declare const VK_FORMAT_R64_UINT: VkFormat
  declare const VK_FORMAT_R64_SINT: VkFormat
  declare const VK_FORMAT_R64_SFLOAT: VkFormat
  declare const VK_FORMAT_R64G64_UINT: VkFormat
  declare const VK_FORMAT_R64G64_SINT: VkFormat
  declare const VK_FORMAT_R64G64_SFLOAT: VkFormat
  declare const VK_FORMAT_R64G64B64_UINT: VkFormat
  declare const VK_FORMAT_R64G64B64_SINT: VkFormat
  declare const VK_FORMAT_R64G64B64_SFLOAT: VkFormat
  declare const VK_FORMAT_R64G64B64A64_UINT: VkFormat
  declare const VK_FORMAT_R64G64B64A64_SINT: VkFormat
  declare const VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat
  declare const VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat
  declare const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat
  declare const VK_FORMAT_D16_UNORM: VkFormat
  declare const VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat
  declare const VK_FORMAT_D32_SFLOAT: VkFormat
  declare const VK_FORMAT_S8_UINT: VkFormat
  declare const VK_FORMAT_D16_UNORM_S8_UINT: VkFormat
  declare const VK_FORMAT_D24_UNORM_S8_UINT: VkFormat
  declare const VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat
  declare const VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_BC2_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC2_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_BC3_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC3_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_BC4_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC4_SNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC5_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC5_SNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat
  declare const VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat
  declare const VK_FORMAT_BC7_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_BC7_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat
  declare const VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat
  declare const VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat
  declare const VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat
  declare const VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat
  declare const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat
  declare const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat
  declare const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat
  declare const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat
  declare const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat
  declare const VK_FORMAT_R10X6_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat
  declare const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat
  declare const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat
  declare const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat
  declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_R12X4_UNORM_PACK16: VkFormat
  declare const VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat
  declare const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat
  declare const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat
  declare const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat
  declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat
  declare const VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat
  declare const VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat
  declare const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat
  declare const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat
  declare const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat
  declare const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat
  declare const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat
  declare const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat
  declare const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat
  declare const VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat
  declare const VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat
  declare const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat
  declare const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat
  declare const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat
  declare const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat
  declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat
  declare const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat
  declare const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat
  declare const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat
  declare const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat
  declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat
  declare const VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat
  declare const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat

  /**
   * Vulkan structure types ({#0#})
   * @member VK_STRUCTURE_TYPE_APPLICATION_INFO
   * @member VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_SUBMIT_INFO
   * @member VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
   * @member VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
   * @member VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
   * @member VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
   * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
   * @member VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
   * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
   * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
   * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
   * @member VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
   * @member VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
   * @member VK_STRUCTURE_TYPE_MEMORY_BARRIER
   * @member VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
   * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
   * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
   * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
   * @member VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
   * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
   * @member VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
   * @member VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
   * @member VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
   * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
   * @member VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
   * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
   * @member VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
   * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES
   * @member VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES
   * @member VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2
   * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
   * @member VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
   * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
   * @member VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
   * @member VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
   * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
   * @member VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
   * @member VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
   * @member VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES
   * @member VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
   * @member VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
   * @member VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID
   * @member VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID
   * @member VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD
   * @member VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX
   * @member VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD
   * @member VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV
   * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV
   * @member VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV
   * @member VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
   * @member VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
   * @member VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR
   * @member VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX
   * @member VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX
   * @member VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX
   * @member VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX
   * @member VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX
   * @member VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX
   * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
   * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT
   * @member VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
   * @member VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
   * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_HDR_METADATA_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR
   * @member VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
   * @member VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
   * @member VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
   * @member VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR
   * @member VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
   * @member VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
   * @member VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
   * @member VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK
   * @member VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK
   * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
   * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID
   * @member VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID
   * @member VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID
   * @member VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
   * @member VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
   * @member VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT
   * @member VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_GEOMETRY_NV
   * @member VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV
   * @member VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV
   * @member VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV
   * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV
   * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT
   * @member VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT
   * @member VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD
   * @member VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD
   * @member VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP
   * @member VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
   * @member VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL
   * @member VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL
   * @member VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL
   * @member VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL
   * @member VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL
   * @member VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL
   * @member VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD
   * @member VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD
   * @member VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA
   * @member VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT
   * @member VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV
   * @member VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV
   * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT
   * @member VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT
   * @member VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR
   * @member VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR
   * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR
   * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR
   * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR
   * @member VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR
   * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR
   * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR
   * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR
   * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR
   */
  export enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID,
    VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR,
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_GEOMETRY_NV,
    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV,
    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV,
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR,
    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR,
    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL,
    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR,
  }

  declare const VK_STRUCTURE_TYPE_APPLICATION_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_SUBMIT_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: VkStructureType
  declare const VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: VkStructureType
  declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_BARRIER: VkStructureType
  declare const VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: VkStructureType
  declare const VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_HDR_METADATA_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: VkStructureType
  declare const VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_GEOMETRY_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: VkStructureType
  declare const VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: VkStructureType
  declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType

  /**
   * Specify how commands in the first subpass of a render pass are provided
   * @member VK_SUBPASS_CONTENTS_INLINE specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers 'must' not be executed within the subpass.
   * @member VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS specifies that the contents are recorded in secondary command buffers that will be called from the primary command buffer, and 'vkCmdExecuteCommands' is the only valid command on the command buffer until 'vkCmdNextSubpass' or 'vkCmdEndRenderPass'.
   */
  export enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
  }

  declare const VK_SUBPASS_CONTENTS_INLINE: VkSubpassContents
  declare const VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: VkSubpassContents

  /**
   * Vulkan command return codes
   * @member VK_SUCCESS Command successfully completed
   * @member VK_NOT_READY A fence or query has not yet completed
   * @member VK_TIMEOUT A wait operation has not completed in the specified time
   * @member VK_EVENT_SET An event is signaled
   * @member VK_EVENT_RESET An event is unsignaled
   * @member VK_INCOMPLETE A return array was too small for the result
   * @member VK_ERROR_OUT_OF_HOST_MEMORY
   * @member VK_ERROR_OUT_OF_DEVICE_MEMORY
   * @member VK_ERROR_INITIALIZATION_FAILED
   * @member VK_ERROR_DEVICE_LOST
   * @member VK_ERROR_MEMORY_MAP_FAILED
   * @member VK_ERROR_LAYER_NOT_PRESENT
   * @member VK_ERROR_EXTENSION_NOT_PRESENT
   * @member VK_ERROR_FEATURE_NOT_PRESENT
   * @member VK_ERROR_INCOMPATIBLE_DRIVER
   * @member VK_ERROR_TOO_MANY_OBJECTS
   * @member VK_ERROR_FORMAT_NOT_SUPPORTED
   * @member VK_ERROR_FRAGMENTED_POOL
   * @member VK_ERROR_OUT_OF_POOL_MEMORY
   * @member VK_ERROR_INVALID_EXTERNAL_HANDLE
   * @member VK_ERROR_SURFACE_LOST_KHR
   * @member VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
   * @member VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface properties exactly, but 'can' still be used to present to the surface successfully.
   * @member VK_ERROR_OUT_OF_DATE_KHR
   * @member VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
   * @member VK_ERROR_VALIDATION_FAILED_EXT
   * @member VK_ERROR_INVALID_SHADER_NV
   * @member VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT
   * @member VK_ERROR_FRAGMENTATION_EXT
   * @member VK_ERROR_NOT_PERMITTED_EXT
   * @member VK_ERROR_INVALID_DEVICE_ADDRESS_EXT
   * @member VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
   * @member VK_ERROR_OUT_OF_POOL_MEMORY_KHR
   * @member VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR
   */
  export enum VkResult {
    VK_SUCCESS,
    VK_NOT_READY,
    VK_TIMEOUT,
    VK_EVENT_SET,
    VK_EVENT_RESET,
    VK_INCOMPLETE,
    VK_ERROR_OUT_OF_HOST_MEMORY,
    VK_ERROR_OUT_OF_DEVICE_MEMORY,
    VK_ERROR_INITIALIZATION_FAILED,
    VK_ERROR_DEVICE_LOST,
    VK_ERROR_MEMORY_MAP_FAILED,
    VK_ERROR_LAYER_NOT_PRESENT,
    VK_ERROR_EXTENSION_NOT_PRESENT,
    VK_ERROR_FEATURE_NOT_PRESENT,
    VK_ERROR_INCOMPATIBLE_DRIVER,
    VK_ERROR_TOO_MANY_OBJECTS,
    VK_ERROR_FORMAT_NOT_SUPPORTED,
    VK_ERROR_FRAGMENTED_POOL,
    VK_ERROR_OUT_OF_POOL_MEMORY,
    VK_ERROR_INVALID_EXTERNAL_HANDLE,
    VK_ERROR_SURFACE_LOST_KHR,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
    VK_SUBOPTIMAL_KHR,
    VK_ERROR_OUT_OF_DATE_KHR,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
    VK_ERROR_VALIDATION_FAILED_EXT,
    VK_ERROR_INVALID_SHADER_NV,
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
    VK_ERROR_FRAGMENTATION_EXT,
    VK_ERROR_NOT_PERMITTED_EXT,
    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT,
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,
  }

  declare const VK_SUCCESS: VkResult
  declare const VK_NOT_READY: VkResult
  declare const VK_TIMEOUT: VkResult
  declare const VK_EVENT_SET: VkResult
  declare const VK_EVENT_RESET: VkResult
  declare const VK_INCOMPLETE: VkResult
  declare const VK_ERROR_OUT_OF_HOST_MEMORY: VkResult
  declare const VK_ERROR_OUT_OF_DEVICE_MEMORY: VkResult
  declare const VK_ERROR_INITIALIZATION_FAILED: VkResult
  declare const VK_ERROR_DEVICE_LOST: VkResult
  declare const VK_ERROR_MEMORY_MAP_FAILED: VkResult
  declare const VK_ERROR_LAYER_NOT_PRESENT: VkResult
  declare const VK_ERROR_EXTENSION_NOT_PRESENT: VkResult
  declare const VK_ERROR_FEATURE_NOT_PRESENT: VkResult
  declare const VK_ERROR_INCOMPATIBLE_DRIVER: VkResult
  declare const VK_ERROR_TOO_MANY_OBJECTS: VkResult
  declare const VK_ERROR_FORMAT_NOT_SUPPORTED: VkResult
  declare const VK_ERROR_FRAGMENTED_POOL: VkResult
  declare const VK_ERROR_OUT_OF_POOL_MEMORY: VkResult
  declare const VK_ERROR_INVALID_EXTERNAL_HANDLE: VkResult
  declare const VK_ERROR_SURFACE_LOST_KHR: VkResult
  declare const VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: VkResult
  declare const VK_SUBOPTIMAL_KHR: VkResult
  declare const VK_ERROR_OUT_OF_DATE_KHR: VkResult
  declare const VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: VkResult
  declare const VK_ERROR_VALIDATION_FAILED_EXT: VkResult
  declare const VK_ERROR_INVALID_SHADER_NV: VkResult
  declare const VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: VkResult
  declare const VK_ERROR_FRAGMENTATION_EXT: VkResult
  declare const VK_ERROR_NOT_PERMITTED_EXT: VkResult
  declare const VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult
  declare const VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: VkResult
  declare const VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult
  declare const VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult

  /**
   * Indicate which dynamic state is taken from dynamic state commands
   * @member VK_DYNAMIC_STATE_VIEWPORT
   * @member VK_DYNAMIC_STATE_SCISSOR
   * @member VK_DYNAMIC_STATE_LINE_WIDTH
   * @member VK_DYNAMIC_STATE_DEPTH_BIAS specifies that the 'depthBiasConstantFactor', 'depthBiasClamp' and 'depthBiasSlopeFactor' states in 'VkPipelineRasterizationStateCreateInfo' will be ignored and 'must' be set dynamically with 'vkCmdSetDepthBias' before any draws are performed with 'depthBiasEnable' in 'VkPipelineRasterizationStateCreateInfo' set to 'VK_TRUE'.
   * @member VK_DYNAMIC_STATE_BLEND_CONSTANTS specifies that the 'blendConstants' state in 'VkPipelineColorBlendStateCreateInfo' will be ignored and 'must' be set dynamically with 'vkCmdSetBlendConstants' before any draws are performed with a pipeline state with 'VkPipelineColorBlendAttachmentState' member 'blendEnable' set to 'VK_TRUE' and any of the blend functions using a constant blend color.
   * @member VK_DYNAMIC_STATE_DEPTH_BOUNDS specifies that the 'minDepthBounds' and 'maxDepthBounds' states of 'VkPipelineDepthStencilStateCreateInfo' will be ignored and 'must' be set dynamically with 'vkCmdSetDepthBounds' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'depthBoundsTestEnable' set to 'VK_TRUE'.
   * @member VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK specifies that the 'compareMask' state in 'VkPipelineDepthStencilStateCreateInfo' for both 'front' and 'back' will be ignored and 'must' be set dynamically with 'vkCmdSetStencilCompareMask' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'stencilTestEnable' set to 'VK_TRUE'
   * @member VK_DYNAMIC_STATE_STENCIL_WRITE_MASK specifies that the 'writeMask' state in 'VkPipelineDepthStencilStateCreateInfo' for both 'front' and 'back' will be ignored and 'must' be set dynamically with 'vkCmdSetStencilWriteMask' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'stencilTestEnable' set to 'VK_TRUE'
   * @member VK_DYNAMIC_STATE_STENCIL_REFERENCE specifies that the 'reference' state in 'VkPipelineDepthStencilStateCreateInfo' for both 'front' and 'back' will be ignored and 'must' be set dynamically with 'vkCmdSetStencilReference' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'stencilTestEnable' set to 'VK_TRUE'
   * @member VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV specifies that the 'pViewportScalings' state in 'VkPipelineViewportWScalingStateCreateInfoNV' will be ignored and 'must' be set dynamically with 'vkCmdSetViewportWScalingNV' before any draws are performed with a pipeline state with 'VkPipelineViewportWScalingStateCreateInfoNV' member 'viewportScalingEnable' set to 'VK_TRUE'
   * @member VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT
   * @member VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT
   * @member VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV
   * @member VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV
   * @member VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV
   * @member VK_DYNAMIC_STATE_LINE_STIPPLE_EXT
   */
  export enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_SCISSOR,
    VK_DYNAMIC_STATE_LINE_WIDTH,
    VK_DYNAMIC_STATE_DEPTH_BIAS,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV,
    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT,
  }

  declare const VK_DYNAMIC_STATE_VIEWPORT: VkDynamicState
  declare const VK_DYNAMIC_STATE_SCISSOR: VkDynamicState
  declare const VK_DYNAMIC_STATE_LINE_WIDTH: VkDynamicState
  declare const VK_DYNAMIC_STATE_DEPTH_BIAS: VkDynamicState
  declare const VK_DYNAMIC_STATE_BLEND_CONSTANTS: VkDynamicState
  declare const VK_DYNAMIC_STATE_DEPTH_BOUNDS: VkDynamicState
  declare const VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK: VkDynamicState
  declare const VK_DYNAMIC_STATE_STENCIL_WRITE_MASK: VkDynamicState
  declare const VK_DYNAMIC_STATE_STENCIL_REFERENCE: VkDynamicState
  declare const VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV: VkDynamicState
  declare const VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT: VkDynamicState
  declare const VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT: VkDynamicState
  declare const VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV: VkDynamicState
  declare const VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV: VkDynamicState
  declare const VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV: VkDynamicState
  declare const VK_DYNAMIC_STATE_LINE_STIPPLE_EXT: VkDynamicState

  /**
   * Indicates the valid usage of the descriptor update template
   * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET specifies that the descriptor update template will be used for descriptor set updates only.
   * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR
   */
  export enum VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
  }

  declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: VkDescriptorUpdateTemplateType
  declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR: VkDescriptorUpdateTemplateType

  /**
   * Specify an enumeration to track object handle types
   * @member VK_OBJECT_TYPE_UNKNOWN
   * @member VK_OBJECT_TYPE_INSTANCE
   * @member VK_OBJECT_TYPE_PHYSICAL_DEVICE
   * @member VK_OBJECT_TYPE_DEVICE
   * @member VK_OBJECT_TYPE_QUEUE
   * @member VK_OBJECT_TYPE_SEMAPHORE
   * @member VK_OBJECT_TYPE_COMMAND_BUFFER
   * @member VK_OBJECT_TYPE_FENCE
   * @member VK_OBJECT_TYPE_DEVICE_MEMORY
   * @member VK_OBJECT_TYPE_BUFFER
   * @member VK_OBJECT_TYPE_IMAGE
   * @member VK_OBJECT_TYPE_EVENT
   * @member VK_OBJECT_TYPE_QUERY_POOL
   * @member VK_OBJECT_TYPE_BUFFER_VIEW
   * @member VK_OBJECT_TYPE_IMAGE_VIEW
   * @member VK_OBJECT_TYPE_SHADER_MODULE
   * @member VK_OBJECT_TYPE_PIPELINE_CACHE
   * @member VK_OBJECT_TYPE_PIPELINE_LAYOUT
   * @member VK_OBJECT_TYPE_RENDER_PASS
   * @member VK_OBJECT_TYPE_PIPELINE
   * @member VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT
   * @member VK_OBJECT_TYPE_SAMPLER
   * @member VK_OBJECT_TYPE_DESCRIPTOR_POOL
   * @member VK_OBJECT_TYPE_DESCRIPTOR_SET
   * @member VK_OBJECT_TYPE_FRAMEBUFFER
   * @member VK_OBJECT_TYPE_COMMAND_POOL
   * @member VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
   * @member VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
   * @member VK_OBJECT_TYPE_SURFACE_KHR
   * @member VK_OBJECT_TYPE_SWAPCHAIN_KHR
   * @member VK_OBJECT_TYPE_DISPLAY_KHR
   * @member VK_OBJECT_TYPE_DISPLAY_MODE_KHR
   * @member VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
   * @member VK_OBJECT_TYPE_OBJECT_TABLE_NVX
   * @member VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX
   * @member VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
   * @member VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
   * @member VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
   * @member VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL
   * @member VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR
   * @member VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR
   */
  export enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN,
    VK_OBJECT_TYPE_INSTANCE,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE,
    VK_OBJECT_TYPE_DEVICE,
    VK_OBJECT_TYPE_QUEUE,
    VK_OBJECT_TYPE_SEMAPHORE,
    VK_OBJECT_TYPE_COMMAND_BUFFER,
    VK_OBJECT_TYPE_FENCE,
    VK_OBJECT_TYPE_DEVICE_MEMORY,
    VK_OBJECT_TYPE_BUFFER,
    VK_OBJECT_TYPE_IMAGE,
    VK_OBJECT_TYPE_EVENT,
    VK_OBJECT_TYPE_QUERY_POOL,
    VK_OBJECT_TYPE_BUFFER_VIEW,
    VK_OBJECT_TYPE_IMAGE_VIEW,
    VK_OBJECT_TYPE_SHADER_MODULE,
    VK_OBJECT_TYPE_PIPELINE_CACHE,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT,
    VK_OBJECT_TYPE_RENDER_PASS,
    VK_OBJECT_TYPE_PIPELINE,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
    VK_OBJECT_TYPE_SAMPLER,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL,
    VK_OBJECT_TYPE_DESCRIPTOR_SET,
    VK_OBJECT_TYPE_FRAMEBUFFER,
    VK_OBJECT_TYPE_COMMAND_POOL,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    VK_OBJECT_TYPE_SURFACE_KHR,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR,
    VK_OBJECT_TYPE_DISPLAY_KHR,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX,
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV,
    VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR,
  }

  declare const VK_OBJECT_TYPE_UNKNOWN: VkObjectType
  declare const VK_OBJECT_TYPE_INSTANCE: VkObjectType
  declare const VK_OBJECT_TYPE_PHYSICAL_DEVICE: VkObjectType
  declare const VK_OBJECT_TYPE_DEVICE: VkObjectType
  declare const VK_OBJECT_TYPE_QUEUE: VkObjectType
  declare const VK_OBJECT_TYPE_SEMAPHORE: VkObjectType
  declare const VK_OBJECT_TYPE_COMMAND_BUFFER: VkObjectType
  declare const VK_OBJECT_TYPE_FENCE: VkObjectType
  declare const VK_OBJECT_TYPE_DEVICE_MEMORY: VkObjectType
  declare const VK_OBJECT_TYPE_BUFFER: VkObjectType
  declare const VK_OBJECT_TYPE_IMAGE: VkObjectType
  declare const VK_OBJECT_TYPE_EVENT: VkObjectType
  declare const VK_OBJECT_TYPE_QUERY_POOL: VkObjectType
  declare const VK_OBJECT_TYPE_BUFFER_VIEW: VkObjectType
  declare const VK_OBJECT_TYPE_IMAGE_VIEW: VkObjectType
  declare const VK_OBJECT_TYPE_SHADER_MODULE: VkObjectType
  declare const VK_OBJECT_TYPE_PIPELINE_CACHE: VkObjectType
  declare const VK_OBJECT_TYPE_PIPELINE_LAYOUT: VkObjectType
  declare const VK_OBJECT_TYPE_RENDER_PASS: VkObjectType
  declare const VK_OBJECT_TYPE_PIPELINE: VkObjectType
  declare const VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT: VkObjectType
  declare const VK_OBJECT_TYPE_SAMPLER: VkObjectType
  declare const VK_OBJECT_TYPE_DESCRIPTOR_POOL: VkObjectType
  declare const VK_OBJECT_TYPE_DESCRIPTOR_SET: VkObjectType
  declare const VK_OBJECT_TYPE_FRAMEBUFFER: VkObjectType
  declare const VK_OBJECT_TYPE_COMMAND_POOL: VkObjectType
  declare const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION: VkObjectType
  declare const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: VkObjectType
  declare const VK_OBJECT_TYPE_SURFACE_KHR: VkObjectType
  declare const VK_OBJECT_TYPE_SWAPCHAIN_KHR: VkObjectType
  declare const VK_OBJECT_TYPE_DISPLAY_KHR: VkObjectType
  declare const VK_OBJECT_TYPE_DISPLAY_MODE_KHR: VkObjectType
  declare const VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT: VkObjectType
  declare const VK_OBJECT_TYPE_OBJECT_TABLE_NVX: VkObjectType
  declare const VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX: VkObjectType
  declare const VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT: VkObjectType
  declare const VK_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkObjectType
  declare const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV: VkObjectType
  declare const VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL: VkObjectType
  declare const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR: VkObjectType
  declare const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR: VkObjectType

  /**
   * Sepcifies the type of a semaphore object
   * @member VK_SEMAPHORE_TYPE_BINARY_KHR specifies a _binary semaphore_ type that has a boolean payload indicating whether the semaphore is currently signaled or unsignaled. When created, the semaphore is in the unsignaled state.
   * @member VK_SEMAPHORE_TYPE_TIMELINE_KHR specifies a _timeline semaphore_ type that has a monotonically increasing 64-bit unsigned integer payload indicating whether the semaphore is signaled with respect to a particular reference value. When created, the semaphore payload has the value given by the 'initialValue' field of 'VkSemaphoreTypeCreateInfoKHR'.
   */
  export enum VkSemaphoreTypeKHR {
    VK_SEMAPHORE_TYPE_BINARY_KHR,
    VK_SEMAPHORE_TYPE_TIMELINE_KHR,
  }

  declare const VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreTypeKHR
  declare const VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreTypeKHR

  /**
   * presentation mode supported for a surface
   * @member VK_PRESENT_MODE_IMMEDIATE_KHR specifies that the presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode 'may' result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.
   * @member VK_PRESENT_MODE_MAILBOX_KHR specifies that the presentation engine waits for the next vertical blanking period to update the current image. Tearing 'cannot' be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.
   * @member VK_PRESENT_MODE_FIFO_KHR specifies that the presentation engine waits for the next vertical blanking period to update the current image. Tearing 'cannot' be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of 'presentMode' that is 'required' to be supported.
   * @member VK_PRESENT_MODE_FIFO_RELAXED_KHR specifies that the presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode 'may' result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.
   * @member VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR specifies that the presentation engine and application have concurrent access to a single image, which is referred to as a _shared presentable image_. The presentation engine is only required to update the current image after a new presentation request is received. Therefore the application 'must' make a presentation request whenever an update is required. However, the presentation engine 'may' update the current image at any point, meaning this mode 'may' result in visible tearing.
   * @member VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR specifies that the presentation engine and application have concurrent access to a single image, which is referred to as a _shared presentable image_. The presentation engine periodically updates the current image on its regular refresh cycle. The application is only required to make one initial presentation request, after which the presentation engine 'must' update the current image without any need for further presentation requests. The application 'can' indicate the image contents have been updated by making a presentation request, but this does not guarantee the timing of when it will be updated. This mode 'may' result in visible tearing if rendering to the image is not timed correctly.
   */
  export enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_MAILBOX_KHR,
    VK_PRESENT_MODE_FIFO_KHR,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
  }

  declare const VK_PRESENT_MODE_IMMEDIATE_KHR: VkPresentModeKHR
  declare const VK_PRESENT_MODE_MAILBOX_KHR: VkPresentModeKHR
  declare const VK_PRESENT_MODE_FIFO_KHR: VkPresentModeKHR
  declare const VK_PRESENT_MODE_FIFO_RELAXED_KHR: VkPresentModeKHR
  declare const VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: VkPresentModeKHR
  declare const VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: VkPresentModeKHR

  /**
   * supported color space of the presentation engine
   * @member VK_COLOR_SPACE_SRGB_NONLINEAR_KHR specifies support for the sRGB color space.
   * @member VK_COLORSPACE_SRGB_NONLINEAR_KHR
   * @member VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT specifies support for the Display-P3 color space to be displayed using an sRGB-like EOTF (defined below).
   * @member VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT specifies support for the extended sRGB color space to be displayed using a linear EOTF.
   * @member VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT specifies support for the Display-P3 color space to be displayed using a linear EOTF.
   * @member VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT specifies support for the DCI-P3 color space to be displayed using the DCI-P3 EOTF. Note that values in such an image are interpreted as XYZ encoded color data by the presentation engine.
   * @member VK_COLOR_SPACE_BT709_LINEAR_EXT specifies support for the BT709 color space to be displayed using a linear EOTF.
   * @member VK_COLOR_SPACE_BT709_NONLINEAR_EXT specifies support for the BT709 color space to be displayed using the SMPTE 170M EOTF.
   * @member VK_COLOR_SPACE_BT2020_LINEAR_EXT specifies support for the BT2020 color space to be displayed using a linear EOTF.
   * @member VK_COLOR_SPACE_HDR10_ST2084_EXT specifies support for the HDR10 (BT2020 color) space to be displayed using the SMPTE ST2084 Perceptual Quantizer (PQ) EOTF.
   * @member VK_COLOR_SPACE_DOLBYVISION_EXT specifies support for the Dolby Vision (BT2020 color space), proprietary encoding, to be displayed using the SMPTE ST2084 EOTF.
   * @member VK_COLOR_SPACE_HDR10_HLG_EXT specifies support for the HDR10 (BT2020 color space) to be displayed using the Hybrid Log Gamma (HLG) EOTF.
   * @member VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT specifies support for the AdobeRGB color space to be displayed using a linear EOTF.
   * @member VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT specifies support for the AdobeRGB color space to be displayed using the Gamma 2.2 EOTF.
   * @member VK_COLOR_SPACE_PASS_THROUGH_EXT specifies that color components are used "`as is`". This is intended to allow applications to supply data for color spaces not described here.ifdef::VK_AMD_display_native_hdr[]
   * @member VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT specifies support for the extended sRGB color space to be displayed using an sRGB EOTF.
   * @member VK_COLOR_SPACE_DCI_P3_LINEAR_EXT
   * @member VK_COLOR_SPACE_DISPLAY_NATIVE_AMD specifies support for the display's native color space. This matches the color space expectations of AMD's FreeSync2 standard, for displays supporting it.
   */
  export enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLORSPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
    VK_COLOR_SPACE_BT709_LINEAR_EXT,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT,
    VK_COLOR_SPACE_HDR10_ST2084_EXT,
    VK_COLOR_SPACE_DOLBYVISION_EXT,
    VK_COLOR_SPACE_HDR10_HLG_EXT,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
    VK_COLOR_SPACE_PASS_THROUGH_EXT,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT,
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
  }

  declare const VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR
  declare const VK_COLORSPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_BT709_LINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_BT709_NONLINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_BT2020_LINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_HDR10_ST2084_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_DOLBYVISION_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_HDR10_HLG_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_PASS_THROUGH_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_DCI_P3_LINEAR_EXT: VkColorSpaceKHR
  declare const VK_COLOR_SPACE_DISPLAY_NATIVE_AMD: VkColorSpaceKHR

  /**
   * Supported time domains
   * @member VK_TIME_DOMAIN_DEVICE_EXT specifies the device time domain. Timestamp values in this time domain use the same units and are comparable with device timestamp values captured using 'vkCmdWriteTimestamp' and are defined to be incrementing according to the <<limits-timestampPeriod,timestampPeriod>> of the device.
   * @member VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT
   * @member VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT
   * @member VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT
   */
  export enum VkTimeDomainEXT {
    VK_TIME_DOMAIN_DEVICE_EXT,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT,
    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT,
  }

  declare const VK_TIME_DOMAIN_DEVICE_EXT: VkTimeDomainEXT
  declare const VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT: VkTimeDomainEXT
  declare const VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: VkTimeDomainEXT
  declare const VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: VkTimeDomainEXT

  /**
   * Specify the type of an object handle
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT
   * @member VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT
   */
  export enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT,
  }

  declare const VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT: VkDebugReportObjectTypeEXT
  declare const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT: VkDebugReportObjectTypeEXT

  /**
   * Specify rasterization order for a graphics pipeline
   * @member VK_RASTERIZATION_ORDER_STRICT_AMD specifies that operations for each primitive in a subpass 'must' occur in <<drawing-primitive-order, primitive order>>.
   * @member VK_RASTERIZATION_ORDER_RELAXED_AMD specifies that operations for each primitive in a subpass 'may' not occur in <<drawing-primitive-order, primitive order>>.
   */
  export enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD,
    VK_RASTERIZATION_ORDER_RELAXED_AMD,
  }

  declare const VK_RASTERIZATION_ORDER_STRICT_AMD: VkRasterizationOrderAMD
  declare const VK_RASTERIZATION_ORDER_RELAXED_AMD: VkRasterizationOrderAMD

  /**
   * Specify validation checks to disable
   * @member VK_VALIDATION_CHECK_ALL_EXT specifies that all validation checks are disabled.
   * @member VK_VALIDATION_CHECK_SHADERS_EXT specifies that shader validation is disabled.
   */
  export enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT,
    VK_VALIDATION_CHECK_SHADERS_EXT,
  }

  declare const VK_VALIDATION_CHECK_ALL_EXT: VkValidationCheckEXT
  declare const VK_VALIDATION_CHECK_SHADERS_EXT: VkValidationCheckEXT

  /**
   * Specify validation features to enable
   * @member VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT specifies that GPU-assisted validation is enabled. Activating this feature instruments shader programs to generate additional diagnostic data. This feature is disabled by default.
   * @member VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT specifies that the validation layers reserve a descriptor set binding slot for their own use. The layer reports a value for 'VkPhysicalDeviceLimits'::'maxBoundDescriptorSets' that is one less than the value reported by the device. If the device supports the binding of only one descriptor set, the validation layer does not perform GPU-assisted validation. This feature is disabled by default. The GPU-assisted validation feature must be enabled in order to use this feature.
   * @member VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT specifies that Vulkan best-practices validation is enabled. Activating this feature enables the output of warnings related to common misuse of the API, but which are not explicitly prohibited by the specification. This feature is disabled by default.
   */
  export enum VkValidationFeatureEnableEXT {
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
    VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
  }

  declare const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT: VkValidationFeatureEnableEXT
  declare const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT: VkValidationFeatureEnableEXT
  declare const VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT: VkValidationFeatureEnableEXT

  /**
   * Specify validation features to disable
   * @member VK_VALIDATION_FEATURE_DISABLE_ALL_EXT specifies that all validation checks are disabled.
   * @member VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT specifies that shader validation is disabled. This feature is enabled by default.
   * @member VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT specifies that thread safety validation is disabled. This feature is enabled by default.
   * @member VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT specifies that stateless parameter validation is disabled. This feature is enabled by default.
   * @member VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT specifies that object lifetime validation is disabled. This feature is enabled by default.
   * @member VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT specifies that core validation checks are disabled. This feature is enabled by default. If this feature is disabled, the shader validation and GPU-assisted validation features are also disabled.
   * @member VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT specifies that protection against duplicate non-dispatchable object handles is disabled. This feature is enabled by default.
   */
  export enum VkValidationFeatureDisableEXT {
    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
  }

  declare const VK_VALIDATION_FEATURE_DISABLE_ALL_EXT: VkValidationFeatureDisableEXT
  declare const VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT: VkValidationFeatureDisableEXT
  declare const VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT: VkValidationFeatureDisableEXT
  declare const VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT: VkValidationFeatureDisableEXT
  declare const VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT: VkValidationFeatureDisableEXT
  declare const VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT: VkValidationFeatureDisableEXT
  declare const VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT: VkValidationFeatureDisableEXT

  /**
   * Enum specifying
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX
   * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX
   */
  export enum VkIndirectCommandsTokenTypeNVX {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX,
  }

  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX: VkIndirectCommandsTokenTypeNVX
  declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX: VkIndirectCommandsTokenTypeNVX

  /**
   * Enum specifying object table entry type
   * @member VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX specifies a 'VkDescriptorSet' resource entry that is registered via 'VkObjectTableDescriptorSetEntryNVX'.
   * @member VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX specifies a 'VkPipeline' resource entry that is registered via 'VkObjectTablePipelineEntryNVX'.
   * @member VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX specifies a 'VkBuffer' resource entry that is registered via 'VkObjectTableIndexBufferEntryNVX'.
   * @member VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX specifies a 'VkBuffer' resource entry that is registered via 'VkObjectTableVertexBufferEntryNVX'.
   * @member VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX specifies the resource entry is registered via 'VkObjectTablePushConstantEntryNVX'.
   */
  export enum VkObjectEntryTypeNVX {
    VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX,
    VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX,
    VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX,
    VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX,
    VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX,
  }

  declare const VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX: VkObjectEntryTypeNVX
  declare const VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX: VkObjectEntryTypeNVX
  declare const VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX: VkObjectEntryTypeNVX
  declare const VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX: VkObjectEntryTypeNVX
  declare const VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX: VkObjectEntryTypeNVX

  /**
   * Possible power states for a display
   * @member VK_DISPLAY_POWER_STATE_OFF_EXT specifies that the display is powered down.
   * @member VK_DISPLAY_POWER_STATE_SUSPEND_EXT specifies that the display is put into a low power mode, from which it 'may' be able to transition back to 'VK_DISPLAY_POWER_STATE_ON_EXT' more quickly than if it were in 'VK_DISPLAY_POWER_STATE_OFF_EXT'. This state 'may' be the same as 'VK_DISPLAY_POWER_STATE_OFF_EXT'.
   * @member VK_DISPLAY_POWER_STATE_ON_EXT specifies that the display is powered on.
   */
  export enum VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
    VK_DISPLAY_POWER_STATE_ON_EXT,
  }

  declare const VK_DISPLAY_POWER_STATE_OFF_EXT: VkDisplayPowerStateEXT
  declare const VK_DISPLAY_POWER_STATE_SUSPEND_EXT: VkDisplayPowerStateEXT
  declare const VK_DISPLAY_POWER_STATE_ON_EXT: VkDisplayPowerStateEXT

  /**
   * Events that can occur on a device object
   * @member VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT specifies that the fence is signaled when a display is plugged into or unplugged from the specified device. Applications 'can' use this notification to determine when they need to re-enumerate the available displays on a device.
   */
  export enum VkDeviceEventTypeEXT {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
  }

  declare const VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT: VkDeviceEventTypeEXT

  /**
   * Events that can occur on a display object
   * @member VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT specifies that the fence is signaled when the first pixel of the next display refresh cycle leaves the display engine for the display.
   */
  export enum VkDisplayEventTypeEXT {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
  }

  declare const VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT: VkDisplayEventTypeEXT

  /**
   * Specify how a viewport coordinate is swizzled
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV
   * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV
   */
  export enum VkViewportCoordinateSwizzleNV {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
  }

  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV: VkViewportCoordinateSwizzleNV
  declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV: VkViewportCoordinateSwizzleNV

  /**
   * Specify the discard rectangle mode
   * @member VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT specifies that a fragment within any discard rectangle satisfies the test.
   * @member VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT specifies that a fragment not within any of the discard rectangles satisfies the test.
   */
  export enum VkDiscardRectangleModeEXT {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
  }

  declare const VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT: VkDiscardRectangleModeEXT
  declare const VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT: VkDiscardRectangleModeEXT

  /**
   * Enum specifying the point clipping behavior
   * @member VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES specifies that the primitive is discarded if the vertex lies outside any clip plane, including the planes bounding the view volume.
   * @member VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY specifies that the primitive is discarded only if the vertex lies outside any user clip plane.
   * @member VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR
   * @member VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR
   */
  export enum VkPointClippingBehavior {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
  }

  declare const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES: VkPointClippingBehavior
  declare const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: VkPointClippingBehavior
  declare const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR: VkPointClippingBehavior
  declare const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR: VkPointClippingBehavior

  /**
   * Specify reduction mode for texture filtering
   * @member VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
   * @member VK_SAMPLER_REDUCTION_MODE_MIN_EXT
   * @member VK_SAMPLER_REDUCTION_MODE_MAX_EXT
   */
  export enum VkSamplerReductionModeEXT {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
  }

  declare const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: VkSamplerReductionModeEXT
  declare const VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionModeEXT
  declare const VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionModeEXT

  /**
   * Enum describing tessellation domain origin
   * @member VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT specifies that the origin of the domain space is in the upper left corner, as shown in figure <<img-tessellation-topology-ul>>.
   * @member VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT specifies that the origin of the domain space is in the lower left corner, as shown in figure <<img-tessellation-topology-ll>>.
   * @member VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR
   * @member VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR
   */
  export enum VkTessellationDomainOrigin {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
  }

  declare const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: VkTessellationDomainOrigin
  declare const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: VkTessellationDomainOrigin
  declare const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR: VkTessellationDomainOrigin
  declare const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR: VkTessellationDomainOrigin

  /**
   * Color model component of a color space
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY specifies that the input values to the conversion are unmodified.
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY specifies no model conversion but the inputs are range expanded as for Y'C~B~C~R~.
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 specifies the color model conversion from Y'C~B~C~R~ to R'G'B' defined in BT.709 and described in the "`BT.709 Y’C~B~C~R~ conversion`" section of the <<data-format,Khronos Data Format Specification>>.
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 specifies the color model conversion from Y'C~B~C~R~ to R'G'B' defined in BT.601 and described in the "`BT.601 Y’C~B~C~R~ conversion`" section of the <<data-format,Khronos Data Format Specification>>.
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 specifies the color model conversion from Y'C~B~C~R~ to R'G'B' defined in BT.2020 and described in the "`BT.2020 Y’C~B~C~R~ conversion`" section of the <<data-format,Khronos Data Format Specification>>.
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR
   * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR
   */
  export enum VkSamplerYcbcrModelConversion {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
  }

  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR: VkSamplerYcbcrModelConversion
  declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR: VkSamplerYcbcrModelConversion

  /**
   * Range of encoded values in a color space
   * @member VK_SAMPLER_YCBCR_RANGE_ITU_FULL specifies that the full range of the encoded values are valid and interpreted according to the ITU "`full range`" quantization rules.
   * @member VK_SAMPLER_YCBCR_RANGE_ITU_NARROW specifies that headroom and foot room are reserved in the numerical range of encoded values, and the remaining values are expanded according to the ITU "`narrow range`" quantization rules.
   * @member VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR
   * @member VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR
   */
  export enum VkSamplerYcbcrRange {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
  }

  declare const VK_SAMPLER_YCBCR_RANGE_ITU_FULL: VkSamplerYcbcrRange
  declare const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: VkSamplerYcbcrRange
  declare const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRange
  declare const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRange

  /**
   * Position of downsampled chroma samples
   * @member VK_CHROMA_LOCATION_COSITED_EVEN specifies that downsampled chroma samples are aligned with luma samples with even coordinates.
   * @member VK_CHROMA_LOCATION_MIDPOINT specifies that downsampled chroma samples are located half way between each even luma sample and the nearest higher odd luma sample.
   * @member VK_CHROMA_LOCATION_COSITED_EVEN_KHR
   * @member VK_CHROMA_LOCATION_MIDPOINT_KHR
   */
  export enum VkChromaLocation {
    VK_CHROMA_LOCATION_COSITED_EVEN,
    VK_CHROMA_LOCATION_MIDPOINT,
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
    VK_CHROMA_LOCATION_MIDPOINT_KHR,
  }

  declare const VK_CHROMA_LOCATION_COSITED_EVEN: VkChromaLocation
  declare const VK_CHROMA_LOCATION_MIDPOINT: VkChromaLocation
  declare const VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocation
  declare const VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocation

  /**
   * Enumerant specifying the blend overlap parameter
   * @member VK_BLEND_OVERLAP_UNCORRELATED_EXT specifies that there is no correlation between the source and destination coverage.
   * @member VK_BLEND_OVERLAP_DISJOINT_EXT specifies that the source and destination coverage are considered to have minimal overlap.
   * @member VK_BLEND_OVERLAP_CONJOINT_EXT specifies that the source and destination coverage are considered to have maximal overlap.
   */
  export enum VkBlendOverlapEXT {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    VK_BLEND_OVERLAP_DISJOINT_EXT,
    VK_BLEND_OVERLAP_CONJOINT_EXT,
  }

  declare const VK_BLEND_OVERLAP_UNCORRELATED_EXT: VkBlendOverlapEXT
  declare const VK_BLEND_OVERLAP_DISJOINT_EXT: VkBlendOverlapEXT
  declare const VK_BLEND_OVERLAP_CONJOINT_EXT: VkBlendOverlapEXT

  /**
   * Specify the coverage modulation mode
   * @member VK_COVERAGE_MODULATION_MODE_NONE_NV
   * @member VK_COVERAGE_MODULATION_MODE_RGB_NV
   * @member VK_COVERAGE_MODULATION_MODE_ALPHA_NV
   * @member VK_COVERAGE_MODULATION_MODE_RGBA_NV
   */
  export enum VkCoverageModulationModeNV {
    VK_COVERAGE_MODULATION_MODE_NONE_NV,
    VK_COVERAGE_MODULATION_MODE_RGB_NV,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV,
  }

  declare const VK_COVERAGE_MODULATION_MODE_NONE_NV: VkCoverageModulationModeNV
  declare const VK_COVERAGE_MODULATION_MODE_RGB_NV: VkCoverageModulationModeNV
  declare const VK_COVERAGE_MODULATION_MODE_ALPHA_NV: VkCoverageModulationModeNV
  declare const VK_COVERAGE_MODULATION_MODE_RGBA_NV: VkCoverageModulationModeNV

  /**
   * Specify the coverage reduction mode
   * @member VK_COVERAGE_REDUCTION_MODE_MERGE_NV
   * @member VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV
   */
  export enum VkCoverageReductionModeNV {
    VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
    VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
  }

  declare const VK_COVERAGE_REDUCTION_MODE_MERGE_NV: VkCoverageReductionModeNV
  declare const VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV: VkCoverageReductionModeNV

  /**
   * Encode validation cache version
   * @member VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
   */
  export enum VkValidationCacheHeaderVersionEXT {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
  }

  declare const VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT: VkValidationCacheHeaderVersionEXT

  /**
   * Enum specifying which type of shader info to query
   * @member VK_SHADER_INFO_TYPE_STATISTICS_AMD
   * @member VK_SHADER_INFO_TYPE_BINARY_AMD
   * @member VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD
   */
  export enum VkShaderInfoTypeAMD {
    VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    VK_SHADER_INFO_TYPE_BINARY_AMD,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
  }

  declare const VK_SHADER_INFO_TYPE_STATISTICS_AMD: VkShaderInfoTypeAMD
  declare const VK_SHADER_INFO_TYPE_BINARY_AMD: VkShaderInfoTypeAMD
  declare const VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD: VkShaderInfoTypeAMD

  /**
   * Values specifying a system-wide queue priority
   * @member VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT
   * @member VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT
   * @member VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT
   * @member VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
   */
  export enum VkQueueGlobalPriorityEXT {
    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT,
  }

  declare const VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT: VkQueueGlobalPriorityEXT
  declare const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: VkQueueGlobalPriorityEXT
  declare const VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT: VkQueueGlobalPriorityEXT
  declare const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: VkQueueGlobalPriorityEXT

  /**
   * Specify the conservative rasterization mode
   * @member VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT specifies that conservative rasterization is disabled and rasterization proceeds as normal.
   * @member VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT specifies that conservative rasterization is enabled in overestimation mode.
   * @member VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT specifies that conservative rasterization is enabled in underestimation mode.
   */
  export enum VkConservativeRasterizationModeEXT {
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
  }

  declare const VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT: VkConservativeRasterizationModeEXT
  declare const VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT: VkConservativeRasterizationModeEXT
  declare const VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT: VkConservativeRasterizationModeEXT

  /**
   * Khronos vendor IDs
   * @member VK_VENDOR_ID_VIV
   * @member VK_VENDOR_ID_VSI
   * @member VK_VENDOR_ID_KAZAN
   */
  export enum VkVendorId {
    VK_VENDOR_ID_VIV,
    VK_VENDOR_ID_VSI,
    VK_VENDOR_ID_KAZAN,
  }

  declare const VK_VENDOR_ID_VIV: VkVendorId
  declare const VK_VENDOR_ID_VSI: VkVendorId
  declare const VK_VENDOR_ID_KAZAN: VkVendorId

  /**
   * Khronos driver IDs
   * @member VK_DRIVER_ID_AMD_PROPRIETARY_KHR
   * @member VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR
   * @member VK_DRIVER_ID_MESA_RADV_KHR
   * @member VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR
   * @member VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR
   * @member VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR
   * @member VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR
   * @member VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR
   * @member VK_DRIVER_ID_ARM_PROPRIETARY_KHR
   * @member VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR
   * @member VK_DRIVER_ID_GGP_PROPRIETARY_KHR
   * @member VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR
   */
  export enum VkDriverIdKHR {
    VK_DRIVER_ID_AMD_PROPRIETARY_KHR,
    VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR,
    VK_DRIVER_ID_MESA_RADV_KHR,
    VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR,
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR,
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR,
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR,
    VK_DRIVER_ID_ARM_PROPRIETARY_KHR,
    VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR,
    VK_DRIVER_ID_GGP_PROPRIETARY_KHR,
    VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR,
  }

  declare const VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_MESA_RADV_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverIdKHR
  declare const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverIdKHR

  /**
   * Shading rate image palette entry types
   * @member VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV
   * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV
   */
  export enum VkShadingRatePaletteEntryNV {
    VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
  }

  declare const VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV: VkShadingRatePaletteEntryNV
  declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV: VkShadingRatePaletteEntryNV

  /**
   * Shading rate image sample ordering types
   * @member VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV specifies that coverage samples will be ordered in an implementation-dependent manner.
   * @member VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV specifies that coverage samples will be ordered according to the array of custom orderings provided in either the 'pCustomSampleOrders' member of 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV' or the 'pCustomSampleOrders' member of 'vkCmdSetCoarseSampleOrderNV'.
   * @member VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV specifies that coverage samples will be ordered sequentially, sorted first by pixel coordinate (in row-major order) and then by coverage sample number.
   * @member VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV specifies that coverage samples will be ordered sequentially, sorted first by coverage sample number and then by pixel coordinate (in row-major order).
   */
  export enum VkCoarseSampleOrderTypeNV {
    VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
    VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
    VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
    VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
  }

  declare const VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV: VkCoarseSampleOrderTypeNV
  declare const VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV: VkCoarseSampleOrderTypeNV
  declare const VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV: VkCoarseSampleOrderTypeNV
  declare const VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV: VkCoarseSampleOrderTypeNV

  /**
   * Acceleration structure copy mode
   * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV creates a direct copy of the acceleration structure specified in 'src' into the one specified by 'dst'. The 'dst' acceleration structure 'must' have been created with the same parameters as 'src'.
   * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV creates a more compact version of an acceleration structure 'src' into 'dst'. The acceleration structure 'dst' 'must' have been created with a 'compactedSize' corresponding to the one returned by 'vkCmdWriteAccelerationStructuresPropertiesNV' after the build of the acceleration structure specified by 'src'.
   */
  export enum VkCopyAccelerationStructureModeNV {
    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV,
  }

  declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: VkCopyAccelerationStructureModeNV
  declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: VkCopyAccelerationStructureModeNV

  /**
   * Type of acceleration structure
   * @member VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV is a top-level acceleration structure containing instance data referring to bottom-level level acceleration structures.
   * @member VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV is a bottom-level acceleration structure containing the AABBs or geometry to be intersected.
   */
  export enum VkAccelerationStructureTypeNV {
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV,
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV,
  }

  declare const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: VkAccelerationStructureTypeNV
  declare const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: VkAccelerationStructureTypeNV

  /**
   * Enum specifying which type of geometry is provided
   * @member VK_GEOMETRY_TYPE_TRIANGLES_NV
   * @member VK_GEOMETRY_TYPE_AABBS_NV
   */
  export enum VkGeometryTypeNV {
    VK_GEOMETRY_TYPE_TRIANGLES_NV,
    VK_GEOMETRY_TYPE_AABBS_NV,
  }

  declare const VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeNV
  declare const VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeNV

  /**
   * Acceleration structure memory requirement type
   * @member VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV requests the memory requirement for the 'VkAccelerationStructureNV' backing store.
   * @member VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV requests the memory requirement for scratch space during the initial build.
   * @member VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV requests the memory requirement for scratch space during an update.
   */
  export enum VkAccelerationStructureMemoryRequirementsTypeNV {
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
  }

  declare const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV: VkAccelerationStructureMemoryRequirementsTypeNV
  declare const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV: VkAccelerationStructureMemoryRequirementsTypeNV
  declare const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV: VkAccelerationStructureMemoryRequirementsTypeNV

  /**
   * Shader group types
   * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV indicates a shader group with a single 'VK_SHADER_STAGE_RAYGEN_BIT_NV', 'VK_SHADER_STAGE_MISS_BIT_NV', or 'VK_SHADER_STAGE_CALLABLE_BIT_NV' shader in it.
   * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV specifies a shader group that only hits triangles and 'must' not contain an intersection shader, only closest hit and any-hit.
   * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV specifies a shader group that only intersects with custom geometry and 'must' contain an intersection shader and 'may' contain closest hit and any-hit shaders.
   */
  export enum VkRayTracingShaderGroupTypeNV {
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV,
  }

  declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: VkRayTracingShaderGroupTypeNV
  declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: VkRayTracingShaderGroupTypeNV
  declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: VkRayTracingShaderGroupTypeNV

  /**
   * Specify memory overallocation behavior
   * @member VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD lets the implementation decide if overallocation should be allowed.
   * @member VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD specifies overallocation is allowed if platform permits.
   * @member VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD specifies the application is not allowed to allocate device memory beyond the heap sizes reported by 'VkPhysicalDeviceMemoryProperties'. Allocations that are not explicitly made by the application within the scope of the Vulkan instance are not accounted for.
   */
  export enum VkMemoryOverallocationBehaviorAMD {
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
  }

  declare const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD: VkMemoryOverallocationBehaviorAMD
  declare const VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD: VkMemoryOverallocationBehaviorAMD
  declare const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD: VkMemoryOverallocationBehaviorAMD

  /**
   * Specify SPIR-V scope
   * @member VK_SCOPE_DEVICE_NV corresponds to SPIR-V 'Device' scope.
   * @member VK_SCOPE_WORKGROUP_NV corresponds to SPIR-V 'Workgroup' scope.
   * @member VK_SCOPE_SUBGROUP_NV corresponds to SPIR-V 'Subgroup' scope.
   * @member VK_SCOPE_QUEUE_FAMILY_NV corresponds to SPIR-V 'QueueFamilyKHR' scope.
   */
  export enum VkScopeNV {
    VK_SCOPE_DEVICE_NV,
    VK_SCOPE_WORKGROUP_NV,
    VK_SCOPE_SUBGROUP_NV,
    VK_SCOPE_QUEUE_FAMILY_NV,
  }

  declare const VK_SCOPE_DEVICE_NV: VkScopeNV
  declare const VK_SCOPE_WORKGROUP_NV: VkScopeNV
  declare const VK_SCOPE_SUBGROUP_NV: VkScopeNV
  declare const VK_SCOPE_QUEUE_FAMILY_NV: VkScopeNV

  /**
   * Specify SPIR-V cooperative matrix component type
   * @member VK_COMPONENT_TYPE_FLOAT16_NV
   * @member VK_COMPONENT_TYPE_FLOAT32_NV
   * @member VK_COMPONENT_TYPE_FLOAT64_NV
   * @member VK_COMPONENT_TYPE_SINT8_NV
   * @member VK_COMPONENT_TYPE_SINT16_NV
   * @member VK_COMPONENT_TYPE_SINT32_NV
   * @member VK_COMPONENT_TYPE_SINT64_NV
   * @member VK_COMPONENT_TYPE_UINT8_NV
   * @member VK_COMPONENT_TYPE_UINT16_NV
   * @member VK_COMPONENT_TYPE_UINT32_NV
   * @member VK_COMPONENT_TYPE_UINT64_NV
   */
  export enum VkComponentTypeNV {
    VK_COMPONENT_TYPE_FLOAT16_NV,
    VK_COMPONENT_TYPE_FLOAT32_NV,
    VK_COMPONENT_TYPE_FLOAT64_NV,
    VK_COMPONENT_TYPE_SINT8_NV,
    VK_COMPONENT_TYPE_SINT16_NV,
    VK_COMPONENT_TYPE_SINT32_NV,
    VK_COMPONENT_TYPE_SINT64_NV,
    VK_COMPONENT_TYPE_UINT8_NV,
    VK_COMPONENT_TYPE_UINT16_NV,
    VK_COMPONENT_TYPE_UINT32_NV,
    VK_COMPONENT_TYPE_UINT64_NV,
  }

  declare const VK_COMPONENT_TYPE_FLOAT16_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_FLOAT32_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_FLOAT64_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_SINT8_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_SINT16_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_SINT32_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_SINT64_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_UINT8_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_UINT16_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_UINT32_NV: VkComponentTypeNV
  declare const VK_COMPONENT_TYPE_UINT64_NV: VkComponentTypeNV

  /**
   * Hint values an application can specify affecting full-screen transition behavior
   * @member VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT indicates the implementation 'should' determine the appropriate full-screen method by whatever means it deems appropriate.
   * @member VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT indicates the implementation 'may' use full-screen exclusive mechanisms when available. Such mechanisms 'may' result in better performance and/or the availability of different presentation capabilities, but 'may' require a more disruptive transition during swapchain initialization, first presentation and/or destruction.
   * @member VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT indicates the implementation 'should' avoid using full-screen mechanisms which rely on disruptive transitions.
   * @member VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT indicates the application will manage full-screen exclusive mode by using the 'vkAcquireFullScreenExclusiveModeEXT' and 'vkReleaseFullScreenExclusiveModeEXT' commands.
   */
  export enum VkFullScreenExclusiveEXT {
    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
  }

  declare const VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT: VkFullScreenExclusiveEXT
  declare const VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT: VkFullScreenExclusiveEXT
  declare const VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT: VkFullScreenExclusiveEXT
  declare const VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT: VkFullScreenExclusiveEXT

  /**
   * Type of performance configuration
   * @member VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL
   */
  export enum VkPerformanceConfigurationTypeINTEL {
    VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL,
  }

  declare const VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL: VkPerformanceConfigurationTypeINTEL

  /**
   * Enum specifying how performance queries should be captured
   * @member VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL
   */
  export enum VkQueryPoolSamplingModeINTEL {
    VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
  }

  declare const VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL: VkQueryPoolSamplingModeINTEL

  /**
   * Performance override type
   * @member VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL
   * @member VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL
   */
  export enum VkPerformanceOverrideTypeINTEL {
    VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
    VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
  }

  declare const VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL: VkPerformanceOverrideTypeINTEL
  declare const VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL: VkPerformanceOverrideTypeINTEL

  /**
   * Parameters that can be queried
   * @member VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL
   * @member VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL
   */
  export enum VkPerformanceParameterTypeINTEL {
    VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
    VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
  }

  declare const VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL: VkPerformanceParameterTypeINTEL
  declare const VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL: VkPerformanceParameterTypeINTEL

  /**
   * Type of the parameters that can be queried
   * @member VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL specifies that unsigned 32-bit integer data is returned in 'data.value32'.
   * @member VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL specifies that unsigned 64-bit integer data is returned in 'data.value64'.
   * @member VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL specifies that floating-point data is returned in 'data.valueFloat'.
   * @member VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL specifies that 'Bool32' data is returned in 'data.valueBool'.
   * @member VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL specifies that a reference to a string is returned in 'data.valueString'. The reference is valid for the lifetime of the 'device' parameter passed to 'vkGetPerformanceParameterINTEL'.
   */
  export enum VkPerformanceValueTypeINTEL {
    VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
    VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
    VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
    VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
    VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
  }

  declare const VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL: VkPerformanceValueTypeINTEL
  declare const VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL: VkPerformanceValueTypeINTEL
  declare const VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL: VkPerformanceValueTypeINTEL
  declare const VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL: VkPerformanceValueTypeINTEL
  declare const VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL: VkPerformanceValueTypeINTEL

  /**
   * Enum describing a pipeline executable statistic
   * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR specifies that the statistic is returned as a 32-bit boolean value which 'must' be either 'VK_TRUE' or 'VK_FALSE' and 'should' be read from the 'b32' field of 'VkPipelineExecutableStatisticValueKHR'.
   * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR specifies that the statistic is returned as a signed 64-bit integer and 'should' be read from the 'i64' field of 'VkPipelineExecutableStatisticValueKHR'.
   * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR specifies that the statistic is returned as an unsigned 64-bit integer and 'should' be read from the 'u64' field of 'VkPipelineExecutableStatisticValueKHR'.
   * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR specifies that the statistic is returned as a 64-bit floating-point value and 'should' be read from the 'f64' field of 'VkPipelineExecutableStatisticValueKHR'.
   */
  export enum VkPipelineExecutableStatisticFormatKHR {
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
  }

  declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR: VkPipelineExecutableStatisticFormatKHR
  declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR: VkPipelineExecutableStatisticFormatKHR
  declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR: VkPipelineExecutableStatisticFormatKHR
  declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR: VkPipelineExecutableStatisticFormatKHR

  /**
   * Enum specifying whether, and how, shader float controls can be set separately
   * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR
   * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR
   * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR
   */
  export enum VkShaderFloatControlsIndependenceKHR {
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR,
  }

  declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR: VkShaderFloatControlsIndependenceKHR
  declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR: VkShaderFloatControlsIndependenceKHR
  declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR: VkShaderFloatControlsIndependenceKHR

  /**
   * Line rasterization modes
   * @member VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT is equivalent to 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT' if 'VkPhysicalDeviceLimits'::'strictLines' is 'VK_TRUE', otherwise lines are drawn as non-'strictLines' parallelograms. Both of these modes are defined in <<primsrast-lines-basic,Basic Line Segment Rasterization>>.
   * @member VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT specifies lines drawn as if they were rectangles extruded from the line
   * @member VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT specifies lines drawn by determining which pixel diamonds the line intersects and exits, as defined in <<primsrast-lines-bresenham,Bresenham Line Segment Rasterization>>.
   * @member VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT specifies lines drawn if they were rectangles extruded from the line, with alpha falloff, as defined in <<primsrast-lines-smooth,Smooth Lines>>.
   */
  export enum VkLineRasterizationModeEXT {
    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT,
    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT,
  }

  declare const VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT: VkLineRasterizationModeEXT
  declare const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT: VkLineRasterizationModeEXT
  declare const VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT: VkLineRasterizationModeEXT
  declare const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT: VkLineRasterizationModeEXT

  /**
   * Bitmask controlling triangle culling
   * @member VK_CULL_MODE_NONE specifies that no triangles are discarded
   * @member VK_CULL_MODE_FRONT_BIT specifies that front-facing triangles are discarded
   * @member VK_CULL_MODE_BACK_BIT specifies that back-facing triangles are discarded
   * @member VK_CULL_MODE_FRONT_AND_BACK specifies that all triangles are discarded.
   */
  export enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE,
    VK_CULL_MODE_FRONT_BIT,
    VK_CULL_MODE_BACK_BIT,
    VK_CULL_MODE_FRONT_AND_BACK,
  }

  declare const VK_CULL_MODE_NONE: VkCullModeFlagBits
  declare const VK_CULL_MODE_FRONT_BIT: VkCullModeFlagBits
  declare const VK_CULL_MODE_BACK_BIT: VkCullModeFlagBits
  declare const VK_CULL_MODE_FRONT_AND_BACK: VkCullModeFlagBits

  /**
   * Bitmask specifying capabilities of queues in a queue family
   * @member VK_QUEUE_GRAPHICS_BIT specifies that queues in this queue family support graphics operations.
   * @member VK_QUEUE_COMPUTE_BIT specifies that queues in this queue family support compute operations.
   * @member VK_QUEUE_TRANSFER_BIT specifies that queues in this queue family support transfer operations.
   * @member VK_QUEUE_SPARSE_BINDING_BIT specifies that queues in this queue family support sparse memory management operations (see <<sparsememory,Sparse Resources>>). If any of the sparse resource features are enabled, then at least one queue family 'must' support this bit.
   * @member VK_QUEUE_PROTECTED_BIT is set, then the queues in this queue family support the 'VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT' bit. (see <<memory-protected-memory,Protected Memory>>). If the protected memory physical device feature is supported, then at least one queue family of at least one physical device exposed by the implementation 'must' support this bit.
   * @member VK_QUEUE_RESERVED_6_BIT_KHR
   * @member VK_QUEUE_RESERVED_5_BIT_KHR
   */
  export enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT,
    VK_QUEUE_COMPUTE_BIT,
    VK_QUEUE_TRANSFER_BIT,
    VK_QUEUE_SPARSE_BINDING_BIT,
    VK_QUEUE_PROTECTED_BIT,
    VK_QUEUE_RESERVED_6_BIT_KHR,
    VK_QUEUE_RESERVED_5_BIT_KHR,
  }

  declare const VK_QUEUE_GRAPHICS_BIT: VkQueueFlagBits
  declare const VK_QUEUE_COMPUTE_BIT: VkQueueFlagBits
  declare const VK_QUEUE_TRANSFER_BIT: VkQueueFlagBits
  declare const VK_QUEUE_SPARSE_BINDING_BIT: VkQueueFlagBits
  declare const VK_QUEUE_PROTECTED_BIT: VkQueueFlagBits
  declare const VK_QUEUE_RESERVED_6_BIT_KHR: VkQueueFlagBits
  declare const VK_QUEUE_RESERVED_5_BIT_KHR: VkQueueFlagBits

  /**
   *
   * @member VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR
   * @member VK_RENDER_PASS_RESERVED_BIT_1_QCOM
   */
  export enum VkRenderPassCreateFlagBits {
    VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR,
    VK_RENDER_PASS_RESERVED_BIT_1_QCOM,
  }

  declare const VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR: VkRenderPassCreateFlagBits
  declare const VK_RENDER_PASS_RESERVED_BIT_1_QCOM: VkRenderPassCreateFlagBits

  /**
   * Bitmask specifying behavior of the queue
   * @member VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT specifies that the device queue is a protected-capable queue. If the protected memory feature is not enabled, the 'VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT' bit of 'flags' 'must' not be set.
   */
  export enum VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
  }

  declare const VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: VkDeviceQueueCreateFlagBits

  /**
   * Bitmask specifying properties for a memory type
   * @member VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit specifies that memory allocated with this type is the most efficient for device access. This property will be set if and only if the memory type belongs to a heap with the 'VK_MEMORY_HEAP_DEVICE_LOCAL_BIT' set.
   * @member VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit specifies that memory allocated with this type 'can' be mapped for host access using 'vkMapMemory'.
   * @member VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit specifies that the host cache management commands 'vkFlushMappedMemoryRanges' and 'vkInvalidateMappedMemoryRanges' are not needed to flush host writes to the device or make device writes visible to the host, respectively.
   * @member VK_MEMORY_PROPERTY_HOST_CACHED_BIT bit specifies that memory allocated with this type is cached on the host. Host memory accesses to uncached memory are slower than to cached memory, however uncached memory is always host coherent.
   * @member VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit specifies that the memory type only allows device access to the memory. Memory types 'must' not have both 'VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT' and 'VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT' set. Additionally, the object's backing memory 'may' be provided by the implementation lazily as specified in <<memory-device-lazy_allocation, Lazily Allocated Memory>>.
   * @member VK_MEMORY_PROPERTY_PROTECTED_BIT bit specifies that the memory type only allows device access to the memory, and allows protected queue operations to access the memory. Memory types 'must' not have 'VK_MEMORY_PROPERTY_PROTECTED_BIT' set and any of 'VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT' set, or 'VK_MEMORY_PROPERTY_HOST_COHERENT_BIT' set, or 'VK_MEMORY_PROPERTY_HOST_CACHED_BIT' set.
   * @member VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD
   * @member VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD
   */
  export enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    VK_MEMORY_PROPERTY_PROTECTED_BIT,
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
  }

  declare const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_HOST_CACHED_BIT: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_PROTECTED_BIT: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: VkMemoryPropertyFlagBits
  declare const VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD: VkMemoryPropertyFlagBits

  /**
   * Bitmask specifying attribute flags for a heap
   * @member VK_MEMORY_HEAP_DEVICE_LOCAL_BIT specifies that the heap corresponds to device local memory. Device local memory 'may' have different performance characteristics than host local memory, and 'may' support different memory property flags.
   * @member VK_MEMORY_HEAP_MULTI_INSTANCE_BIT specifies that in a logical device representing more than one physical device, there is a per-physical device instance of the heap memory. By default, an allocation from such a heap will be replicated to each physical device's instance of the heap.
   * @member VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR
   */
  export enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,
  }

  declare const VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: VkMemoryHeapFlagBits
  declare const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: VkMemoryHeapFlagBits
  declare const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR: VkMemoryHeapFlagBits

  /**
   * Bitmask specifying memory access types that will participate in a memory dependency
   * @member VK_ACCESS_INDIRECT_COMMAND_READ_BIT specifies read access to indirect command data read as part of an indirect drawing or dispatch command.
   * @member VK_ACCESS_INDEX_READ_BIT specifies read access to an index buffer as part of an indexed drawing command, bound by 'vkCmdBindIndexBuffer'.
   * @member VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT specifies read access to a vertex buffer as part of a drawing command, bound by 'vkCmdBindVertexBuffers'.
   * @member VK_ACCESS_UNIFORM_READ_BIT specifies read access to a <<descriptorsets-uniformbuffer, uniform buffer>>.
   * @member VK_ACCESS_INPUT_ATTACHMENT_READ_BIT specifies read access to an <<renderpass, input attachment>> within a render pass during fragment shading.
   * @member VK_ACCESS_SHADER_READ_BIT specifies read access to a <<descriptorsets-storagebuffer, storage buffer>>, <<descriptorsets-physical-storage-buffer, physical storage buffer>>,
   * @member VK_ACCESS_SHADER_WRITE_BIT
   * @member VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
   * @member VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
   * @member VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
   * @member VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
   * @member VK_ACCESS_TRANSFER_READ_BIT
   * @member VK_ACCESS_TRANSFER_WRITE_BIT
   * @member VK_ACCESS_HOST_READ_BIT
   * @member VK_ACCESS_HOST_WRITE_BIT
   * @member VK_ACCESS_MEMORY_READ_BIT
   * @member VK_ACCESS_MEMORY_WRITE_BIT
   * @member VK_ACCESS_RESERVED_30_BIT_KHR
   * @member VK_ACCESS_RESERVED_31_BIT_KHR
   * @member VK_ACCESS_RESERVED_28_BIT_KHR
   * @member VK_ACCESS_RESERVED_29_BIT_KHR
   * @member VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
   * @member VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
   * @member VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
   * @member VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT
   * @member VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX
   * @member VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX
   * @member VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
   * @member VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV
   * @member VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV
   * @member VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV
   * @member VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
   */
  export enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    VK_ACCESS_INDEX_READ_BIT,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    VK_ACCESS_UNIFORM_READ_BIT,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    VK_ACCESS_SHADER_READ_BIT,
    VK_ACCESS_SHADER_WRITE_BIT,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    VK_ACCESS_TRANSFER_READ_BIT,
    VK_ACCESS_TRANSFER_WRITE_BIT,
    VK_ACCESS_HOST_READ_BIT,
    VK_ACCESS_HOST_WRITE_BIT,
    VK_ACCESS_MEMORY_READ_BIT,
    VK_ACCESS_MEMORY_WRITE_BIT,
    VK_ACCESS_RESERVED_30_BIT_KHR,
    VK_ACCESS_RESERVED_31_BIT_KHR,
    VK_ACCESS_RESERVED_28_BIT_KHR,
    VK_ACCESS_RESERVED_29_BIT_KHR,
    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV,
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV,
    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
  }

  declare const VK_ACCESS_INDIRECT_COMMAND_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_INDEX_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_UNIFORM_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_SHADER_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_SHADER_WRITE_BIT: VkAccessFlagBits
  declare const VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: VkAccessFlagBits
  declare const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: VkAccessFlagBits
  declare const VK_ACCESS_TRANSFER_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_TRANSFER_WRITE_BIT: VkAccessFlagBits
  declare const VK_ACCESS_HOST_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_HOST_WRITE_BIT: VkAccessFlagBits
  declare const VK_ACCESS_MEMORY_READ_BIT: VkAccessFlagBits
  declare const VK_ACCESS_MEMORY_WRITE_BIT: VkAccessFlagBits
  declare const VK_ACCESS_RESERVED_30_BIT_KHR: VkAccessFlagBits
  declare const VK_ACCESS_RESERVED_31_BIT_KHR: VkAccessFlagBits
  declare const VK_ACCESS_RESERVED_28_BIT_KHR: VkAccessFlagBits
  declare const VK_ACCESS_RESERVED_29_BIT_KHR: VkAccessFlagBits
  declare const VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: VkAccessFlagBits
  declare const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: VkAccessFlagBits
  declare const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: VkAccessFlagBits
  declare const VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: VkAccessFlagBits
  declare const VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX: VkAccessFlagBits
  declare const VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX: VkAccessFlagBits
  declare const VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: VkAccessFlagBits
  declare const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits
  declare const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits
  declare const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits
  declare const VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: VkAccessFlagBits

  /**
   * Bitmask specifying allowed usage of a buffer
   * @member VK_BUFFER_USAGE_TRANSFER_SRC_BIT specifies that the buffer 'can' be used as the source of a _transfer command_ (see the definition of <<synchronization-pipeline-stages-transfer, 'VK_PIPELINE_STAGE_TRANSFER_BIT'>>).
   * @member VK_BUFFER_USAGE_TRANSFER_DST_BIT specifies that the buffer 'can' be used as the destination of a transfer command.
   * @member VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT specifies that the buffer 'can' be used to create a 'VkBufferView' suitable for occupying a 'VkDescriptorSet' slot of type 'VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER'.
   * @member VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT specifies that the buffer 'can' be used to create a 'VkBufferView' suitable for occupying a 'VkDescriptorSet' slot of type 'VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER'.
   * @member VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT specifies that the buffer 'can' be used in a 'VkDescriptorBufferInfo' suitable for occupying a 'VkDescriptorSet' slot either of type 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER' or 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC'.
   * @member VK_BUFFER_USAGE_STORAGE_BUFFER_BIT specifies that the buffer 'can' be used in a 'VkDescriptorBufferInfo' suitable for occupying a 'VkDescriptorSet' slot either of type 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER' or 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC'.
   * @member VK_BUFFER_USAGE_INDEX_BUFFER_BIT specifies that the buffer is suitable for passing as the 'buffer' parameter to 'vkCmdBindIndexBuffer'.
   * @member VK_BUFFER_USAGE_VERTEX_BUFFER_BIT specifies that the buffer is suitable for passing as an element of the 'pBuffers' array to 'vkCmdBindVertexBuffers'.
   * @member VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT specifies that the buffer is suitable for passing as the 'buffer' parameter to 'vkCmdDrawIndirect', 'vkCmdDrawIndexedIndirect', 'vkCmdDrawMeshTasksIndirectNV', 'vkCmdDrawMeshTasksIndirectCountNV',
   * @member VK_BUFFER_USAGE_RESERVED_15_BIT_KHR
   * @member VK_BUFFER_USAGE_RESERVED_16_BIT_KHR
   * @member VK_BUFFER_USAGE_RESERVED_13_BIT_KHR
   * @member VK_BUFFER_USAGE_RESERVED_14_BIT_KHR
   * @member VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT
   * @member VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
   * @member VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT
   * @member VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
   * @member VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT
   */
  export enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    VK_BUFFER_USAGE_RESERVED_15_BIT_KHR,
    VK_BUFFER_USAGE_RESERVED_16_BIT_KHR,
    VK_BUFFER_USAGE_RESERVED_13_BIT_KHR,
    VK_BUFFER_USAGE_RESERVED_14_BIT_KHR,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT,
  }

  declare const VK_BUFFER_USAGE_TRANSFER_SRC_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_TRANSFER_DST_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_INDEX_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_RESERVED_15_BIT_KHR: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_RESERVED_16_BIT_KHR: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_RESERVED_13_BIT_KHR: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_RESERVED_14_BIT_KHR: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits
  declare const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT: VkBufferUsageFlagBits

  /**
   * Bitmask specifying additional parameters of a buffer
   * @member VK_BUFFER_CREATE_SPARSE_BINDING_BIT specifies that the buffer will be backed using sparse memory binding.
   * @member VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT specifies that the buffer 'can' be partially backed using sparse memory binding. Buffers created with this flag 'must' also be created with the 'VK_BUFFER_CREATE_SPARSE_BINDING_BIT' flag.
   * @member VK_BUFFER_CREATE_SPARSE_ALIASED_BIT specifies that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag 'must' also be created with the 'VK_BUFFER_CREATE_SPARSE_BINDING_BIT' flag.
   * @member VK_BUFFER_CREATE_PROTECTED_BIT specifies that the buffer is a protected buffer.
   * @member VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
   */
  export enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
    VK_BUFFER_CREATE_PROTECTED_BIT,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
  }

  declare const VK_BUFFER_CREATE_SPARSE_BINDING_BIT: VkBufferCreateFlagBits
  declare const VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: VkBufferCreateFlagBits
  declare const VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: VkBufferCreateFlagBits
  declare const VK_BUFFER_CREATE_PROTECTED_BIT: VkBufferCreateFlagBits
  declare const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: VkBufferCreateFlagBits

  /**
   * Bitmask specifying a pipeline stage
   * @member VK_SHADER_STAGE_VERTEX_BIT specifies the vertex stage.
   * @member VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT specifies the tessellation control stage.
   * @member VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT specifies the tessellation evaluation stage.
   * @member VK_SHADER_STAGE_GEOMETRY_BIT specifies the geometry stage.
   * @member VK_SHADER_STAGE_FRAGMENT_BIT specifies the fragment stage.
   * @member VK_SHADER_STAGE_COMPUTE_BIT specifies the compute stage.
   * @member VK_SHADER_STAGE_ALL_GRAPHICS
   * @member VK_SHADER_STAGE_ALL
   * @member VK_SHADER_STAGE_RAYGEN_BIT_NV
   * @member VK_SHADER_STAGE_ANY_HIT_BIT_NV
   * @member VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
   * @member VK_SHADER_STAGE_MISS_BIT_NV
   * @member VK_SHADER_STAGE_INTERSECTION_BIT_NV
   * @member VK_SHADER_STAGE_CALLABLE_BIT_NV
   * @member VK_SHADER_STAGE_TASK_BIT_NV specifies the task stage.
   * @member VK_SHADER_STAGE_MESH_BIT_NV specifies the mesh stage.
   */
  export enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    VK_SHADER_STAGE_GEOMETRY_BIT,
    VK_SHADER_STAGE_FRAGMENT_BIT,
    VK_SHADER_STAGE_COMPUTE_BIT,
    VK_SHADER_STAGE_ALL_GRAPHICS,
    VK_SHADER_STAGE_ALL,
    VK_SHADER_STAGE_RAYGEN_BIT_NV,
    VK_SHADER_STAGE_ANY_HIT_BIT_NV,
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV,
    VK_SHADER_STAGE_MISS_BIT_NV,
    VK_SHADER_STAGE_INTERSECTION_BIT_NV,
    VK_SHADER_STAGE_CALLABLE_BIT_NV,
    VK_SHADER_STAGE_TASK_BIT_NV,
    VK_SHADER_STAGE_MESH_BIT_NV,
  }

  declare const VK_SHADER_STAGE_VERTEX_BIT: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_GEOMETRY_BIT: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_FRAGMENT_BIT: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_COMPUTE_BIT: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_ALL_GRAPHICS: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_ALL: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_RAYGEN_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_ANY_HIT_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_MISS_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_INTERSECTION_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_CALLABLE_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_TASK_BIT_NV: VkShaderStageFlagBits
  declare const VK_SHADER_STAGE_MESH_BIT_NV: VkShaderStageFlagBits

  /**
   * Bitmask specifying intended usage of an image
   * @member VK_IMAGE_USAGE_TRANSFER_SRC_BIT specifies that the image 'can' be used as the source of a transfer command.
   * @member VK_IMAGE_USAGE_TRANSFER_DST_BIT specifies that the image 'can' be used as the destination of a transfer command.
   * @member VK_IMAGE_USAGE_SAMPLED_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for occupying a 'VkDescriptorSet' slot either of type 'VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE' or 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', and be sampled by a shader.
   * @member VK_IMAGE_USAGE_STORAGE_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for occupying a 'VkDescriptorSet' slot of type 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE'.
   * @member VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for use as a color or resolve attachment in a 'VkFramebuffer'.
   * @member VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for use as a depth/stencil or depth/stencil resolve
   * @member VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
   * @member VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
   * @member VK_IMAGE_USAGE_RESERVED_13_BIT_KHR
   * @member VK_IMAGE_USAGE_RESERVED_14_BIT_KHR
   * @member VK_IMAGE_USAGE_RESERVED_15_BIT_KHR
   * @member VK_IMAGE_USAGE_RESERVED_10_BIT_KHR
   * @member VK_IMAGE_USAGE_RESERVED_11_BIT_KHR
   * @member VK_IMAGE_USAGE_RESERVED_12_BIT_KHR
   * @member VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
   * @member VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
   */
  export enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    VK_IMAGE_USAGE_SAMPLED_BIT,
    VK_IMAGE_USAGE_STORAGE_BIT,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    VK_IMAGE_USAGE_RESERVED_13_BIT_KHR,
    VK_IMAGE_USAGE_RESERVED_14_BIT_KHR,
    VK_IMAGE_USAGE_RESERVED_15_BIT_KHR,
    VK_IMAGE_USAGE_RESERVED_10_BIT_KHR,
    VK_IMAGE_USAGE_RESERVED_11_BIT_KHR,
    VK_IMAGE_USAGE_RESERVED_12_BIT_KHR,
    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
  }

  declare const VK_IMAGE_USAGE_TRANSFER_SRC_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_TRANSFER_DST_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_SAMPLED_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_STORAGE_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_RESERVED_13_BIT_KHR: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_RESERVED_14_BIT_KHR: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_RESERVED_15_BIT_KHR: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_RESERVED_10_BIT_KHR: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_RESERVED_11_BIT_KHR: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_RESERVED_12_BIT_KHR: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: VkImageUsageFlagBits
  declare const VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkImageUsageFlagBits

  /**
   * Bitmask specifying additional parameters of an image
   * @member VK_IMAGE_CREATE_SPARSE_BINDING_BIT specifies that the image will be backed using sparse memory binding.
   * @member VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT specifies that the image 'can' be partially backed using sparse memory binding. Images created with this flag 'must' also be created with the 'VK_IMAGE_CREATE_SPARSE_BINDING_BIT' flag.
   * @member VK_IMAGE_CREATE_SPARSE_ALIASED_BIT specifies that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag 'must' also be created with the 'VK_IMAGE_CREATE_SPARSE_BINDING_BIT' flag
   * @member VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that the image 'can' be used to create a 'VkImageView' with a different format from the image. For <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> formats, 'VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT' specifies that a 'VkImageView' can be created of a _plane_ of the image.
   * @member VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
   * @member VK_IMAGE_CREATE_ALIAS_BIT
   * @member VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
   * @member VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
   * @member VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT
   * @member VK_IMAGE_CREATE_EXTENDED_USAGE_BIT
   * @member VK_IMAGE_CREATE_PROTECTED_BIT
   * @member VK_IMAGE_CREATE_DISJOINT_BIT
   * @member VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV
   * @member VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
   * @member VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
   * @member VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
   * @member VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR
   * @member VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR
   * @member VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR
   * @member VK_IMAGE_CREATE_DISJOINT_BIT_KHR
   * @member VK_IMAGE_CREATE_ALIAS_BIT_KHR
   */
  export enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_ALIAS_BIT,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VK_IMAGE_CREATE_PROTECTED_BIT,
    VK_IMAGE_CREATE_DISJOINT_BIT,
    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR,
  }

  declare const VK_IMAGE_CREATE_SPARSE_BINDING_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_ALIAS_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_PROTECTED_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_DISJOINT_BIT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_DISJOINT_BIT_KHR: VkImageCreateFlagBits
  declare const VK_IMAGE_CREATE_ALIAS_BIT_KHR: VkImageCreateFlagBits

  /**
   * Bitmask specifying additional parameters of an image view
   * @member VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT prohibits the implementation from accessing the fragment density map by the host during 'vkCmdBeginRenderPass' as the contents are expected to change after recording
   */
  export enum VkImageViewCreateFlagBits {
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT,
  }

  declare const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: VkImageViewCreateFlagBits

  /**
   * Bitmask specifying additional parameters of sampler
   * @member VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT specifies that the sampler will read from an image created with 'flags' containing 'VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT'.
   * @member VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT specifies that the implementation 'may' use approximations when reconstructing a full color value for texture access from a subsampled image.
   */
  export enum VkSamplerCreateFlagBits {
    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,
    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
  }

  declare const VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: VkSamplerCreateFlagBits
  declare const VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: VkSamplerCreateFlagBits

  /**
   * Bitmask controlling how a pipeline is created
   * @member VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the created pipeline will not be optimized. Using this flag 'may' reduce the time taken to create the pipeline.
   * @member VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to 'vkCreateGraphicsPipelines' or 'vkCreateComputePipelines'.
   * @member VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to be created will be a child of a previously created parent pipeline.ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
   * @member VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT specifies that any shader input variables decorated as 'ViewIndex' will be assigned values as if they were decorated as 'DeviceIndex'.
   * @member VK_PIPELINE_CREATE_DISPATCH_BASE
   * @member VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
   * @member VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR
   * @member VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
   * @member VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
   * @member VK_PIPELINE_CREATE_DISPATCH_BASE_KHR
   */
  export enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    VK_PIPELINE_CREATE_DISPATCH_BASE,
    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV,
    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR,
  }

  declare const VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_DERIVATIVE_BIT: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_DISPATCH_BASE: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: VkPipelineCreateFlagBits
  declare const VK_PIPELINE_CREATE_DISPATCH_BASE_KHR: VkPipelineCreateFlagBits

  /**
   * Bitmask controlling how a pipeline shader stage is created
   * @member VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV
   * @member VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT specifies that the <<interfaces-builtin-variables-sgs,'SubgroupSize'>> 'may' vary in the shader stage.
   * @member VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT specifies that the subgroup sizes 'must' be launched with all invocations active in the compute stage.
   */
  export enum VkPipelineShaderStageCreateFlagBits {
    VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV,
    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT,
  }

  declare const VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV: VkPipelineShaderStageCreateFlagBits
  declare const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: VkPipelineShaderStageCreateFlagBits
  declare const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT: VkPipelineShaderStageCreateFlagBits

  /**
   * Bitmask controlling which components are written to the framebuffer
   * @member VK_COLOR_COMPONENT_R_BIT specifies that the [eq]#R# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
   * @member VK_COLOR_COMPONENT_G_BIT specifies that the [eq]#G# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
   * @member VK_COLOR_COMPONENT_B_BIT specifies that the [eq]#B# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
   * @member VK_COLOR_COMPONENT_A_BIT specifies that the [eq]#A# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
   */
  export enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT,
    VK_COLOR_COMPONENT_G_BIT,
    VK_COLOR_COMPONENT_B_BIT,
    VK_COLOR_COMPONENT_A_BIT,
  }

  declare const VK_COLOR_COMPONENT_R_BIT: VkColorComponentFlagBits
  declare const VK_COLOR_COMPONENT_G_BIT: VkColorComponentFlagBits
  declare const VK_COLOR_COMPONENT_B_BIT: VkColorComponentFlagBits
  declare const VK_COLOR_COMPONENT_A_BIT: VkColorComponentFlagBits

  /**
   * Bitmask specifying initial state and behavior of a fence
   * @member VK_FENCE_CREATE_SIGNALED_BIT specifies that the fence object is created in the signaled state. Otherwise, it is created in the unsignaled state.
   */
  export enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT,
  }

  declare const VK_FENCE_CREATE_SIGNALED_BIT: VkFenceCreateFlagBits

  /**
   *
   */
  export enum VkSemaphoreCreateFlagBits {}

  /**
   * Bitmask specifying features supported by a buffer
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT specifies that an image view 'can' be <<descriptorsets-sampledimage, sampled from>>.
   * @member VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT specifies that an image view 'can' be used as a <<descriptorsets-storageimage, storage images>>.
   * @member VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT specifies that an image view 'can' be used as storage image that supports atomic operations.
   * @member VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT
   * @member VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT
   * @member VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
   * @member VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT
   * @member VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT specifies that an image view 'can' be used as a framebuffer color attachment and as an input attachment.
   * @member VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT specifies that an image view 'can' be used as a framebuffer color attachment that supports blending and as an input attachment.
   * @member VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that an image view 'can' be used as a framebuffer depth/stencil attachment and as an input attachment.
   * @member VK_FORMAT_FEATURE_BLIT_SRC_BIT specifies that an image 'can' be used as 'srcImage' for the 'vkCmdBlitImage' command.
   * @member VK_FORMAT_FEATURE_BLIT_DST_BIT specifies that an image 'can' be used as 'dstImage' for the 'vkCmdBlitImage' command.
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT specifies that if 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT' is also set, an image view 'can' be used with a sampler that has either of 'magFilter' or 'minFilter' set to 'VK_FILTER_LINEAR', or 'mipmapMode' set to 'VK_SAMPLER_MIPMAP_MODE_LINEAR'. If 'VK_FORMAT_FEATURE_BLIT_SRC_BIT' is also set, an image can be used as the 'srcImage' to 'vkCmdBlitImage' with a 'filter' of 'VK_FILTER_LINEAR'. This bit 'must' only be exposed for formats that also support the 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT' or 'VK_FORMAT_FEATURE_BLIT_SRC_BIT'.+If the format being queried is a depth/stencil format, this bit onlyspecifies that the depth aspect (not the stencil aspect) of an image of thisformat supports linear filtering, and that linear filtering of the depthaspect is supported whether depth compare is enabled in the sampler or not.If this bit is not present, linear filtering with depth compare disabled isunsupported and linear filtering with depth compare enabled is supported,but 'may' compute the filtered value in an implementation-dependent mannerwhich differs from the normal rules of linear filtering.The resulting value 'must' be in the range [eq]#[0,1]# and 'should' beproportional to, or a weighted average of, the number of comparison passesor failures.
   * @member VK_FORMAT_FEATURE_TRANSFER_SRC_BIT
   * @member VK_FORMAT_FEATURE_TRANSFER_DST_BIT
   * @member VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
   * @member VK_FORMAT_FEATURE_DISJOINT_BIT
   * @member VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG
   * @member VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR
   * @member VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR
   * @member VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR
   * @member VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
   * @member VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT
   * @member VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR
   * @member VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR
   * @member VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
   * @member VK_FORMAT_FEATURE_DISJOINT_BIT_KHR
   * @member VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR
   * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
   */
  export enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    VK_FORMAT_FEATURE_BLIT_DST_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR,
    VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR,
    VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR,
    VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
  }

  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_BLIT_SRC_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_BLIT_DST_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_TRANSFER_DST_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_DISJOINT_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits
  declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: VkFormatFeatureFlagBits

  /**
   * Bitmask specifying constraints on a query
   * @member VK_QUERY_CONTROL_PRECISE_BIT specifies the precision of <<queries-occlusion, occlusion queries>>.
   */
  export enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT,
  }

  declare const VK_QUERY_CONTROL_PRECISE_BIT: VkQueryControlFlagBits

  /**
   * Bitmask specifying how and when query results are returned
   * @member VK_QUERY_RESULT_64_BIT specifies the results will be written as an array of 64-bit unsigned integer values. If this bit is not set, the results will be written as an array of 32-bit unsigned integer values.
   * @member VK_QUERY_RESULT_WAIT_BIT specifies that Vulkan will wait for each query's status to become available before retrieving its results.
   * @member VK_QUERY_RESULT_WITH_AVAILABILITY_BIT specifies that the availability status accompanies the results.
   * @member VK_QUERY_RESULT_PARTIAL_BIT specifies that returning partial results is acceptable.
   */
  export enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT,
    VK_QUERY_RESULT_WAIT_BIT,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
    VK_QUERY_RESULT_PARTIAL_BIT,
  }

  declare const VK_QUERY_RESULT_64_BIT: VkQueryResultFlagBits
  declare const VK_QUERY_RESULT_WAIT_BIT: VkQueryResultFlagBits
  declare const VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: VkQueryResultFlagBits
  declare const VK_QUERY_RESULT_PARTIAL_BIT: VkQueryResultFlagBits

  /**
   * Bitmask specifying usage behavior for command buffer
   * @member VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT specifies that each recording of the command buffer will only be submitted once, and the command buffer will be reset and recorded again between each submission.
   * @member VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT specifies that a secondary command buffer is considered to be entirely inside a render pass. If this is a primary command buffer, then this bit is ignored.
   * @member VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT specifies that a command buffer 'can' be resubmitted to a queue while it is in the _pending state_, and recorded into multiple primary command buffers.
   */
  export enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
  }

  declare const VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: VkCommandBufferUsageFlagBits
  declare const VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: VkCommandBufferUsageFlagBits
  declare const VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: VkCommandBufferUsageFlagBits

  /**
   * Bitmask specifying queried pipeline statistics
   * @member VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT specifies that queries managed by the pool will count the number of vertices processed by the <<drawing,input assembly>> stage. Vertices corresponding to incomplete primitives 'may' contribute to the count.
   * @member VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives processed by the <<drawing,input assembly>> stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives 'may' be counted.
   * @member VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of vertex shader invocations. This counter's value is incremented each time a vertex shader is <<shaders-vertex-execution,invoked>>.
   * @member VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of geometry shader invocations. This counter's value is incremented each time a geometry shader is <<shaders-geometry-execution,invoked>>. In the case of <<geometry-invocations,instanced geometry shaders>>, the geometry shader invocations count is incremented for each separate instanced invocation.
   * @member VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives generated by geometry shader invocations. The counter's value is incremented each time the geometry shader emits a primitive. Restarting primitive topology using the SPIR-V instructions 'OpEndPrimitive' or 'OpEndStreamPrimitive' has no effect on the geometry shader output primitives count.
   * @member VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of primitives processed by the <<vertexpostproc-clipping,Primitive Clipping>> stage of the pipeline. The counter's value is incremented each time a primitive reaches the primitive clipping stage.
   * @member VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives output by the <<vertexpostproc-clipping,Primitive Clipping>> stage of the pipeline. The counter's value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but 'must' satisfy the following conditions:
   * @member VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of fragment shader invocations. The counter's value is incremented each time the fragment shader is <<shaders-fragment-execution,invoked>>.
   * @member VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT specifies that queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter's value is incremented once for each patch for which a tessellation control shader is <<shaders-tessellation-control-execution,invoked>>.
   * @member VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter's value is incremented each time the tessellation evaluation shader is <<shaders-tessellation-evaluation-execution,invoked>>.
   * @member VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of compute shader invocations. The counter's value is incremented every time the compute shader is invoked. Implementations 'may' skip the execution of certain compute shader invocations or execute additional compute shader invocations for implementation-dependent reasons as long as the results of rendering otherwise remain unchanged.
   */
  export enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
  }

  declare const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits
  declare const VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits

  /**
   * Bitmask specifying which aspects of an image are included in a view
   * @member VK_IMAGE_ASPECT_COLOR_BIT specifies the color aspect.
   * @member VK_IMAGE_ASPECT_DEPTH_BIT specifies the depth aspect.
   * @member VK_IMAGE_ASPECT_STENCIL_BIT specifies the stencil aspect.
   * @member VK_IMAGE_ASPECT_METADATA_BIT specifies the metadata aspect, used for sparse <<sparsememory, sparse resource>> operations.
   * @member VK_IMAGE_ASPECT_PLANE_0_BIT specifies plane 0 of a _multi-planar_ image format.
   * @member VK_IMAGE_ASPECT_PLANE_1_BIT specifies plane 1 of a _multi-planar_ image format.
   * @member VK_IMAGE_ASPECT_PLANE_2_BIT specifies plane 2 of a _multi-planar_ image format.
   * @member VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT
   * @member VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT
   * @member VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT
   * @member VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT
   * @member VK_IMAGE_ASPECT_PLANE_0_BIT_KHR
   * @member VK_IMAGE_ASPECT_PLANE_1_BIT_KHR
   * @member VK_IMAGE_ASPECT_PLANE_2_BIT_KHR
   */
  export enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT,
    VK_IMAGE_ASPECT_DEPTH_BIT,
    VK_IMAGE_ASPECT_STENCIL_BIT,
    VK_IMAGE_ASPECT_METADATA_BIT,
    VK_IMAGE_ASPECT_PLANE_0_BIT,
    VK_IMAGE_ASPECT_PLANE_1_BIT,
    VK_IMAGE_ASPECT_PLANE_2_BIT,
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR,
  }

  declare const VK_IMAGE_ASPECT_COLOR_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_DEPTH_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_STENCIL_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_METADATA_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_PLANE_0_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_PLANE_1_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_PLANE_2_BIT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits
  declare const VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits

  /**
   * Bitmask specifying additional information about a sparse image resource
   * @member VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT specifies that the image uses a single mip tail region for all array layers.
   * @member VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT specifies that the first mip level whose dimensions are not integer multiples of the corresponding dimensions of the sparse image block begins the mip tail region.
   * @member VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT specifies that the image uses non-standard sparse image block dimensions, and the 'imageGranularity' values do not match the standard sparse image block dimensions for the given format.
   */
  export enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
  }

  declare const VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: VkSparseImageFormatFlagBits
  declare const VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: VkSparseImageFormatFlagBits
  declare const VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: VkSparseImageFormatFlagBits

  /**
   * Bitmask specifying usage of a sparse memory binding operation
   * @member VK_SPARSE_MEMORY_BIND_METADATA_BIT specifies that the memory being bound is only for the metadata aspect.
   */
  export enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT,
  }

  declare const VK_SPARSE_MEMORY_BIND_METADATA_BIT: VkSparseMemoryBindFlagBits

  /**
   * Bitmask specifying pipeline stages
   * @member VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT specifies the stage of the pipeline where any commands are initially received by the queue.
   * @member VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT specifies the stage of the pipeline where Draw/DispatchIndirect data structures are consumed. This stage also includes reading commands written by 'vkCmdProcessCommandsNVX'.
   * @member VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
   * @member VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
   * @member VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
   * @member VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
   * @member VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
   * @member VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
   * @member VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
   * @member VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
   * @member VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
   * @member VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
   * @member VK_PIPELINE_STAGE_TRANSFER_BIT
   * @member VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
   * @member VK_PIPELINE_STAGE_HOST_BIT
   * @member VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
   * @member VK_PIPELINE_STAGE_ALL_COMMANDS_BIT
   * @member VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR
   * @member VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR
   * @member VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
   * @member VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT
   * @member VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
   * @member VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
   * @member VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV
   * @member VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
   * @member VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
   * @member VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
   * @member VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
   */
  export enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    VK_PIPELINE_STAGE_TRANSFER_BIT,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    VK_PIPELINE_STAGE_HOST_BIT,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR,
    VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR,
    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX,
    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV,
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV,
    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV,
    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
  }

  declare const VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_TRANSFER_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_HOST_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits
  declare const VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT: VkPipelineStageFlagBits

  /**
   * Bitmask specifying usage behavior for a command pool
   * @member VK_COMMAND_POOL_CREATE_TRANSIENT_BIT specifies that command buffers allocated from the pool will be short-lived, meaning that they will be reset or freed in a relatively short timeframe. This flag 'may' be used by the implementation to control memory allocation behavior within the pool.
   * @member VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT allows any command buffer allocated from a pool to be individually reset to the <<commandbuffers-lifecycle, initial state>>; either by calling 'vkResetCommandBuffer', or via the implicit reset when calling 'vkBeginCommandBuffer'. If this flag is not set on a pool, then 'vkResetCommandBuffer' 'must' not be called for any command buffer allocated from that pool.
   * @member VK_COMMAND_POOL_CREATE_PROTECTED_BIT specifies that command buffers allocated from the pool are protected command buffers. If the protected memory feature is not enabled, the 'VK_COMMAND_POOL_CREATE_PROTECTED_BIT' bit of 'flags' 'must' not be set.
   */
  export enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
  }

  declare const VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: VkCommandPoolCreateFlagBits
  declare const VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: VkCommandPoolCreateFlagBits
  declare const VK_COMMAND_POOL_CREATE_PROTECTED_BIT: VkCommandPoolCreateFlagBits

  /**
   * Bitmask controlling behavior of a command pool reset
   * @member VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT specifies that resetting a command pool recycles all of the resources from the command pool back to the system.
   */
  export enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
  }

  declare const VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: VkCommandPoolResetFlagBits

  /**
   * Bitmask controlling behavior of a command buffer reset
   * @member VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT specifies that most or all memory resources currently owned by the command buffer 'should' be returned to the parent command pool. If this flag is not set, then the command buffer 'may' hold onto memory resources and reuse them when recording commands. 'commandBuffer' is moved to the <<commandbuffers-lifecycle, initial state>>.
   */
  export enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
  }

  declare const VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: VkCommandBufferResetFlagBits

  /**
   * Bitmask specifying sample counts supported for an image used for storage operations
   * @member VK_SAMPLE_COUNT_1_BIT
   * @member VK_SAMPLE_COUNT_2_BIT
   * @member VK_SAMPLE_COUNT_4_BIT
   * @member VK_SAMPLE_COUNT_8_BIT
   * @member VK_SAMPLE_COUNT_16_BIT
   * @member VK_SAMPLE_COUNT_32_BIT
   * @member VK_SAMPLE_COUNT_64_BIT
   */
  export enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT,
    VK_SAMPLE_COUNT_2_BIT,
    VK_SAMPLE_COUNT_4_BIT,
    VK_SAMPLE_COUNT_8_BIT,
    VK_SAMPLE_COUNT_16_BIT,
    VK_SAMPLE_COUNT_32_BIT,
    VK_SAMPLE_COUNT_64_BIT,
  }

  declare const VK_SAMPLE_COUNT_1_BIT: VkSampleCountFlagBits
  declare const VK_SAMPLE_COUNT_2_BIT: VkSampleCountFlagBits
  declare const VK_SAMPLE_COUNT_4_BIT: VkSampleCountFlagBits
  declare const VK_SAMPLE_COUNT_8_BIT: VkSampleCountFlagBits
  declare const VK_SAMPLE_COUNT_16_BIT: VkSampleCountFlagBits
  declare const VK_SAMPLE_COUNT_32_BIT: VkSampleCountFlagBits
  declare const VK_SAMPLE_COUNT_64_BIT: VkSampleCountFlagBits

  /**
   * Bitmask specifying additional properties of an attachment
   * @member VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT specifies that the attachment aliases the same device memory as other attachments.
   */
  export enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
  }

  declare const VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: VkAttachmentDescriptionFlagBits

  /**
   * Bitmask specifying sets of stencil state for which to update the compare mask
   * @member VK_STENCIL_FACE_FRONT_BIT specifies that only the front set of stencil state is updated.
   * @member VK_STENCIL_FACE_BACK_BIT specifies that only the back set of stencil state is updated.
   * @member VK_STENCIL_FACE_FRONT_AND_BACK is the combination of 'VK_STENCIL_FACE_FRONT_BIT' and 'VK_STENCIL_FACE_BACK_BIT', and specifies that both sets of stencil state are updated.
   * @member VK_STENCIL_FRONT_AND_BACK
   */
  export enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT,
    VK_STENCIL_FACE_BACK_BIT,
    VK_STENCIL_FACE_FRONT_AND_BACK,
    VK_STENCIL_FRONT_AND_BACK,
  }

  declare const VK_STENCIL_FACE_FRONT_BIT: VkStencilFaceFlagBits
  declare const VK_STENCIL_FACE_BACK_BIT: VkStencilFaceFlagBits
  declare const VK_STENCIL_FACE_FRONT_AND_BACK: VkStencilFaceFlagBits
  declare const VK_STENCIL_FRONT_AND_BACK: VkStencilFaceFlagBits

  /**
   * Bitmask specifying certain supported operations on a descriptor pool
   * @member VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT specifies that descriptor sets 'can' return their individual allocations to the pool, i.e. all of 'vkAllocateDescriptorSets', 'vkFreeDescriptorSets', and 'vkResetDescriptorPool' are allowed. Otherwise, descriptor sets allocated from the pool 'must' not be individually freed back to the pool, i.e. only 'vkAllocateDescriptorSets' and 'vkResetDescriptorPool' are allowed.
   * @member VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT specifies that descriptor sets allocated from this pool 'can' include bindings with the 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT' bit set. It is valid to allocate descriptor sets that have bindings that do not set the 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT' bit from a pool that has 'VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT' set.
   */
  export enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,
  }

  declare const VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: VkDescriptorPoolCreateFlagBits
  declare const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorPoolCreateFlagBits

  /**
   * Bitmask specifying how execution and memory dependencies are formed
   * @member VK_DEPENDENCY_BY_REGION_BIT specifies that dependencies will be <<synchronization-framebuffer-regions, framebuffer-local>>.
   * @member VK_DEPENDENCY_DEVICE_GROUP_BIT
   * @member VK_DEPENDENCY_VIEW_LOCAL_BIT specifies that a <<synchronization-pipeline-barriers-subpass-self-dependencies, subpass has more than one view>>.
   * @member VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR
   * @member VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR
   */
  export enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT,
    VK_DEPENDENCY_DEVICE_GROUP_BIT,
    VK_DEPENDENCY_VIEW_LOCAL_BIT,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR,
  }

  declare const VK_DEPENDENCY_BY_REGION_BIT: VkDependencyFlagBits
  declare const VK_DEPENDENCY_DEVICE_GROUP_BIT: VkDependencyFlagBits
  declare const VK_DEPENDENCY_VIEW_LOCAL_BIT: VkDependencyFlagBits
  declare const VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR: VkDependencyFlagBits
  declare const VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR: VkDependencyFlagBits

  /**
   * Bitmask specifying additional parameters of a semaphore wait operation
   * @member VK_SEMAPHORE_WAIT_ANY_BIT_KHR specifies that the semaphore wait condition is that at least one of the semaphores in 'VkSemaphoreWaitInfoKHR'::'pSemaphores' has reached the value specified by the corresponding element of 'VkSemaphoreWaitInfoKHR'::'pValues'. If 'VK_SEMAPHORE_WAIT_ANY_BIT_KHR' is not set, the semaphore wait condition is that all of the semaphores in 'VkSemaphoreWaitInfoKHR'::'pSemaphores' have reached the value specified by the corresponding element of 'VkSemaphoreWaitInfoKHR'::'pValues'.
   */
  export enum VkSemaphoreWaitFlagBitsKHR {
    VK_SEMAPHORE_WAIT_ANY_BIT_KHR,
  }

  declare const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBitsKHR

  /**
   * Alpha blending type
   * @member VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR specifies that the source image will be treated as opaque.
   * @member VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR specifies that a global alpha value 'must' be specified that will be applied to all pixels in the source image.
   * @member VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR specifies that the alpha value will be determined by the alpha channel of the source image's pixels. If the source format contains no alpha values, no blending will be applied. The source alpha values are not premultiplied into the source image's other color channels.
   * @member VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR is equivalent to 'VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR', except the source alpha values are assumed to be premultiplied into the source image's other color channels.
   */
  export enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
  }

  declare const VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR
  declare const VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR
  declare const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR
  declare const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR

  /**
   * alpha compositing modes supported on a device
   * @member VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR
   * @member VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR
   * @member VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR
   * @member VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR
   */
  export enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
  }

  declare const VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: VkCompositeAlphaFlagBitsKHR
  declare const VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: VkCompositeAlphaFlagBitsKHR
  declare const VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: VkCompositeAlphaFlagBitsKHR
  declare const VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: VkCompositeAlphaFlagBitsKHR

  /**
   * presentation transforms supported on a device
   * @member VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR specifies that image content is presented without being transformed.
   * @member VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR specifies that image content is rotated 90 degrees clockwise.
   * @member VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR specifies that image content is rotated 180 degrees clockwise.
   * @member VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR specifies that image content is rotated 270 degrees clockwise.
   * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR specifies that image content is mirrored horizontally.
   * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR specifies that image content is mirrored horizontally, then rotated 90 degrees clockwise.
   * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR specifies that image content is mirrored horizontally, then rotated 180 degrees clockwise.
   * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR specifies that image content is mirrored horizontally, then rotated 270 degrees clockwise.
   * @member VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR specifies that the presentation transform is not specified, and is instead determined by platform-specific considerations and mechanisms outside Vulkan.
   */
  export enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
  }

  declare const VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: VkSurfaceTransformFlagBitsKHR
  declare const VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: VkSurfaceTransformFlagBitsKHR

  /**
   *
   * @member VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID
   */
  export enum VkSwapchainImageUsageFlagBitsANDROID {
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID,
  }

  declare const VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID: VkSwapchainImageUsageFlagBitsANDROID

  /**
   * Bitmask specifying events which cause a debug report callback
   * @member VK_DEBUG_REPORT_INFORMATION_BIT_EXT specifies an informational message such as resource details that may be handy when debugging an application.
   * @member VK_DEBUG_REPORT_WARNING_BIT_EXT specifies use of Vulkan that 'may' expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases 'may' point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.
   * @member VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT specifies a potentially non-optimal use of Vulkan, e.g. using 'vkCmdClearColorImage' when setting 'VkAttachmentDescription'::'loadOp' to 'VK_ATTACHMENT_LOAD_OP_CLEAR' would have worked.
   * @member VK_DEBUG_REPORT_ERROR_BIT_EXT specifies that the application has violated a valid usage condition of the specification.
   * @member VK_DEBUG_REPORT_DEBUG_BIT_EXT specifies diagnostic information from the implementation and layers.
   */
  export enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
    VK_DEBUG_REPORT_WARNING_BIT_EXT,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
    VK_DEBUG_REPORT_ERROR_BIT_EXT,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT,
  }

  declare const VK_DEBUG_REPORT_INFORMATION_BIT_EXT: VkDebugReportFlagBitsEXT
  declare const VK_DEBUG_REPORT_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT
  declare const VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT
  declare const VK_DEBUG_REPORT_ERROR_BIT_EXT: VkDebugReportFlagBitsEXT
  declare const VK_DEBUG_REPORT_DEBUG_BIT_EXT: VkDebugReportFlagBitsEXT

  /**
   * Bitmask specifying external memory handle types
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV specifies a handle to memory returned by 'vkGetMemoryWin32HandleNV', or one duplicated from such a handle using `DuplicateHandle()`.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV specifies a handle to memory returned by 'vkGetMemoryWin32HandleNV'.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV specifies a valid NT handle to memory returned by `IDXGIResource1::CreateSharedHandle`, or a handle duplicated from such a handle using `DuplicateHandle()`.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV specifies a handle to memory returned by `IDXGIResource::GetSharedHandle()`.
   */
  export enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV,
  }

  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV

  /**
   * Bitmask specifying external memory features
   * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV specifies that external memory of the specified type 'must' be created as a dedicated allocation when used in the manner specified.
   * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV specifies that the implementation supports exporting handles of the specified type.
   * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV specifies that the implementation supports importing handles of the specified type.
   */
  export enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV,
  }

  declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: VkExternalMemoryFeatureFlagBitsNV
  declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: VkExternalMemoryFeatureFlagBitsNV
  declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: VkExternalMemoryFeatureFlagBitsNV

  /**
   * Enum describing what subgroup operations are supported
   * @member VK_SUBGROUP_FEATURE_BASIC_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniform' capability.
   * @member VK_SUBGROUP_FEATURE_VOTE_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformVote' capability.
   * @member VK_SUBGROUP_FEATURE_ARITHMETIC_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformArithmetic' capability.
   * @member VK_SUBGROUP_FEATURE_BALLOT_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformBallot' capability.
   * @member VK_SUBGROUP_FEATURE_SHUFFLE_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformShuffle' capability.
   * @member VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformShuffleRelative' capability.
   * @member VK_SUBGROUP_FEATURE_CLUSTERED_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformClustered' capability.
   * @member VK_SUBGROUP_FEATURE_QUAD_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformQuad' capability.
   * @member VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformPartitionedNV' capability.
   */
  export enum VkSubgroupFeatureFlagBits {
    VK_SUBGROUP_FEATURE_BASIC_BIT,
    VK_SUBGROUP_FEATURE_VOTE_BIT,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
    VK_SUBGROUP_FEATURE_BALLOT_BIT,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
    VK_SUBGROUP_FEATURE_QUAD_BIT,
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
  }

  declare const VK_SUBGROUP_FEATURE_BASIC_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_VOTE_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_BALLOT_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_SHUFFLE_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_CLUSTERED_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_QUAD_BIT: VkSubgroupFeatureFlagBits
  declare const VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV: VkSubgroupFeatureFlagBits

  /**
   * Bitmask specifying allowed usage of an indirect commands layout
   * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX specifies that the processing of sequences 'can' happen at an implementation-dependent order, which is not guaranteed to be coherent across multiple invocations.
   * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX specifies that there is likely a high difference between allocated number of sequences and actually used.
   * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX specifies that there are likely many draw or dispatch calls that are zero-sized (zero grid dimension, no primitives to render).
   * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX specifies that the input data for the sequences is not implicitly indexed from 0..sequencesUsed but a user provided 'VkBuffer' encoding the index is provided.
   */
  export enum VkIndirectCommandsLayoutUsageFlagBitsNVX {
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX,
  }

  declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX: VkIndirectCommandsLayoutUsageFlagBitsNVX
  declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX: VkIndirectCommandsLayoutUsageFlagBitsNVX
  declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX: VkIndirectCommandsLayoutUsageFlagBitsNVX
  declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX: VkIndirectCommandsLayoutUsageFlagBitsNVX

  /**
   * Bitmask specifying allowed usage of an object entry
   * @member VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX specifies that the resource is bound to 'VK_PIPELINE_BIND_POINT_GRAPHICS'
   * @member VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX specifies that the resource is bound to 'VK_PIPELINE_BIND_POINT_COMPUTE'
   */
  export enum VkObjectEntryUsageFlagBitsNVX {
    VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX,
    VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX,
  }

  declare const VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX: VkObjectEntryUsageFlagBitsNVX
  declare const VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX: VkObjectEntryUsageFlagBitsNVX

  /**
   * Bitmask specifying descriptor set layout properties
   * @member VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR specifies that descriptor sets 'must' not be allocated using this layout, and descriptors are instead pushed by 'vkCmdPushDescriptorSetKHR'.
   * @member VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
   */
  export enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
  }

  declare const VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: VkDescriptorSetLayoutCreateFlagBits
  declare const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT: VkDescriptorSetLayoutCreateFlagBits

  /**
   * Bit specifying external memory handle types
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file descriptor handle that has only limited valid usage outside of Vulkan and other compatible APIs. It 'must' be compatible with the POSIX system calls 'dup', 'dup2', 'close', and the non-standard system call 'dup3'. Additionally, it 'must' be transportable over a socket using an 'SCM_RIGHTS' control message. It owns a reference to the underlying memory resource represented by its Vulkan memory object.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT handle that has only limited valid usage outside of Vulkan and other compatible APIs. It 'must' be compatible with the functions 'DuplicateHandle', 'CloseHandle', 'CompareObjectHandles', 'GetHandleInformation', and 'SetHandleInformation'. It owns a reference to the underlying memory resource represented by its Vulkan memory object.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a global share handle that has only limited valid usage outside of Vulkan and other compatible APIs. It is not compatible with any native APIs. It does not own a reference to the underlying memory resource represented its Vulkan memory object, and will therefore become invalid when all Vulkan memory objects associated with it are destroyed.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT specifies an NT handle returned by 'IDXGIResource1'::'CreateSharedHandle' referring to a Direct3D 10 or 11 texture resource. It owns a reference to the memory used by the Direct3D resource.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT specifies a global share handle returned by 'IDXGIResource'::'GetSharedHandle' referring to a Direct3D 10 or 11 texture resource. It does not own a reference to the underlying Direct3D resource, and will therefore become invalid when all Vulkan memory objects and Direct3D resources associated with it are destroyed.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT specifies an NT handle returned by 'ID3D12Device'::'CreateSharedHandle' referring to a Direct3D 12 heap resource. It owns a reference to the resources used by the Direct3D heap.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT specifies an NT handle returned by 'ID3D12Device'::'CreateSharedHandle' referring to a Direct3D 12 committed resource. It owns a reference to the memory used by the Direct3D resource.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT specifies a host reference returned by a host memory allocation command. It does not own a reference to the underlying memory resource, and will therefore become invalid if the host memory is freed.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT specifies a host reference to _host mapped foreign memory_. It does not own a reference to the underlying memory resource, and will therefore become invalid if the foreign memory is unmapped or otherwise becomes no longer available.
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
   */
  export enum VkExternalMemoryHandleTypeFlagBits {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
  }

  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagBits
  declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits

  /**
   * Bitmask specifying features of an external memory handle type
   * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT specifies that images or buffers created with the specified parameters and handle type 'must' use the mechanisms defined by 'VkMemoryDedicatedRequirements' and 'VkMemoryDedicatedAllocateInfo' to create (or import) a dedicated allocation for the image or buffer.
   * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT specifies that handles of this type 'can' be exported from Vulkan memory objects.
   * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT specifies that handles of this type 'can' be imported as Vulkan memory objects.
   * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
   * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
   */
  export enum VkExternalMemoryFeatureFlagBits {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
  }

  declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: VkExternalMemoryFeatureFlagBits
  declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: VkExternalMemoryFeatureFlagBits
  declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: VkExternalMemoryFeatureFlagBits
  declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagBits
  declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits
  declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits

  /**
   * Bitmask of valid external semaphore handle types
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file descriptor handle that has only limited valid usage outside of Vulkan and other compatible APIs. It 'must' be compatible with the POSIX system calls 'dup', 'dup2', 'close', and the non-standard system call 'dup3'. Additionally, it 'must' be transportable over a socket using an 'SCM_RIGHTS' control message. It owns a reference to the underlying synchronization primitive represented by its Vulkan semaphore object.
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT handle that has only limited valid usage outside of Vulkan and other compatible APIs. It 'must' be compatible with the functions 'DuplicateHandle', 'CloseHandle', 'CompareObjectHandles', 'GetHandleInformation', and 'SetHandleInformation'. It owns a reference to the underlying synchronization primitive represented by its Vulkan semaphore object.
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a global share handle that has only limited valid usage outside of Vulkan and other compatible APIs. It is not compatible with any native APIs. It does not own a reference to the underlying synchronization primitive represented its Vulkan semaphore object, and will therefore become invalid when all Vulkan semaphore objects associated with it are destroyed.
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT specifies an NT handle returned by 'ID3D12Device'::'CreateSharedHandle' referring to a Direct3D 12 fence. It owns a reference to the underlying synchronization primitive associated with the Direct3D fence.
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT specifies a POSIX file descriptor handle to a Linux Sync File or Android Fence object. It can be used with any native API accepting a valid sync file or fence as input. It owns a reference to the underlying synchronization primitive associated with the file descriptor. Implementations which support importing this handle type 'must' accept any type of sync or fence FD supported by the native system they are running on.
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
   * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
   */
  export enum VkExternalSemaphoreHandleTypeFlagBits {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  }

  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits

  /**
   * Bitfield describing features of an external semaphore handle type
   * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
   * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
   * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
   * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
   */
  export enum VkExternalSemaphoreFeatureFlagBits {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
  }

  declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits
  declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits

  /**
   * Bitmask specifying additional parameters of semaphore payload import
   * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT specifies that the semaphore payload will be imported only temporarily, as described in <<synchronization-semaphores-importing,Importing Semaphore Payloads>>, regardless of the permanence of 'handleType'.
   * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
   */
  export enum VkSemaphoreImportFlagBits {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
  }

  declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: VkSemaphoreImportFlagBits
  declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagBits

  /**
   * Bitmask of valid external fence handle types
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file descriptor handle that has only limited valid usage outside of Vulkan and other compatible APIs. It 'must' be compatible with the POSIX system calls 'dup', 'dup2', 'close', and the non-standard system call 'dup3'. Additionally, it 'must' be transportable over a socket using an 'SCM_RIGHTS' control message. It owns a reference to the underlying synchronization primitive represented by its Vulkan fence object.
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT handle that has only limited valid usage outside of Vulkan and other compatible APIs. It 'must' be compatible with the functions 'DuplicateHandle', 'CloseHandle', 'CompareObjectHandles', 'GetHandleInformation', and 'SetHandleInformation'. It owns a reference to the underlying synchronization primitive represented by its Vulkan fence object.
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a global share handle that has only limited valid usage outside of Vulkan and other compatible APIs. It is not compatible with any native APIs. It does not own a reference to the underlying synchronization primitive represented by its Vulkan fence object, and will therefore become invalid when all Vulkan fence objects associated with it are destroyed.
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT specifies a POSIX file descriptor handle to a Linux Sync File or Android Fence. It can be used with any native API accepting a valid sync file or fence as input. It owns a reference to the underlying synchronization primitive associated with the file descriptor. Implementations which support importing this handle type 'must' accept any type of sync or fence FD supported by the native system they are running on.
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
   * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
   */
  export enum VkExternalFenceHandleTypeFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  }

  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalFenceHandleTypeFlagBits
  declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits

  /**
   * Bitfield describing features of an external fence handle type
   * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
   * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
   * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
   * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
   */
  export enum VkExternalFenceFeatureFlagBits {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
  }

  declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: VkExternalFenceFeatureFlagBits
  declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: VkExternalFenceFeatureFlagBits
  declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits
  declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits

  /**
   * Bitmask specifying additional parameters of fence payload import
   * @member VK_FENCE_IMPORT_TEMPORARY_BIT specifies that the fence payload will be imported only temporarily, as described in <<synchronization-fences-importing,Importing Fence Payloads>>, regardless of the permanence of 'handleType'.
   * @member VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
   */
  export enum VkFenceImportFlagBits {
    VK_FENCE_IMPORT_TEMPORARY_BIT,
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
  }

  declare const VK_FENCE_IMPORT_TEMPORARY_BIT: VkFenceImportFlagBits
  declare const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBits

  /**
   * Surface-relative counter types
   * @member VK_SURFACE_COUNTER_VBLANK_EXT specifies a counter incrementing once every time a vertical blanking period occurs on the display associated with the surface.
   */
  export enum VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT,
  }

  declare const VK_SURFACE_COUNTER_VBLANK_EXT: VkSurfaceCounterFlagBitsEXT

  /**
   * Bitmask specifying supported peer memory features
   * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT specifies that the memory 'can' be accessed as the source of a 'vkCmdCopyBuffer', 'vkCmdCopyImage', 'vkCmdCopyBufferToImage', or 'vkCmdCopyImageToBuffer' command.
   * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT specifies that the memory 'can' be accessed as the destination of a 'vkCmdCopyBuffer', 'vkCmdCopyImage', 'vkCmdCopyBufferToImage', or 'vkCmdCopyImageToBuffer' command.
   * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT specifies that the memory 'can' be read as any memory access type.
   * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT specifies that the memory 'can' be written as any memory access type. Shader atomics are considered to be writes.
   * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
   * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
   * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
   * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
   */
  export enum VkPeerMemoryFeatureFlagBits {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
  }

  declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits
  declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits

  /**
   * Bitmask specifying flags for a device memory allocation
   * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT specifies that memory will be allocated for the devices in 'VkMemoryAllocateFlagsInfo'::'deviceMask'.
   * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
   */
  export enum VkMemoryAllocateFlagBits {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
  }

  declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: VkMemoryAllocateFlagBits
  declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagBits

  /**
   * Bitmask specifying supported device group present modes
   * @member VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR specifies that any physical device with a presentation engine 'can' present its own swapchain images.
   * @member VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR specifies that any physical device with a presentation engine 'can' present swapchain images from any physical device in its 'presentMask'.
   * @member VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR specifies that any physical device with a presentation engine 'can' present the sum of swapchain images from any physical devices in its 'presentMask'.
   * @member VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR specifies that multiple physical devices with a presentation engine 'can' each present their own swapchain images.
   */
  export enum VkDeviceGroupPresentModeFlagBitsKHR {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
  }

  declare const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR
  declare const VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR
  declare const VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR
  declare const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR

  /**
   * Bitmask controlling swapchain creation
   * @member VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR specifies that images created from the swapchain (i.e. with the 'swapchain' member of 'VkImageSwapchainCreateInfoKHR' set to this swapchain's handle) 'must' use 'VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT'.
   * @member VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR
   * @member VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR
   */
  export enum VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,
  }

  declare const VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkSwapchainCreateFlagBitsKHR
  declare const VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: VkSwapchainCreateFlagBitsKHR
  declare const VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR: VkSwapchainCreateFlagBitsKHR

  /**
   * Bitmask specifying usage of a subpass
   * @member VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX specifies that shaders compiled for this subpass write the attributes for all views in a single invocation of each vertex processing stage. All pipelines compiled against a subpass that includes this bit 'must' write per-view attributes to the `
   * @member VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX specifies that shaders compiled for this subpass use per-view positions which only differ in value in the x component. Per-view viewport mask 'can' also be used.
   * @member VK_SUBPASS_DESCRIPTION_RESERVED_2_BIT_QCOM
   * @member VK_SUBPASS_DESCRIPTION_RESERVED_3_BIT_QCOM
   */
  export enum VkSubpassDescriptionFlagBits {
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
    VK_SUBPASS_DESCRIPTION_RESERVED_2_BIT_QCOM,
    VK_SUBPASS_DESCRIPTION_RESERVED_3_BIT_QCOM,
  }

  declare const VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX: VkSubpassDescriptionFlagBits
  declare const VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX: VkSubpassDescriptionFlagBits
  declare const VK_SUBPASS_DESCRIPTION_RESERVED_2_BIT_QCOM: VkSubpassDescriptionFlagBits
  declare const VK_SUBPASS_DESCRIPTION_RESERVED_3_BIT_QCOM: VkSubpassDescriptionFlagBits

  /**
   * Bitmask specifying which severities of events cause a debug messenger callback
   * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT specifies the most verbose output indicating all diagnostic messages from the Vulkan loader, layers, and drivers should be captured.
   * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT specifies an informational message such as resource details that may be handy when debugging an application.
   * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT specifies use of Vulkan that 'may' expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases 'may' point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.
   * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT specifies that the application has violated a valid usage condition of the specification.
   */
  export enum VkDebugUtilsMessageSeverityFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
  }

  declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT
  declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT
  declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT
  declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT

  /**
   * Bitmask specifying which types of events cause a debug messenger callback
   * @member VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT specifies that some general event has occurred. This is typically a non-specification, non-performance event.
   * @member VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT specifies that something has occurred during validation against the Vulkan specification that may indicate invalid behavior.
   * @member VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT specifies a potentially non-optimal use of Vulkan, e.g. using 'vkCmdClearColorImage' when setting 'VkAttachmentDescription'::'loadOp' to 'VK_ATTACHMENT_LOAD_OP_CLEAR' would have worked.
   */
  export enum VkDebugUtilsMessageTypeFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
  }

  declare const VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT
  declare const VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT
  declare const VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT

  /**
   * Bitmask specifying descriptor set layout binding properties
   * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT indicates that if descriptors in this binding are updated between when the descriptor set is bound in a command buffer and when that command buffer is submitted to a queue, then the submission will use the most recently set descriptors for this binding and the updates do not invalidate the command buffer. Descriptor bindings created with this flag are also partially exempt from the external synchronization requirement in 'vkUpdateDescriptorSetWithTemplateKHR' and
   * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
   * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
   * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
   */
  export enum VkDescriptorBindingFlagBitsEXT {
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
  }

  declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagBitsEXT
  declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagBitsEXT
  declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagBitsEXT
  declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagBitsEXT

  /**
   * Specify the behavior of conditional rendering
   * @member VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT specifies the condition used to determine whether to discard rendering commands or not. That is, if the 32-bit predicate read from 'buffer' memory at 'offset' is zero, the rendering commands are not discarded, and if non zero, then they are discarded.
   */
  export enum VkConditionalRenderingFlagBitsEXT {
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT,
  }

  declare const VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT: VkConditionalRenderingFlagBitsEXT

  /**
   * Bitmask indicating supported depth and stencil resolve modes
   * @member VK_RESOLVE_MODE_NONE_KHR
   * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
   * @member VK_RESOLVE_MODE_AVERAGE_BIT_KHR
   * @member VK_RESOLVE_MODE_MIN_BIT_KHR
   * @member VK_RESOLVE_MODE_MAX_BIT_KHR
   */
  export enum VkResolveModeFlagBitsKHR {
    VK_RESOLVE_MODE_NONE_KHR,
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
    VK_RESOLVE_MODE_AVERAGE_BIT_KHR,
    VK_RESOLVE_MODE_MIN_BIT_KHR,
    VK_RESOLVE_MODE_MAX_BIT_KHR,
  }

  declare const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBitsKHR
  declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBitsKHR
  declare const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBitsKHR
  declare const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBitsKHR
  declare const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBitsKHR

  /**
   * Instance flag bits
   * @member VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV disables face culling for this instance.
   * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV indicates that the front face of the triangle for culling purposes is the face that is counter clockwise in object space relative to the ray origin. Because the facing is determined in object space, an instance transform matrix does not change the winding, but a geometry transform does.
   * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV causes this instance to act as though 'VK_GEOMETRY_OPAQUE_BIT_NV' were specified on all geometries referenced by this instance. This behavior 'can' be overridden by the ray flag 'gl_RayFlagsNoOpaqueNV'.
   * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV causes this instance to act as though 'VK_GEOMETRY_OPAQUE_BIT_NV' were not specified on all geometries referenced by this instance. This behavior 'can' be overridden by the ray flag 'gl_RayFlagsOpaqueNV'.
   */
  export enum VkGeometryInstanceFlagBitsNV {
    VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV,
    VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV,
    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV,
    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV,
  }

  declare const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagBitsNV
  declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: VkGeometryInstanceFlagBitsNV
  declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsNV
  declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsNV

  /**
   * Bitmask specifying additional parameters for a geometry
   * @member VK_GEOMETRY_OPAQUE_BIT_NV indicates that this geometry does not invoke the any-hit shaders even if present in a hit group.
   * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV indicates that the implementation 'must' only call the any-hit shader a single time for each primitive in this geometry. If this bit is absent an implementation 'may' invoke the any-hit shader more than once for this geometry.
   */
  export enum VkGeometryFlagBitsNV {
    VK_GEOMETRY_OPAQUE_BIT_NV,
    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV,
  }

  declare const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsNV
  declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagBitsNV

  /**
   * Bitmask specifying additional parameters for acceleration structure builds
   * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV indicates that the specified acceleration structure 'can' be updated with 'update' of 'VK_TRUE' in 'vkCmdBuildAccelerationStructureNV'.
   * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV indicates that the specified acceleration structure 'can' act as the source for 'vkCmdCopyAccelerationStructureNV' with 'mode' of 'VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV' to produce a compacted acceleration structure.
   * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV indicates that the given acceleration structure build 'should' prioritize trace performance over build time.
   * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV indicates that the given acceleration structure build 'should' prioritize build time over trace performance.
   * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV indicates that this acceleration structure 'should' minimize the size of the scratch memory and the final result build, potentially at the expense of build time or trace performance.
   */
  export enum VkBuildAccelerationStructureFlagBitsNV {
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV,
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV,
    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV,
  }

  declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: VkBuildAccelerationStructureFlagBitsNV
  declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: VkBuildAccelerationStructureFlagBitsNV
  declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: VkBuildAccelerationStructureFlagBitsNV
  declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: VkBuildAccelerationStructureFlagBitsNV
  declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: VkBuildAccelerationStructureFlagBitsNV

  /**
   * Bitmask specifying framebuffer properties
   * @member VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR specifies that image views are not specified, and only attachment compatibility information will be provided via an instance of 'VkFramebufferAttachmentImageInfoKHR'.
   */
  export enum VkFramebufferCreateFlagBits {
    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR,
  }

  declare const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR: VkFramebufferCreateFlagBits

  /**
   * Bitmask specifying pipeline or pipeline stage creation feedback
   * @member VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT indicates that the feedback information is valid.
   * @member VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT indicates that a readily usable pipeline or pipeline stage was found in the 'pipelineCache' specified by the application in the pipeline creation command.+An implementation 'should' set the'VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXTbit' if it was able to avoid the large majority of pipeline or pipeline stagecreation work by using the 'pipelineCache' parameter of'vkCreateGraphicsPipelines','vkCreateRayTracingPipelinesNV',
   * @member VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT
   */
  export enum VkPipelineCreationFeedbackFlagBitsEXT {
    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT,
    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT,
    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT,
  }

  declare const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT: VkPipelineCreationFeedbackFlagBitsEXT
  declare const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT: VkPipelineCreationFeedbackFlagBitsEXT
  declare const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT: VkPipelineCreationFeedbackFlagBitsEXT

  /**
   * Bitmask specifying shader core properties
   */
  export enum VkShaderCorePropertiesFlagBitsAMD {}

  /**
   *
   * @member VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV
   */
  export enum VkShaderModuleCreateFlagBits {
    VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV,
  }

  declare const VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV: VkShaderModuleCreateFlagBits

  /**
   * Enum specifying available compilation control flags
   */
  export enum VkPipelineCompilerControlFlagBitsAMD {}

  /**
   * Opaque handle to a debug messenger object
   */
  declare interface VkDebugUtilsMessengerEXT {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDebugUtilsMessengerEXTConstructor {
    readonly prototype: VkDebugUtilsMessengerEXT
    new (): VkDebugUtilsMessengerEXT
  }

  declare var VkDebugUtilsMessengerEXT: VkDebugUtilsMessengerEXTConstructor

  /**
   * Opaque handle to a debug report callback object
   */
  declare interface VkDebugReportCallbackEXT {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDebugReportCallbackEXTConstructor {
    readonly prototype: VkDebugReportCallbackEXT
    new (): VkDebugReportCallbackEXT
  }

  declare var VkDebugReportCallbackEXT: VkDebugReportCallbackEXTConstructor

  /**
   * Opaque handle to a swapchain object
   */
  declare interface VkSwapchainKHR {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkSwapchainKHRConstructor {
    readonly prototype: VkSwapchainKHR
    new (): VkSwapchainKHR
  }

  declare var VkSwapchainKHR: VkSwapchainKHRConstructor

  /**
   * Opaque handle to a surface object
   */
  declare interface VkSurfaceKHR {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkSurfaceKHRConstructor {
    readonly prototype: VkSurfaceKHR
    new (): VkSurfaceKHR
  }

  declare var VkSurfaceKHR: VkSurfaceKHRConstructor

  /**
   * Opaque handle to a display mode object
   */
  declare interface VkDisplayModeKHR {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDisplayModeKHRConstructor {
    readonly prototype: VkDisplayModeKHR
    new (): VkDisplayModeKHR
  }

  declare var VkDisplayModeKHR: VkDisplayModeKHRConstructor

  /**
   * Opaque handle to a display object
   */
  declare interface VkDisplayKHR {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDisplayKHRConstructor {
    readonly prototype: VkDisplayKHR
    new (): VkDisplayKHR
  }

  declare var VkDisplayKHR: VkDisplayKHRConstructor

  /**
   * Device configuration for performance queries
   */
  declare interface VkPerformanceConfigurationINTEL {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkPerformanceConfigurationINTELConstructor {
    readonly prototype: VkPerformanceConfigurationINTEL
    new (): VkPerformanceConfigurationINTEL
  }

  declare var VkPerformanceConfigurationINTEL: VkPerformanceConfigurationINTELConstructor

  /**
   * Opaque handle to an acceleration structure object
   */
  declare interface VkAccelerationStructureNV {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkAccelerationStructureNVConstructor {
    readonly prototype: VkAccelerationStructureNV
    new (): VkAccelerationStructureNV
  }

  declare var VkAccelerationStructureNV: VkAccelerationStructureNVConstructor

  /**
   * Opaque handle to a validation cache object
   */
  declare interface VkValidationCacheEXT {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkValidationCacheEXTConstructor {
    readonly prototype: VkValidationCacheEXT
    new (): VkValidationCacheEXT
  }

  declare var VkValidationCacheEXT: VkValidationCacheEXTConstructor

  /**
   * Opaque handle to a device-specific sampler Y\
   */
  declare interface VkSamplerYcbcrConversion {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkSamplerYcbcrConversionConstructor {
    readonly prototype: VkSamplerYcbcrConversion
    new (): VkSamplerYcbcrConversion
  }

  declare var VkSamplerYcbcrConversion: VkSamplerYcbcrConversionConstructor

  /**
   * Opaque handle to a descriptor update template
   */
  declare interface VkDescriptorUpdateTemplate {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDescriptorUpdateTemplateConstructor {
    readonly prototype: VkDescriptorUpdateTemplate
    new (): VkDescriptorUpdateTemplate
  }

  declare var VkDescriptorUpdateTemplate: VkDescriptorUpdateTemplateConstructor

  /**
   * Opaque handle to an indirect commands layout object
   */
  declare interface VkIndirectCommandsLayoutNVX {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkIndirectCommandsLayoutNVXConstructor {
    readonly prototype: VkIndirectCommandsLayoutNVX
    new (): VkIndirectCommandsLayoutNVX
  }

  declare var VkIndirectCommandsLayoutNVX: VkIndirectCommandsLayoutNVXConstructor

  /**
   * Opaque handle to an object table
   */
  declare interface VkObjectTableNVX {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkObjectTableNVXConstructor {
    readonly prototype: VkObjectTableNVX
    new (): VkObjectTableNVX
  }

  declare var VkObjectTableNVX: VkObjectTableNVXConstructor

  /**
   * Opaque handle to a pipeline cache object
   */
  declare interface VkPipelineCache {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkPipelineCacheConstructor {
    readonly prototype: VkPipelineCache
    new (): VkPipelineCache
  }

  declare var VkPipelineCache: VkPipelineCacheConstructor

  /**
   * Opaque handle to a render pass object
   */
  declare interface VkRenderPass {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkRenderPassConstructor {
    readonly prototype: VkRenderPass
    new (): VkRenderPass
  }

  declare var VkRenderPass: VkRenderPassConstructor

  /**
   * Opaque handle to a framebuffer object
   */
  declare interface VkFramebuffer {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkFramebufferConstructor {
    readonly prototype: VkFramebuffer
    new (): VkFramebuffer
  }

  declare var VkFramebuffer: VkFramebufferConstructor

  /**
   * Opaque handle to a query pool object
   */
  declare interface VkQueryPool {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkQueryPoolConstructor {
    readonly prototype: VkQueryPool
    new (): VkQueryPool
  }

  declare var VkQueryPool: VkQueryPoolConstructor

  /**
   * Opaque handle to an event object
   */
  declare interface VkEvent {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkEventConstructor {
    readonly prototype: VkEvent
    new (): VkEvent
  }

  declare var VkEvent: VkEventConstructor

  /**
   * Opaque handle to a semaphore object
   */
  declare interface VkSemaphore {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkSemaphoreConstructor {
    readonly prototype: VkSemaphore
    new (): VkSemaphore
  }

  declare var VkSemaphore: VkSemaphoreConstructor

  /**
   * Opaque handle to a fence object
   */
  declare interface VkFence {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkFenceConstructor {
    readonly prototype: VkFence
    new (): VkFence
  }

  declare var VkFence: VkFenceConstructor

  /**
   * Opaque handle to a descriptor pool object
   */
  declare interface VkDescriptorPool {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDescriptorPoolConstructor {
    readonly prototype: VkDescriptorPool
    new (): VkDescriptorPool
  }

  declare var VkDescriptorPool: VkDescriptorPoolConstructor

  /**
   * Opaque handle to a descriptor set layout object
   */
  declare interface VkDescriptorSetLayout {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDescriptorSetLayoutConstructor {
    readonly prototype: VkDescriptorSetLayout
    new (): VkDescriptorSetLayout
  }

  declare var VkDescriptorSetLayout: VkDescriptorSetLayoutConstructor

  /**
   * Opaque handle to a descriptor set object
   */
  declare interface VkDescriptorSet {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDescriptorSetConstructor {
    readonly prototype: VkDescriptorSet
    new (): VkDescriptorSet
  }

  declare var VkDescriptorSet: VkDescriptorSetConstructor

  /**
   * Opaque handle to a sampler object
   */
  declare interface VkSampler {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkSamplerConstructor {
    readonly prototype: VkSampler
    new (): VkSampler
  }

  declare var VkSampler: VkSamplerConstructor

  /**
   * Opaque handle to a pipeline layout object
   */
  declare interface VkPipelineLayout {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkPipelineLayoutConstructor {
    readonly prototype: VkPipelineLayout
    new (): VkPipelineLayout
  }

  declare var VkPipelineLayout: VkPipelineLayoutConstructor

  /**
   * Opaque handle to a pipeline object
   */
  declare interface VkPipeline {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkPipelineConstructor {
    readonly prototype: VkPipeline
    new (): VkPipeline
  }

  declare var VkPipeline: VkPipelineConstructor

  /**
   * Opaque handle to a shader module object
   */
  declare interface VkShaderModule {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkShaderModuleConstructor {
    readonly prototype: VkShaderModule
    new (): VkShaderModule
  }

  declare var VkShaderModule: VkShaderModuleConstructor

  /**
   * Opaque handle to an image view object
   */
  declare interface VkImageView {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkImageViewConstructor {
    readonly prototype: VkImageView
    new (): VkImageView
  }

  declare var VkImageView: VkImageViewConstructor

  /**
   * Opaque handle to an image object
   */
  declare interface VkImage {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkImageConstructor {
    readonly prototype: VkImage
    new (): VkImage
  }

  declare var VkImage: VkImageConstructor

  /**
   * Opaque handle to a buffer view object
   */
  declare interface VkBufferView {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkBufferViewConstructor {
    readonly prototype: VkBufferView
    new (): VkBufferView
  }

  declare var VkBufferView: VkBufferViewConstructor

  /**
   * Opaque handle to a buffer object
   */
  declare interface VkBuffer {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkBufferConstructor {
    readonly prototype: VkBuffer
    new (): VkBuffer
  }

  declare var VkBuffer: VkBufferConstructor

  /**
   * Opaque handle to a command pool object
   */
  declare interface VkCommandPool {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkCommandPoolConstructor {
    readonly prototype: VkCommandPool
    new (): VkCommandPool
  }

  declare var VkCommandPool: VkCommandPoolConstructor

  /**
   * Opaque handle to a device memory object
   */
  declare interface VkDeviceMemory {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDeviceMemoryConstructor {
    readonly prototype: VkDeviceMemory
    new (): VkDeviceMemory
  }

  declare var VkDeviceMemory: VkDeviceMemoryConstructor

  /**
   * Opaque handle to a command buffer object
   */
  declare interface VkCommandBuffer {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkCommandBufferConstructor {
    readonly prototype: VkCommandBuffer
    new (): VkCommandBuffer
  }

  declare var VkCommandBuffer: VkCommandBufferConstructor

  /**
   * Opaque handle to a queue object
   */
  declare interface VkQueue {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkQueueConstructor {
    readonly prototype: VkQueue
    new (): VkQueue
  }

  declare var VkQueue: VkQueueConstructor

  /**
   * Opaque handle to a device object
   */
  declare interface VkDevice {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkDeviceConstructor {
    readonly prototype: VkDevice
    new (): VkDevice
  }

  declare var VkDevice: VkDeviceConstructor

  /**
   * Opaque handle to a physical device object
   */
  declare interface VkPhysicalDevice {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkPhysicalDeviceConstructor {
    readonly prototype: VkPhysicalDevice
    new (): VkPhysicalDevice
  }

  declare var VkPhysicalDevice: VkPhysicalDeviceConstructor

  /**
   * Opaque handle to an instance object
   */
  declare interface VkInstance {
    /**
     * Memory reference to the original vulkan handle.
     */
    address: bigint
  }

  declare interface VkInstanceConstructor {
    readonly prototype: VkInstance
    new (): VkInstance
  }

  declare var VkInstance: VkInstanceConstructor

  /**
   * A union describing a pipeline executable statistic
   */
  interface VkPipelineExecutableStatisticValueKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the 32-bit boolean value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR'.
     */
    readonly b32: boolean

    /**
     * is the signed 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR'.
     */
    readonly i64: bigint | number

    /**
     * is the unsigned 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR'.
     */
    readonly u64: bigint | number

    /**
     * is the 64-bit floating-point value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR'.
     */
    readonly f64: bigint | number
  }

  declare interface VkPipelineExecutableStatisticValueKHRInitializer {
    /**
     * is the 32-bit boolean value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR'.
     */
    readonly b32?: boolean

    /**
     * is the signed 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR'.
     */
    readonly i64?: bigint | number

    /**
     * is the unsigned 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR'.
     */
    readonly u64?: bigint | number

    /**
     * is the 64-bit floating-point value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR'.
     */
    readonly f64?: bigint | number
  }

  declare interface VkPipelineExecutableStatisticValueKHRConstructor {
    readonly prototype: VkPipelineExecutableStatisticValueKHR
    new (
      param?: VkPipelineExecutableStatisticValueKHRInitializer | null
    ): VkPipelineExecutableStatisticValueKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineExecutableStatisticValueKHR: VkPipelineExecutableStatisticValueKHRConstructor

  /**
   * Values returned for the parameters
   */
  interface VkPerformanceValueDataINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    value32: number

    /**
     *
     */
    value64: bigint | number

    /**
     *
     */
    valueFloat: number

    /**
     *
     */
    valueBool: boolean

    /**
     *
     */
    valueString: string | null
  }

  declare interface VkPerformanceValueDataINTELInitializer {
    /**
     *
     */
    value32?: number

    /**
     *
     */
    value64?: bigint | number

    /**
     *
     */
    valueFloat?: number

    /**
     *
     */
    valueBool?: boolean

    /**
     *
     */
    valueString?: string | null
  }

  declare interface VkPerformanceValueDataINTELConstructor {
    readonly prototype: VkPerformanceValueDataINTEL
    new (
      param?: VkPerformanceValueDataINTELInitializer | null
    ): VkPerformanceValueDataINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPerformanceValueDataINTEL: VkPerformanceValueDataINTELConstructor

  /**
   * Structure specifying a clear value
   */
  interface VkClearValue {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * specifies the color image clear values to use when clearing a color image or attachment.
     */
    color: VkClearColorValue | null

    /**
     * specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.
     */
    depthStencil: VkClearDepthStencilValue | null
  }

  declare interface VkClearValueInitializer {
    /**
     * specifies the color image clear values to use when clearing a color image or attachment.
     */
    color?: VkClearColorValue | null

    /**
     * specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.
     */
    depthStencil?: VkClearDepthStencilValue | null
  }

  declare interface VkClearValueConstructor {
    readonly prototype: VkClearValue
    new (param?: VkClearValueInitializer | null): VkClearValue

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkClearValue: VkClearValueConstructor

  /**
   * Structure specifying a clear color value
   */
  interface VkClearColorValue {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * are the color clear values when the format of the image or attachment is one of the formats in the <<formats-numericformat>> table other than signed integer ('SINT') or unsigned integer ('UINT'). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.
     */
    float32: number[] | null

    /**
     * are the color clear values when the format of the image or attachment is signed integer ('SINT'). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is 'undefined'.
     */
    int32: number[] | null

    /**
     * are the color clear values when the format of the image or attachment is unsigned integer ('UINT'). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.
     */
    uint32: number[] | null
  }

  declare interface VkClearColorValueInitializer {
    /**
     * are the color clear values when the format of the image or attachment is one of the formats in the <<formats-numericformat>> table other than signed integer ('SINT') or unsigned integer ('UINT'). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.
     */
    float32?: number[] | null

    /**
     * are the color clear values when the format of the image or attachment is signed integer ('SINT'). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is 'undefined'.
     */
    int32?: number[] | null

    /**
     * are the color clear values when the format of the image or attachment is unsigned integer ('UINT'). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.
     */
    uint32?: number[] | null
  }

  declare interface VkClearColorValueConstructor {
    readonly prototype: VkClearColorValue
    new (param?: VkClearColorValueInitializer | null): VkClearColorValue

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkClearColorValue: VkClearColorValueConstructor

  /**
   * Structure describing whether device coherent memory can be supported by an implementation
   */
  interface VkPhysicalDeviceCoherentMemoryFeaturesAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports <<VkMemoryPropertyFlagBits,device coherent memory>>.
     */
    deviceCoherentMemory: boolean
  }

  declare interface VkPhysicalDeviceCoherentMemoryFeaturesAMDInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports <<VkMemoryPropertyFlagBits,device coherent memory>>.
     */
    deviceCoherentMemory?: boolean
  }

  declare interface VkPhysicalDeviceCoherentMemoryFeaturesAMDConstructor {
    readonly prototype: VkPhysicalDeviceCoherentMemoryFeaturesAMD
    new (
      param?: VkPhysicalDeviceCoherentMemoryFeaturesAMDInitializer | null
    ): VkPhysicalDeviceCoherentMemoryFeaturesAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceCoherentMemoryFeaturesAMD: VkPhysicalDeviceCoherentMemoryFeaturesAMDConstructor

  /**
   * Structure used to pass compilation control flags to a pipeline
   */
  interface VkPipelineCompilerControlCreateInfoAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkPipelineCompilerControlFlagBitsAMD' affecting how the pipeline will be compiled.
     */
    compilerControlFlags: VkPipelineCompilerControlFlagBitsAMD
  }

  declare interface VkPipelineCompilerControlCreateInfoAMDInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkPipelineCompilerControlFlagBitsAMD' affecting how the pipeline will be compiled.
     */
    compilerControlFlags?: VkPipelineCompilerControlFlagBitsAMD
  }

  declare interface VkPipelineCompilerControlCreateInfoAMDConstructor {
    readonly prototype: VkPipelineCompilerControlCreateInfoAMD
    new (
      param?: VkPipelineCompilerControlCreateInfoAMDInitializer | null
    ): VkPipelineCompilerControlCreateInfoAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCompilerControlCreateInfoAMD: VkPipelineCompilerControlCreateInfoAMDConstructor

  /**
   * Structure specifying parameters of a newly created pipeline line rasterization state
   */
  interface VkPipelineRasterizationLineStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkLineRasterizationModeEXT' value selecting the style of line rasterization.
     */
    lineRasterizationMode: VkLineRasterizationModeEXT

    /**
     * enables <<primsrast-lines-stipple, stippled line rasterization>>.
     */
    stippledLineEnable: boolean

    /**
     * is the repeat factor used in stippled line rasterization.
     */
    lineStippleFactor: number

    /**
     * is the bit pattern used in stippled line rasterization.
     */
    lineStipplePattern: number
  }

  declare interface VkPipelineRasterizationLineStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkLineRasterizationModeEXT' value selecting the style of line rasterization.
     */
    lineRasterizationMode?: VkLineRasterizationModeEXT

    /**
     * enables <<primsrast-lines-stipple, stippled line rasterization>>.
     */
    stippledLineEnable?: boolean

    /**
     * is the repeat factor used in stippled line rasterization.
     */
    lineStippleFactor?: number

    /**
     * is the bit pattern used in stippled line rasterization.
     */
    lineStipplePattern?: number
  }

  declare interface VkPipelineRasterizationLineStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineRasterizationLineStateCreateInfoEXT
    new (
      param?: VkPipelineRasterizationLineStateCreateInfoEXTInitializer | null
    ): VkPipelineRasterizationLineStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRasterizationLineStateCreateInfoEXT: VkPipelineRasterizationLineStateCreateInfoEXTConstructor

  /**
   * Structure describing line rasterization properties supported by an implementation
   */
  interface VkPhysicalDeviceLineRasterizationPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~# when rasterizing <<primsrast-lines,line segments>>.
     */
    readonly lineSubPixelPrecisionBits: number
  }

  declare interface VkPhysicalDeviceLineRasterizationPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~# when rasterizing <<primsrast-lines,line segments>>.
     */
    readonly lineSubPixelPrecisionBits?: number
  }

  declare interface VkPhysicalDeviceLineRasterizationPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceLineRasterizationPropertiesEXT
    new (
      param?: VkPhysicalDeviceLineRasterizationPropertiesEXTInitializer | null
    ): VkPhysicalDeviceLineRasterizationPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceLineRasterizationPropertiesEXT: VkPhysicalDeviceLineRasterizationPropertiesEXTConstructor

  /**
   * Structure describing the line rasterization features that can be supported by an implementation
   */
  interface VkPhysicalDeviceLineRasterizationFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports <<primsrast-lines,rectangular line rasterization>>.
     */
    rectangularLines: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-bresenham,Bresenham-style line rasterization>>.
     */
    bresenhamLines: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-smooth,smooth line rasterization>>.
     */
    smoothLines: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT' lines, or with 'VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT' lines if 'VkPhysicalDeviceLimits'::'strictLines' is 'VK_TRUE'.
     */
    stippledRectangularLines: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT' lines.
     */
    stippledBresenhamLines: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT' lines.
     */
    stippledSmoothLines: boolean
  }

  declare interface VkPhysicalDeviceLineRasterizationFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports <<primsrast-lines,rectangular line rasterization>>.
     */
    rectangularLines?: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-bresenham,Bresenham-style line rasterization>>.
     */
    bresenhamLines?: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-smooth,smooth line rasterization>>.
     */
    smoothLines?: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT' lines, or with 'VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT' lines if 'VkPhysicalDeviceLimits'::'strictLines' is 'VK_TRUE'.
     */
    stippledRectangularLines?: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT' lines.
     */
    stippledBresenhamLines?: boolean

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT' lines.
     */
    stippledSmoothLines?: boolean
  }

  declare interface VkPhysicalDeviceLineRasterizationFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceLineRasterizationFeaturesEXT
    new (
      param?: VkPhysicalDeviceLineRasterizationFeaturesEXTInitializer | null
    ): VkPhysicalDeviceLineRasterizationFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceLineRasterizationFeaturesEXT: VkPhysicalDeviceLineRasterizationFeaturesEXTConstructor

  /**
   * Structure specifying the required subgroup size of a newly created pipeline shader stage
   */
  interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a number value that specifies the required subgroup size for the newly created pipeline shader stage.
     */
    readonly requiredSubgroupSize: number
  }

  declare interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a number value that specifies the required subgroup size for the newly created pipeline shader stage.
     */
    readonly requiredSubgroupSize?: number
  }

  declare interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTConstructor {
    readonly prototype: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT
    new (
      param?: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInitializer | null
    ): VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTConstructor

  /**
   * Structure describing the control subgroup size properties of an implementation
   */
  interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the minimum subgroup size supported by this device. 'minSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'minSubgroupSize' is a power-of-two. 'minSubgroupSize' is less than or equal to 'maxSubgroupSize'. 'minSubgroupSize' is less than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly minSubgroupSize: number

    /**
     * is the maximum subgroup size supported by this device. 'maxSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'maxSubgroupSize' is a power-of-two. 'maxSubgroupSize' is greater than or equal to 'minSubgroupSize'. 'maxSubgroupSize' is greater than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly maxSubgroupSize: number

    /**
     * is the maximum number of subgroups supported by the implementation within a workgroup.
     */
    readonly maxComputeWorkgroupSubgroups: number

    /**
     * is a bitfield of what shader stages support having a required subgroup size specified.
     */
    readonly requiredSubgroupSizeStages: VkShaderStageFlagBits
  }

  declare interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the minimum subgroup size supported by this device. 'minSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'minSubgroupSize' is a power-of-two. 'minSubgroupSize' is less than or equal to 'maxSubgroupSize'. 'minSubgroupSize' is less than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly minSubgroupSize?: number

    /**
     * is the maximum subgroup size supported by this device. 'maxSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'maxSubgroupSize' is a power-of-two. 'maxSubgroupSize' is greater than or equal to 'minSubgroupSize'. 'maxSubgroupSize' is greater than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly maxSubgroupSize?: number

    /**
     * is the maximum number of subgroups supported by the implementation within a workgroup.
     */
    readonly maxComputeWorkgroupSubgroups?: number

    /**
     * is a bitfield of what shader stages support having a required subgroup size specified.
     */
    readonly requiredSubgroupSizeStages?: VkShaderStageFlagBits
  }

  declare interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceSubgroupSizeControlPropertiesEXT
    new (
      param?: VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInitializer | null
    ): VkPhysicalDeviceSubgroupSizeControlPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSubgroupSizeControlPropertiesEXT: VkPhysicalDeviceSubgroupSizeControlPropertiesEXTConstructor

  /**
   * Structure describing the subgroup size control features that can be supported by an implementation
   */
  interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports controlling shader subgroup sizes via the 'VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT' flag and the 'VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT' structure.
     */
    subgroupSizeControl: boolean

    /**
     * indicates whether the implementation supports requiring full subgroups in compute shaders via the 'VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT' flag.
     */
    computeFullSubgroups: boolean
  }

  declare interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports controlling shader subgroup sizes via the 'VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT' flag and the 'VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT' structure.
     */
    subgroupSizeControl?: boolean

    /**
     * indicates whether the implementation supports requiring full subgroups in compute shaders via the 'VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT' flag.
     */
    computeFullSubgroups?: boolean
  }

  declare interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
    new (
      param?: VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInitializer | null
    ): VkPhysicalDeviceSubgroupSizeControlFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSubgroupSizeControlFeaturesEXT: VkPhysicalDeviceSubgroupSizeControlFeaturesEXTConstructor

  /**
   * Structure describing the texel buffer alignment requirements supported by an implementation
   */
  interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a byte alignment that is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetAlignmentBytes: bigint | number

    /**
     * indicates whether single texel alignment is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetSingleTexelAlignment: boolean

    /**
     * is a byte alignment that is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetAlignmentBytes: bigint | number

    /**
     * indicates whether single texel alignment is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetSingleTexelAlignment: boolean
  }

  declare interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a byte alignment that is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetAlignmentBytes?: bigint | number

    /**
     * indicates whether single texel alignment is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetSingleTexelAlignment?: boolean

    /**
     * is a byte alignment that is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetAlignmentBytes?: bigint | number

    /**
     * indicates whether single texel alignment is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetSingleTexelAlignment?: boolean
  }

  declare interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
    new (
      param?: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInitializer | null
    ): VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTConstructor

  /**
   * Structure describing the texel buffer alignment features that can be supported by an implementation
   */
  interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation uses more specific alignment requirements advertised in 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT' rather than 'VkPhysicalDeviceLimits'::'minTexelBufferOffsetAlignment'.
     */
    texelBufferAlignment: boolean
  }

  declare interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation uses more specific alignment requirements advertised in 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT' rather than 'VkPhysicalDeviceLimits'::'minTexelBufferOffsetAlignment'.
     */
    texelBufferAlignment?: boolean
  }

  declare interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
    new (
      param?: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInitializer | null
    ): VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTConstructor

  /**
   * Structure describing the shader demote to helper invocations features that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    shaderDemoteToHelperInvocation: boolean
  }

  declare interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    shaderDemoteToHelperInvocation?: boolean
  }

  declare interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
    new (
      param?: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInitializer | null
    ): VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTConstructor

  /**
   * Structure describing the textual form of a pipeline executable internal representation
   */
  interface VkPipelineExecutableInternalRepresentationKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    name: string | null

    /**
     *
     */
    description: string | null

    /**
     * specifies whether the returned data is text or opaque data. If 'isText' is 'VK_TRUE' then the data returned in 'pData' is text and is guaranteed to be a string.
     */
    isText: boolean

    /**
     * is a number related to the size, in bytes, of the internal representation data, as described below.
     */
    dataSize: bigint | number

    /**
     * is either <i>null</i> or a reference to an block of data into which the implementation will write the textual form of the internal representation.
     */
    pData: ArrayBuffer | null
  }

  declare interface VkPipelineExecutableInternalRepresentationKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    name?: string | null

    /**
     *
     */
    description?: string | null

    /**
     * specifies whether the returned data is text or opaque data. If 'isText' is 'VK_TRUE' then the data returned in 'pData' is text and is guaranteed to be a string.
     */
    isText?: boolean

    /**
     * is a number related to the size, in bytes, of the internal representation data, as described below.
     */
    dataSize?: bigint | number

    /**
     * is either <i>null</i> or a reference to an block of data into which the implementation will write the textual form of the internal representation.
     */
    pData?: ArrayBuffer | null
  }

  declare interface VkPipelineExecutableInternalRepresentationKHRConstructor {
    readonly prototype: VkPipelineExecutableInternalRepresentationKHR
    new (
      param?: VkPipelineExecutableInternalRepresentationKHRInitializer | null
    ): VkPipelineExecutableInternalRepresentationKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineExecutableInternalRepresentationKHR: VkPipelineExecutableInternalRepresentationKHRConstructor

  /**
   * Structure describing a compile-time pipeline executable statistic
   */
  interface VkPipelineExecutableStatisticKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     *
     */
    readonly name: string | null

    /**
     *
     */
    readonly description: string | null

    /**
     * is a 'VkPipelineExecutableStatisticFormatKHR' value specifying the format of the data found in 'value'.
     */
    readonly format: VkPipelineExecutableStatisticFormatKHR

    /**
     * is the value of this statistic.
     */
    readonly value: VkPipelineExecutableStatisticValueKHR | null
  }

  declare interface VkPipelineExecutableStatisticKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     *
     */
    readonly name?: string | null

    /**
     *
     */
    readonly description?: string | null

    /**
     * is a 'VkPipelineExecutableStatisticFormatKHR' value specifying the format of the data found in 'value'.
     */
    readonly format?: VkPipelineExecutableStatisticFormatKHR

    /**
     * is the value of this statistic.
     */
    readonly value?: VkPipelineExecutableStatisticValueKHR | null
  }

  declare interface VkPipelineExecutableStatisticKHRConstructor {
    readonly prototype: VkPipelineExecutableStatisticKHR
    new (
      param?: VkPipelineExecutableStatisticKHRInitializer | null
    ): VkPipelineExecutableStatisticKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineExecutableStatisticKHR: VkPipelineExecutableStatisticKHRConstructor

  /**
   * Structure describing a pipeline executable to query for associated statistics or internal representations
   */
  interface VkPipelineExecutableInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the pipeline to query.
     */
    pipeline: VkPipeline | null

    /**
     * is the index of the executable to query in the array of executable properties returned by 'vkGetPipelineExecutablePropertiesKHR'.
     */
    executableIndex: number
  }

  declare interface VkPipelineExecutableInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the pipeline to query.
     */
    pipeline?: VkPipeline | null

    /**
     * is the index of the executable to query in the array of executable properties returned by 'vkGetPipelineExecutablePropertiesKHR'.
     */
    executableIndex?: number
  }

  declare interface VkPipelineExecutableInfoKHRConstructor {
    readonly prototype: VkPipelineExecutableInfoKHR
    new (
      param?: VkPipelineExecutableInfoKHRInitializer | null
    ): VkPipelineExecutableInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineExecutableInfoKHR: VkPipelineExecutableInfoKHRConstructor

  /**
   * Structure describing a pipeline executable
   */
  interface VkPipelineExecutablePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask of 'VkShaderStageFlagBits' indicating which shader stages (if any) were principally used as inputs to compile this pipeline executable.
     */
    readonly stages: VkShaderStageFlagBits

    /**
     *
     */
    readonly name: string | null

    /**
     *
     */
    readonly description: string | null

    /**
     * is the subgroup size with which this executable is dispatched.
     */
    readonly subgroupSize: number
  }

  declare interface VkPipelineExecutablePropertiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask of 'VkShaderStageFlagBits' indicating which shader stages (if any) were principally used as inputs to compile this pipeline executable.
     */
    readonly stages?: VkShaderStageFlagBits

    /**
     *
     */
    readonly name?: string | null

    /**
     *
     */
    readonly description?: string | null

    /**
     * is the subgroup size with which this executable is dispatched.
     */
    readonly subgroupSize?: number
  }

  declare interface VkPipelineExecutablePropertiesKHRConstructor {
    readonly prototype: VkPipelineExecutablePropertiesKHR
    new (
      param?: VkPipelineExecutablePropertiesKHRInitializer | null
    ): VkPipelineExecutablePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineExecutablePropertiesKHR: VkPipelineExecutablePropertiesKHRConstructor

  /**
   * Structure describing a pipeline
   */
  interface VkPipelineInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkPipeline' handle.
     */
    pipeline: VkPipeline | null
  }

  declare interface VkPipelineInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkPipeline' handle.
     */
    pipeline?: VkPipeline | null
  }

  declare interface VkPipelineInfoKHRConstructor {
    readonly prototype: VkPipelineInfoKHR
    new (param?: VkPipelineInfoKHRInitializer | null): VkPipelineInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineInfoKHR: VkPipelineInfoKHRConstructor

  /**
   * Structure describing whether pipeline executable properties are available
   */
  interface VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    pipelineExecutableInfo: boolean
  }

  declare interface VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    pipelineExecutableInfo?: boolean
  }

  declare interface VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
    new (
      param?: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRInitializer | null
    ): VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRConstructor

  /**
   * Structure describing fragment shader interlock features that can be supported by an implementation
   */
  interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    fragmentShaderSampleInterlock: boolean

    /**
     *
     */
    fragmentShaderPixelInterlock: boolean

    /**
     *
     */
    fragmentShaderShadingRateInterlock: boolean
  }

  declare interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    fragmentShaderSampleInterlock?: boolean

    /**
     *
     */
    fragmentShaderPixelInterlock?: boolean

    /**
     *
     */
    fragmentShaderShadingRateInterlock?: boolean
  }

  declare interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
    new (
      param?: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInitializer | null
    ): VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTConstructor

  /**
   * Structure describing the shader SM Builtins features that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports the SPIR-V 'ShaderSMBuiltinsNV' capability.
     */
    shaderSMBuiltins: boolean
  }

  declare interface VkPhysicalDeviceShaderSMBuiltinsFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports the SPIR-V 'ShaderSMBuiltinsNV' capability.
     */
    shaderSMBuiltins?: boolean
  }

  declare interface VkPhysicalDeviceShaderSMBuiltinsFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
    new (
      param?: VkPhysicalDeviceShaderSMBuiltinsFeaturesNVInitializer | null
    ): VkPhysicalDeviceShaderSMBuiltinsFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderSMBuiltinsFeaturesNV: VkPhysicalDeviceShaderSMBuiltinsFeaturesNVConstructor

  /**
   * Structure describing shader SM Builtins properties supported by an implementation
   */
  interface VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the number of SMs on the device.
     */
    readonly shaderSMCount: number

    /**
     * is the maximum number of simultaneously executing warps on an SM.
     */
    readonly shaderWarpsPerSM: number
  }

  declare interface VkPhysicalDeviceShaderSMBuiltinsPropertiesNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the number of SMs on the device.
     */
    readonly shaderSMCount?: number

    /**
     * is the maximum number of simultaneously executing warps on an SM.
     */
    readonly shaderWarpsPerSM?: number
  }

  declare interface VkPhysicalDeviceShaderSMBuiltinsPropertiesNVConstructor {
    readonly prototype: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
    new (
      param?: VkPhysicalDeviceShaderSMBuiltinsPropertiesNVInitializer | null
    ): VkPhysicalDeviceShaderSMBuiltinsPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderSMBuiltinsPropertiesNV: VkPhysicalDeviceShaderSMBuiltinsPropertiesNVConstructor

  /**
   * Structure describing whether uint8 index type can be used
   */
  interface VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that 'VK_INDEX_TYPE_UINT8_EXT' can be used with 'vkCmdBindIndexBuffer'.
     */
    indexTypeUint8: boolean
  }

  declare interface VkPhysicalDeviceIndexTypeUint8FeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that 'VK_INDEX_TYPE_UINT8_EXT' can be used with 'vkCmdBindIndexBuffer'.
     */
    indexTypeUint8?: boolean
  }

  declare interface VkPhysicalDeviceIndexTypeUint8FeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceIndexTypeUint8FeaturesEXT
    new (
      param?: VkPhysicalDeviceIndexTypeUint8FeaturesEXTInitializer | null
    ): VkPhysicalDeviceIndexTypeUint8FeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceIndexTypeUint8FeaturesEXT: VkPhysicalDeviceIndexTypeUint8FeaturesEXTConstructor

  /**
   * Structure describing features supported by VK_KHR_shader_clock
   */
  interface VkPhysicalDeviceShaderClockFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * indicates whether shaders 'can' support 'Subgroup' scoped clock reads.
     */
    shaderSubgroupClock: boolean

    /**
     * indicates whether shaders 'can' support 'Device' scoped clock reads.
     */
    shaderDeviceClock: boolean
  }

  declare interface VkPhysicalDeviceShaderClockFeaturesKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * indicates whether shaders 'can' support 'Subgroup' scoped clock reads.
     */
    shaderSubgroupClock?: boolean

    /**
     * indicates whether shaders 'can' support 'Device' scoped clock reads.
     */
    shaderDeviceClock?: boolean
  }

  declare interface VkPhysicalDeviceShaderClockFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceShaderClockFeaturesKHR
    new (
      param?: VkPhysicalDeviceShaderClockFeaturesKHRInitializer | null
    ): VkPhysicalDeviceShaderClockFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderClockFeaturesKHR: VkPhysicalDeviceShaderClockFeaturesKHRConstructor

  /**
   * Acquire a configuration to capture performance data
   */
  interface VkPerformanceConfigurationAcquireInfoINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is one of the 'VkPerformanceConfigurationTypeINTEL' type of performance configuration that will be acquired.
     */
    type: VkPerformanceConfigurationTypeINTEL
  }

  declare interface VkPerformanceConfigurationAcquireInfoINTELInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is one of the 'VkPerformanceConfigurationTypeINTEL' type of performance configuration that will be acquired.
     */
    type?: VkPerformanceConfigurationTypeINTEL
  }

  declare interface VkPerformanceConfigurationAcquireInfoINTELConstructor {
    readonly prototype: VkPerformanceConfigurationAcquireInfoINTEL
    new (
      param?: VkPerformanceConfigurationAcquireInfoINTELInitializer | null
    ): VkPerformanceConfigurationAcquireInfoINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPerformanceConfigurationAcquireInfoINTEL: VkPerformanceConfigurationAcquireInfoINTELConstructor

  /**
   * Performance override info
   */
  interface VkPerformanceOverrideInfoINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * is the particular 'VkPerformanceOverrideTypeINTEL' to set.
     */
    type: VkPerformanceOverrideTypeINTEL

    /**
     * defines whether the override is enabled.
     */
    enable: boolean

    /**
     * is a potential required parameter for the override.
     */
    parameter: bigint | number
  }

  declare interface VkPerformanceOverrideInfoINTELInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * is the particular 'VkPerformanceOverrideTypeINTEL' to set.
     */
    type?: VkPerformanceOverrideTypeINTEL

    /**
     * defines whether the override is enabled.
     */
    enable?: boolean

    /**
     * is a potential required parameter for the override.
     */
    parameter?: bigint | number
  }

  declare interface VkPerformanceOverrideInfoINTELConstructor {
    readonly prototype: VkPerformanceOverrideInfoINTEL
    new (
      param?: VkPerformanceOverrideInfoINTELInitializer | null
    ): VkPerformanceOverrideInfoINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPerformanceOverrideInfoINTEL: VkPerformanceOverrideInfoINTELConstructor

  /**
   * Structure specifying stream performance markers
   */
  interface VkPerformanceStreamMarkerInfoINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the marker value that will be recorded into the reports consumed by an external application.
     */
    marker: number
  }

  declare interface VkPerformanceStreamMarkerInfoINTELInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the marker value that will be recorded into the reports consumed by an external application.
     */
    marker?: number
  }

  declare interface VkPerformanceStreamMarkerInfoINTELConstructor {
    readonly prototype: VkPerformanceStreamMarkerInfoINTEL
    new (
      param?: VkPerformanceStreamMarkerInfoINTELInitializer | null
    ): VkPerformanceStreamMarkerInfoINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPerformanceStreamMarkerInfoINTEL: VkPerformanceStreamMarkerInfoINTELConstructor

  /**
   * Structure specifying performance markers
   */
  interface VkPerformanceMarkerInfoINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the marker value that will be recorded into the opaque query results.
     */
    marker: bigint | number
  }

  declare interface VkPerformanceMarkerInfoINTELInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the marker value that will be recorded into the opaque query results.
     */
    marker?: bigint | number
  }

  declare interface VkPerformanceMarkerInfoINTELConstructor {
    readonly prototype: VkPerformanceMarkerInfoINTEL
    new (
      param?: VkPerformanceMarkerInfoINTELInitializer | null
    ): VkPerformanceMarkerInfoINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPerformanceMarkerInfoINTEL: VkPerformanceMarkerInfoINTELConstructor

  /**
   * Structure specifying parameters to create a pool of performance queries
   */
  interface VkQueryPoolCreateInfoINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * describe how performance queries should be captured.
     */
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL
  }

  declare interface VkQueryPoolCreateInfoINTELInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * describe how performance queries should be captured.
     */
    performanceCountersSampling?: VkQueryPoolSamplingModeINTEL
  }

  declare interface VkQueryPoolCreateInfoINTELConstructor {
    readonly prototype: VkQueryPoolCreateInfoINTEL
    new (
      param?: VkQueryPoolCreateInfoINTELInitializer | null
    ): VkQueryPoolCreateInfoINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkQueryPoolCreateInfoINTEL: VkQueryPoolCreateInfoINTELConstructor

  /**
   * Structure specifying parameters of initialize of the device
   */
  interface VkInitializePerformanceApiInfoINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference for application data.
     */
    pUserData: ArrayBuffer | null
  }

  declare interface VkInitializePerformanceApiInfoINTELInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference for application data.
     */
    pUserData?: ArrayBuffer | null
  }

  declare interface VkInitializePerformanceApiInfoINTELConstructor {
    readonly prototype: VkInitializePerformanceApiInfoINTEL
    new (
      param?: VkInitializePerformanceApiInfoINTELInitializer | null
    ): VkInitializePerformanceApiInfoINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkInitializePerformanceApiInfoINTEL: VkInitializePerformanceApiInfoINTELConstructor

  /**
   * Container for value and types of parameters that can be queried
   */
  interface VkPerformanceValueINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkPerformanceValueTypeINTEL' value specifying the type of the returned data.
     */
    type: VkPerformanceValueTypeINTEL

    /**
     * is a 'VkPerformanceValueDataINTEL' union specifying the value of the returned data.
     */
    data: VkPerformanceValueDataINTEL | null
  }

  declare interface VkPerformanceValueINTELInitializer {
    /**
     * is a 'VkPerformanceValueTypeINTEL' value specifying the type of the returned data.
     */
    type?: VkPerformanceValueTypeINTEL

    /**
     * is a 'VkPerformanceValueDataINTEL' union specifying the value of the returned data.
     */
    data?: VkPerformanceValueDataINTEL | null
  }

  declare interface VkPerformanceValueINTELConstructor {
    readonly prototype: VkPerformanceValueINTEL
    new (
      param?: VkPerformanceValueINTELInitializer | null
    ): VkPerformanceValueINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPerformanceValueINTEL: VkPerformanceValueINTELConstructor

  /**
   * Structure describing shader integer functions that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports the 'ShaderIntegerFunctions2INTEL' SPIR-V capability.
     */
    shaderIntegerFunctions2: boolean
  }

  declare interface VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports the 'ShaderIntegerFunctions2INTEL' SPIR-V capability.
     */
    shaderIntegerFunctions2?: boolean
  }

  declare interface VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELConstructor {
    readonly prototype: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
    new (
      param?: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELInitializer | null
    ): VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELConstructor

  /**
   * Structure specifying a supported sample count combination
   */
  interface VkFramebufferMixedSamplesCombinationNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a 'VkCoverageReductionModeNV' value specifying the coverage reduction mode.
     */
    readonly coverageReductionMode: VkCoverageReductionModeNV

    /**
     * specifies the number of rasterization samples in the supported combination.
     */
    readonly rasterizationSamples: VkSampleCountFlagBits

    /**
     * specifies the number of samples in the depth stencil attachment in the supported combination. A value of 0 indicates the combination does not have a depth stencil attachment.
     */
    readonly depthStencilSamples: VkSampleCountFlagBits

    /**
     * specifies the number of color samples in a color attachment in the supported combination. A value of 0 indicates the combination does not have a color attachment.
     */
    readonly colorSamples: VkSampleCountFlagBits
  }

  declare interface VkFramebufferMixedSamplesCombinationNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a 'VkCoverageReductionModeNV' value specifying the coverage reduction mode.
     */
    readonly coverageReductionMode?: VkCoverageReductionModeNV

    /**
     * specifies the number of rasterization samples in the supported combination.
     */
    readonly rasterizationSamples?: VkSampleCountFlagBits

    /**
     * specifies the number of samples in the depth stencil attachment in the supported combination. A value of 0 indicates the combination does not have a depth stencil attachment.
     */
    readonly depthStencilSamples?: VkSampleCountFlagBits

    /**
     * specifies the number of color samples in a color attachment in the supported combination. A value of 0 indicates the combination does not have a color attachment.
     */
    readonly colorSamples?: VkSampleCountFlagBits
  }

  declare interface VkFramebufferMixedSamplesCombinationNVConstructor {
    readonly prototype: VkFramebufferMixedSamplesCombinationNV
    new (
      param?: VkFramebufferMixedSamplesCombinationNVInitializer | null
    ): VkFramebufferMixedSamplesCombinationNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFramebufferMixedSamplesCombinationNV: VkFramebufferMixedSamplesCombinationNVConstructor

  /**
   * Structure specifying parameters controlling coverage reduction
   */
  interface VkPipelineCoverageReductionStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is a 'VkCoverageReductionModeNV' value controlling how the _color sample mask_ is generated from the coverage mask.
     */
    coverageReductionMode: VkCoverageReductionModeNV
  }

  declare interface VkPipelineCoverageReductionStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is a 'VkCoverageReductionModeNV' value controlling how the _color sample mask_ is generated from the coverage mask.
     */
    coverageReductionMode?: VkCoverageReductionModeNV
  }

  declare interface VkPipelineCoverageReductionStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineCoverageReductionStateCreateInfoNV
    new (
      param?: VkPipelineCoverageReductionStateCreateInfoNVInitializer | null
    ): VkPipelineCoverageReductionStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCoverageReductionStateCreateInfoNV: VkPipelineCoverageReductionStateCreateInfoNVConstructor

  /**
   * Structure describing the coverage reduction mode features that can be supported by an implementation
   */
  interface VkPhysicalDeviceCoverageReductionModeFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports coverage reduction modes. See <<fragops-coverage-reduction, Coverage Reduction>>.
     */
    coverageReductionMode: boolean
  }

  declare interface VkPhysicalDeviceCoverageReductionModeFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports coverage reduction modes. See <<fragops-coverage-reduction, Coverage Reduction>>.
     */
    coverageReductionMode?: boolean
  }

  declare interface VkPhysicalDeviceCoverageReductionModeFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceCoverageReductionModeFeaturesNV
    new (
      param?: VkPhysicalDeviceCoverageReductionModeFeaturesNVInitializer | null
    ): VkPhysicalDeviceCoverageReductionModeFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceCoverageReductionModeFeaturesNV: VkPhysicalDeviceCoverageReductionModeFeaturesNVConstructor

  /**
   * Structure specifying parameters of a newly created headless surface object
   */
  interface VkHeadlessSurfaceCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number
  }

  declare interface VkHeadlessSurfaceCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number
  }

  declare interface VkHeadlessSurfaceCreateInfoEXTConstructor {
    readonly prototype: VkHeadlessSurfaceCreateInfoEXT
    new (
      param?: VkHeadlessSurfaceCreateInfoEXTInitializer | null
    ): VkHeadlessSurfaceCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkHeadlessSurfaceCreateInfoEXT: VkHeadlessSurfaceCreateInfoEXTConstructor

  /**
   * Structure describing full screen exclusive capabilities of a surface
   */
  interface VkSurfaceCapabilitiesFullScreenExclusiveEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    fullScreenExclusiveSupported: boolean
  }

  declare interface VkSurfaceCapabilitiesFullScreenExclusiveEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    fullScreenExclusiveSupported?: boolean
  }

  declare interface VkSurfaceCapabilitiesFullScreenExclusiveEXTConstructor {
    readonly prototype: VkSurfaceCapabilitiesFullScreenExclusiveEXT
    new (
      param?: VkSurfaceCapabilitiesFullScreenExclusiveEXTInitializer | null
    ): VkSurfaceCapabilitiesFullScreenExclusiveEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceCapabilitiesFullScreenExclusiveEXT: VkSurfaceCapabilitiesFullScreenExclusiveEXTConstructor

  /**
   * Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode
   */
  interface VkSurfaceFullScreenExclusiveWin32InfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the Win32 'HMONITOR' handle identifying the display to create the surface with.
     */
    hmonitor: null
  }

  declare interface VkSurfaceFullScreenExclusiveWin32InfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the Win32 'HMONITOR' handle identifying the display to create the surface with.
     */
    hmonitor?: null
  }

  declare interface VkSurfaceFullScreenExclusiveWin32InfoEXTConstructor {
    readonly prototype: VkSurfaceFullScreenExclusiveWin32InfoEXT
    new (
      param?: VkSurfaceFullScreenExclusiveWin32InfoEXTInitializer | null
    ): VkSurfaceFullScreenExclusiveWin32InfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceFullScreenExclusiveWin32InfoEXT: VkSurfaceFullScreenExclusiveWin32InfoEXTConstructor

  /**
   * Structure specifying the preferred full-screen transition behavior
   */
  interface VkSurfaceFullScreenExclusiveInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkFullScreenExclusiveEXT' value specifying the preferred full-screen transition behavior.
     */
    fullScreenExclusive: VkFullScreenExclusiveEXT
  }

  declare interface VkSurfaceFullScreenExclusiveInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkFullScreenExclusiveEXT' value specifying the preferred full-screen transition behavior.
     */
    fullScreenExclusive?: VkFullScreenExclusiveEXT
  }

  declare interface VkSurfaceFullScreenExclusiveInfoEXTConstructor {
    readonly prototype: VkSurfaceFullScreenExclusiveInfoEXT
    new (
      param?: VkSurfaceFullScreenExclusiveInfoEXTInitializer | null
    ): VkSurfaceFullScreenExclusiveInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceFullScreenExclusiveInfoEXT: VkSurfaceFullScreenExclusiveInfoEXTConstructor

  /**
   * Request for feedback about the creation of a pipeline
   */
  interface VkPipelineCreationFeedbackCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a 'VkPipelineCreationFeedbackEXT' structure.
     */
    pPipelineCreationFeedback: VkPipelineCreationFeedbackEXT | null

    /**
     * is the number of elements in 'pPipelineStageCreationFeedbacks'.
     */
    pipelineStageCreationFeedbackCount: number

    /**
     * is an array of 'pipelineStageCreationFeedbackCount' 'VkPipelineCreationFeedbackEXT' structures.
     */
    pPipelineStageCreationFeedbacks: VkPipelineCreationFeedbackEXT[] | null
  }

  declare interface VkPipelineCreationFeedbackCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a 'VkPipelineCreationFeedbackEXT' structure.
     */
    pPipelineCreationFeedback?: VkPipelineCreationFeedbackEXT | null

    /**
     * is the number of elements in 'pPipelineStageCreationFeedbacks'.
     */
    pipelineStageCreationFeedbackCount?: number

    /**
     * is an array of 'pipelineStageCreationFeedbackCount' 'VkPipelineCreationFeedbackEXT' structures.
     */
    pPipelineStageCreationFeedbacks?: VkPipelineCreationFeedbackEXT[] | null
  }

  declare interface VkPipelineCreationFeedbackCreateInfoEXTConstructor {
    readonly prototype: VkPipelineCreationFeedbackCreateInfoEXT
    new (
      param?: VkPipelineCreationFeedbackCreateInfoEXTInitializer | null
    ): VkPipelineCreationFeedbackCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCreationFeedbackCreateInfoEXT: VkPipelineCreationFeedbackCreateInfoEXTConstructor

  /**
   * Feedback about the creation of a pipeline or pipeline stage
   */
  interface VkPipelineCreationFeedbackEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkPipelineCreationFeedbackFlagBitsEXT' providing feedback about the creation of a pipeline or of a pipeline stage.
     */
    readonly flags: VkPipelineCreationFeedbackFlagBitsEXT

    /**
     * is the duration spent creating a pipeline or pipeline stage in nanoseconds.
     */
    readonly duration: bigint | number
  }

  declare interface VkPipelineCreationFeedbackEXTInitializer {
    /**
     * is a bitmask of 'VkPipelineCreationFeedbackFlagBitsEXT' providing feedback about the creation of a pipeline or of a pipeline stage.
     */
    readonly flags?: VkPipelineCreationFeedbackFlagBitsEXT

    /**
     * is the duration spent creating a pipeline or pipeline stage in nanoseconds.
     */
    readonly duration?: bigint | number
  }

  declare interface VkPipelineCreationFeedbackEXTConstructor {
    readonly prototype: VkPipelineCreationFeedbackEXT
    new (
      param?: VkPipelineCreationFeedbackEXTInitializer | null
    ): VkPipelineCreationFeedbackEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCreationFeedbackEXT: VkPipelineCreationFeedbackEXTConstructor

  /**
   * Structure specifying the image view for handle queries
   */
  interface VkImageViewHandleInfoNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the image view to query.
     */
    imageView: VkImageView | null

    /**
     * is the type of descriptor for which to query a handle.
     */
    descriptorType: VkDescriptorType

    /**
     * is the sampler to combine with the image view when generating the handle.
     */
    sampler: VkSampler | null
  }

  declare interface VkImageViewHandleInfoNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the image view to query.
     */
    imageView?: VkImageView | null

    /**
     * is the type of descriptor for which to query a handle.
     */
    descriptorType?: VkDescriptorType

    /**
     * is the sampler to combine with the image view when generating the handle.
     */
    sampler?: VkSampler | null
  }

  declare interface VkImageViewHandleInfoNVXConstructor {
    readonly prototype: VkImageViewHandleInfoNVX
    new (
      param?: VkImageViewHandleInfoNVXInitializer | null
    ): VkImageViewHandleInfoNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageViewHandleInfoNVX: VkImageViewHandleInfoNVXConstructor

  /**
   * Structure describing extended Y
   */
  interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports creating images with a format that requires <<formats-requiring-sampler-ycbcr-conversion, Y'C~B~C~R~ conversion>> and has multiple array layers.
     */
    ycbcrImageArrays: boolean
  }

  declare interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports creating images with a format that requires <<formats-requiring-sampler-ycbcr-conversion, Y'C~B~C~R~ conversion>> and has multiple array layers.
     */
    ycbcrImageArrays?: boolean
  }

  declare interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
    new (
      param?: VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInitializer | null
    ): VkPhysicalDeviceYcbcrImageArraysFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceYcbcrImageArraysFeaturesEXT: VkPhysicalDeviceYcbcrImageArraysFeaturesEXTConstructor

  /**
   * Structure specifying cooperative matrix properties
   */
  interface VkCooperativeMatrixPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    MSize: number

    /**
     *
     */
    NSize: number

    /**
     *
     */
    KSize: number

    /**
     *
     */
    AType: VkComponentTypeNV

    /**
     *
     */
    BType: VkComponentTypeNV

    /**
     *
     */
    CType: VkComponentTypeNV

    /**
     *
     */
    DType: VkComponentTypeNV

    /**
     *
     */
    scope: VkScopeNV
  }

  declare interface VkCooperativeMatrixPropertiesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    MSize?: number

    /**
     *
     */
    NSize?: number

    /**
     *
     */
    KSize?: number

    /**
     *
     */
    AType?: VkComponentTypeNV

    /**
     *
     */
    BType?: VkComponentTypeNV

    /**
     *
     */
    CType?: VkComponentTypeNV

    /**
     *
     */
    DType?: VkComponentTypeNV

    /**
     *
     */
    scope?: VkScopeNV
  }

  declare interface VkCooperativeMatrixPropertiesNVConstructor {
    readonly prototype: VkCooperativeMatrixPropertiesNV
    new (
      param?: VkCooperativeMatrixPropertiesNVInitializer | null
    ): VkCooperativeMatrixPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCooperativeMatrixPropertiesNV: VkCooperativeMatrixPropertiesNVConstructor

  /**
   * Structure describing cooperative matrix properties supported by an implementation
   */
  interface VkPhysicalDeviceCooperativeMatrixPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitfield of 'VkShaderStageFlagBits' describing the shader stages that cooperative matrix instructions are supported in. 'cooperativeMatrixSupportedStages' will have the 'VK_SHADER_STAGE_COMPUTE_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly cooperativeMatrixSupportedStages: VkShaderStageFlagBits
  }

  declare interface VkPhysicalDeviceCooperativeMatrixPropertiesNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitfield of 'VkShaderStageFlagBits' describing the shader stages that cooperative matrix instructions are supported in. 'cooperativeMatrixSupportedStages' will have the 'VK_SHADER_STAGE_COMPUTE_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly cooperativeMatrixSupportedStages?: VkShaderStageFlagBits
  }

  declare interface VkPhysicalDeviceCooperativeMatrixPropertiesNVConstructor {
    readonly prototype: VkPhysicalDeviceCooperativeMatrixPropertiesNV
    new (
      param?: VkPhysicalDeviceCooperativeMatrixPropertiesNVInitializer | null
    ): VkPhysicalDeviceCooperativeMatrixPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceCooperativeMatrixPropertiesNV: VkPhysicalDeviceCooperativeMatrixPropertiesNVConstructor

  /**
   * Structure describing cooperative matrix features that can be supported by an implementation
   */
  interface VkPhysicalDeviceCooperativeMatrixFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports the 'CooperativeMatrixNV' SPIR-V capability.
     */
    cooperativeMatrix: boolean

    /**
     * indicates that the implementation supports robust buffer access for SPIR-V 'OpCooperativeMatrixLoadNV' and 'OpCooperativeMatrixStoreNV' instructions.
     */
    cooperativeMatrixRobustBufferAccess: boolean
  }

  declare interface VkPhysicalDeviceCooperativeMatrixFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports the 'CooperativeMatrixNV' SPIR-V capability.
     */
    cooperativeMatrix?: boolean

    /**
     * indicates that the implementation supports robust buffer access for SPIR-V 'OpCooperativeMatrixLoadNV' and 'OpCooperativeMatrixStoreNV' instructions.
     */
    cooperativeMatrixRobustBufferAccess?: boolean
  }

  declare interface VkPhysicalDeviceCooperativeMatrixFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceCooperativeMatrixFeaturesNV
    new (
      param?: VkPhysicalDeviceCooperativeMatrixFeaturesNVInitializer | null
    ): VkPhysicalDeviceCooperativeMatrixFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceCooperativeMatrixFeaturesNV: VkPhysicalDeviceCooperativeMatrixFeaturesNVConstructor

  /**
   * Structure describing ASTC HDR features that can be supported by an implementation
   */
  interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether all of the ASTC HDR compressed texture formats are supported. If this feature is enabled, then the 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT', 'VK_FORMAT_FEATURE_BLIT_SRC_BIT' and 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT' features 'must' be supported in 'optimalTilingFeatures' for the following formats:+
     */
    textureCompressionASTC_HDR: boolean
  }

  declare interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether all of the ASTC HDR compressed texture formats are supported. If this feature is enabled, then the 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT', 'VK_FORMAT_FEATURE_BLIT_SRC_BIT' and 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT' features 'must' be supported in 'optimalTilingFeatures' for the following formats:+
     */
    textureCompressionASTC_HDR?: boolean
  }

  declare interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
    new (
      param?: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInitializer | null
    ): VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTConstructor

  /**
   * Structure specifying images to be used as framebuffer attachments
   */
  interface VkRenderPassAttachmentBeginInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of attachments.
     */
    attachmentCount: number

    /**
     * is an array of 'VkImageView' handles, each of which will be used as the corresponding attachment in the render pass instance.
     */
    pAttachments: VkImageView[] | null
  }

  declare interface VkRenderPassAttachmentBeginInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of attachments.
     */
    attachmentCount?: number

    /**
     * is an array of 'VkImageView' handles, each of which will be used as the corresponding attachment in the render pass instance.
     */
    pAttachments?: VkImageView[] | null
  }

  declare interface VkRenderPassAttachmentBeginInfoKHRConstructor {
    readonly prototype: VkRenderPassAttachmentBeginInfoKHR
    new (
      param?: VkRenderPassAttachmentBeginInfoKHRInitializer | null
    ): VkRenderPassAttachmentBeginInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassAttachmentBeginInfoKHR: VkRenderPassAttachmentBeginInfoKHRConstructor

  /**
   * Structure specifying parameters of an image that will be used with a framebuffer
   */
  interface VkFramebufferAttachmentImageInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkImageCreateFlagBits', matching the value of 'VkImageCreateInfo'::'flags' used to create an image that will be used with this framebuffer.
     */
    flags: VkImageCreateFlagBits

    /**
     * is a bitmask of 'VkImageUsageFlagBits', matching the value of 'VkImageCreateInfo'::'usage' used to create an image used with this framebuffer.
     */
    usage: VkImageUsageFlagBits

    /**
     * is the width of the image view used for rendering.
     */
    width: number

    /**
     * is the height of the image view used for rendering.
     */
    height: number

    /**
     *
     */
    layerCount: number

    /**
     *
     */
    viewFormatCount: number

    /**
     * is an array which lists of all formats which 'can' be used when creating views of the image, matching the value of 'VkImageFormatListCreateInfoKHR'::pViewFormats used to create an image used with this framebuffer.
     */
    pViewFormats: Int32Array | null
  }

  declare interface VkFramebufferAttachmentImageInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkImageCreateFlagBits', matching the value of 'VkImageCreateInfo'::'flags' used to create an image that will be used with this framebuffer.
     */
    flags?: VkImageCreateFlagBits

    /**
     * is a bitmask of 'VkImageUsageFlagBits', matching the value of 'VkImageCreateInfo'::'usage' used to create an image used with this framebuffer.
     */
    usage?: VkImageUsageFlagBits

    /**
     * is the width of the image view used for rendering.
     */
    width?: number

    /**
     * is the height of the image view used for rendering.
     */
    height?: number

    /**
     *
     */
    layerCount?: number

    /**
     *
     */
    viewFormatCount?: number

    /**
     * is an array which lists of all formats which 'can' be used when creating views of the image, matching the value of 'VkImageFormatListCreateInfoKHR'::pViewFormats used to create an image used with this framebuffer.
     */
    pViewFormats?: Int32Array | null
  }

  declare interface VkFramebufferAttachmentImageInfoKHRConstructor {
    readonly prototype: VkFramebufferAttachmentImageInfoKHR
    new (
      param?: VkFramebufferAttachmentImageInfoKHRInitializer | null
    ): VkFramebufferAttachmentImageInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFramebufferAttachmentImageInfoKHR: VkFramebufferAttachmentImageInfoKHRConstructor

  /**
   * Structure specifying parameters of images that will be used with a framebuffer
   */
  interface VkFramebufferAttachmentsCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of attachments being described.
     */
    attachmentImageInfoCount: number

    /**
     * is an array of 'VkFramebufferAttachmentImageInfoKHR' instances, each of which describes a number of parameters of the corresponding attachment in a render pass instance.
     */
    pAttachmentImageInfos: VkFramebufferAttachmentImageInfoKHR[] | null
  }

  declare interface VkFramebufferAttachmentsCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of attachments being described.
     */
    attachmentImageInfoCount?: number

    /**
     * is an array of 'VkFramebufferAttachmentImageInfoKHR' instances, each of which describes a number of parameters of the corresponding attachment in a render pass instance.
     */
    pAttachmentImageInfos?: VkFramebufferAttachmentImageInfoKHR[] | null
  }

  declare interface VkFramebufferAttachmentsCreateInfoKHRConstructor {
    readonly prototype: VkFramebufferAttachmentsCreateInfoKHR
    new (
      param?: VkFramebufferAttachmentsCreateInfoKHRInitializer | null
    ): VkFramebufferAttachmentsCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFramebufferAttachmentsCreateInfoKHR: VkFramebufferAttachmentsCreateInfoKHRConstructor

  /**
   * Structure indicating support for imageless framebuffers
   */
  interface VkPhysicalDeviceImagelessFramebufferFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports specifying the image view for attachments at render pass begin time via 'VkRenderPassAttachmentBeginInfoKHR'.
     */
    imagelessFramebuffer: boolean
  }

  declare interface VkPhysicalDeviceImagelessFramebufferFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports specifying the image view for attachments at render pass begin time via 'VkRenderPassAttachmentBeginInfoKHR'.
     */
    imagelessFramebuffer?: boolean
  }

  declare interface VkPhysicalDeviceImagelessFramebufferFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceImagelessFramebufferFeaturesKHR
    new (
      param?: VkPhysicalDeviceImagelessFramebufferFeaturesKHRInitializer | null
    ): VkPhysicalDeviceImagelessFramebufferFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceImagelessFramebufferFeaturesKHR: VkPhysicalDeviceImagelessFramebufferFeaturesKHRConstructor

  /**
   * Structure for querying cubic filtering capabilities of an image view type
   */
  interface VkFilterCubicImageViewImageFormatPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubic: boolean

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering and minmax filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubicMinmax: boolean
  }

  declare interface VkFilterCubicImageViewImageFormatPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubic?: boolean

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering and minmax filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubicMinmax?: boolean
  }

  declare interface VkFilterCubicImageViewImageFormatPropertiesEXTConstructor {
    readonly prototype: VkFilterCubicImageViewImageFormatPropertiesEXT
    new (
      param?: VkFilterCubicImageViewImageFormatPropertiesEXTInitializer | null
    ): VkFilterCubicImageViewImageFormatPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFilterCubicImageViewImageFormatPropertiesEXT: VkFilterCubicImageViewImageFormatPropertiesEXTConstructor

  /**
   * Structure for providing image view type
   */
  interface VkPhysicalDeviceImageViewImageFormatInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    imageViewType: VkImageViewType
  }

  declare interface VkPhysicalDeviceImageViewImageFormatInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    imageViewType?: VkImageViewType
  }

  declare interface VkPhysicalDeviceImageViewImageFormatInfoEXTConstructor {
    readonly prototype: VkPhysicalDeviceImageViewImageFormatInfoEXT
    new (
      param?: VkPhysicalDeviceImageViewImageFormatInfoEXTInitializer | null
    ): VkPhysicalDeviceImageViewImageFormatInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceImageViewImageFormatInfoEXT: VkPhysicalDeviceImageViewImageFormatInfoEXTConstructor

  /**
   * Request a specific address for a buffer
   */
  interface VkBufferDeviceAddressCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the device address requested for the buffer.
     */
    deviceAddress: bigint | number
  }

  declare interface VkBufferDeviceAddressCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the device address requested for the buffer.
     */
    deviceAddress?: bigint | number
  }

  declare interface VkBufferDeviceAddressCreateInfoEXTConstructor {
    readonly prototype: VkBufferDeviceAddressCreateInfoEXT
    new (
      param?: VkBufferDeviceAddressCreateInfoEXTInitializer | null
    ): VkBufferDeviceAddressCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferDeviceAddressCreateInfoEXT: VkBufferDeviceAddressCreateInfoEXTConstructor

  /**
   * Structure specifying the buffer to query an address for
   */
  interface VkBufferDeviceAddressInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies the buffer whose address is being queried.
     */
    buffer: VkBuffer | null
  }

  declare interface VkBufferDeviceAddressInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies the buffer whose address is being queried.
     */
    buffer?: VkBuffer | null
  }

  declare interface VkBufferDeviceAddressInfoEXTConstructor {
    readonly prototype: VkBufferDeviceAddressInfoEXT
    new (
      param?: VkBufferDeviceAddressInfoEXTInitializer | null
    ): VkBufferDeviceAddressInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferDeviceAddressInfoEXT: VkBufferDeviceAddressInfoEXTConstructor

  /**
   *
   */
  interface VkPhysicalDeviceBufferAddressFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    bufferDeviceAddress: boolean

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean
  }

  declare interface VkPhysicalDeviceBufferAddressFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    bufferDeviceAddress?: boolean

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean
  }

  declare interface VkPhysicalDeviceBufferAddressFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceBufferAddressFeaturesEXT
    new (
      param?: VkPhysicalDeviceBufferAddressFeaturesEXTInitializer | null
    ): VkPhysicalDeviceBufferAddressFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceBufferAddressFeaturesEXT: VkPhysicalDeviceBufferAddressFeaturesEXTConstructor

  /**
   * Structure describing buffer address features that can be supported by an implementation
   */
  interface VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    bufferDeviceAddress: boolean

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean
  }

  declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    bufferDeviceAddress?: boolean

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean
  }

  declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
    new (
      param?: VkPhysicalDeviceBufferDeviceAddressFeaturesEXTInitializer | null
    ): VkPhysicalDeviceBufferDeviceAddressFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceBufferDeviceAddressFeaturesEXT: VkPhysicalDeviceBufferDeviceAddressFeaturesEXTConstructor

  /**
   * Specify a memory allocation priority
   */
  interface VkMemoryPriorityAllocateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a floating-point value between `0` and `1`, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent.
     */
    priority: number
  }

  declare interface VkMemoryPriorityAllocateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a floating-point value between `0` and `1`, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent.
     */
    priority?: number
  }

  declare interface VkMemoryPriorityAllocateInfoEXTConstructor {
    readonly prototype: VkMemoryPriorityAllocateInfoEXT
    new (
      param?: VkMemoryPriorityAllocateInfoEXTInitializer | null
    ): VkMemoryPriorityAllocateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryPriorityAllocateInfoEXT: VkMemoryPriorityAllocateInfoEXTConstructor

  /**
   * Structure describing memory priority features that can be supported by an implementation
   */
  interface VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports memory priorities specified at memory allocation time via 'VkMemoryPriorityAllocateInfoEXT'.
     */
    memoryPriority: boolean
  }

  declare interface VkPhysicalDeviceMemoryPriorityFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports memory priorities specified at memory allocation time via 'VkMemoryPriorityAllocateInfoEXT'.
     */
    memoryPriority?: boolean
  }

  declare interface VkPhysicalDeviceMemoryPriorityFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceMemoryPriorityFeaturesEXT
    new (
      param?: VkPhysicalDeviceMemoryPriorityFeaturesEXTInitializer | null
    ): VkPhysicalDeviceMemoryPriorityFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMemoryPriorityFeaturesEXT: VkPhysicalDeviceMemoryPriorityFeaturesEXTConstructor

  /**
   * Structure specifying physical device memory budget and usage
   */
  interface VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     *
     */
    readonly heapBudget: number[] | null

    /**
     *
     */
    readonly heapUsage: number[] | null
  }

  declare interface VkPhysicalDeviceMemoryBudgetPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     *
     */
    readonly heapBudget?: number[] | null

    /**
     *
     */
    readonly heapUsage?: number[] | null
  }

  declare interface VkPhysicalDeviceMemoryBudgetPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceMemoryBudgetPropertiesEXT
    new (
      param?: VkPhysicalDeviceMemoryBudgetPropertiesEXTInitializer | null
    ): VkPhysicalDeviceMemoryBudgetPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMemoryBudgetPropertiesEXT: VkPhysicalDeviceMemoryBudgetPropertiesEXTConstructor

  /**
   * Structure specifying depth clipping state
   */
  interface VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * controls whether depth clipping is enabled as described in <<vertexpostproc-clipping, Primitive Clipping>>.
     */
    depthClipEnable: boolean
  }

  declare interface VkPipelineRasterizationDepthClipStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * controls whether depth clipping is enabled as described in <<vertexpostproc-clipping, Primitive Clipping>>.
     */
    depthClipEnable?: boolean
  }

  declare interface VkPipelineRasterizationDepthClipStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineRasterizationDepthClipStateCreateInfoEXT
    new (
      param?: VkPipelineRasterizationDepthClipStateCreateInfoEXTInitializer | null
    ): VkPipelineRasterizationDepthClipStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRasterizationDepthClipStateCreateInfoEXT: VkPipelineRasterizationDepthClipStateCreateInfoEXTConstructor

  /**
   * Structure indicating support for explicit enable of depth clip
   */
  interface VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports setting the depth clipping operation explicitly via the 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' pipeline state. Otherwise depth clipping is only enabled when 'VkPipelineRasterizationStateCreateInfo'::'depthClampEnable' is set to 'VK_FALSE'.
     */
    depthClipEnable: boolean
  }

  declare interface VkPhysicalDeviceDepthClipEnableFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports setting the depth clipping operation explicitly via the 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' pipeline state. Otherwise depth clipping is only enabled when 'VkPipelineRasterizationStateCreateInfo'::'depthClampEnable' is set to 'VK_FALSE'.
     */
    depthClipEnable?: boolean
  }

  declare interface VkPhysicalDeviceDepthClipEnableFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceDepthClipEnableFeaturesEXT
    new (
      param?: VkPhysicalDeviceDepthClipEnableFeaturesEXTInitializer | null
    ): VkPhysicalDeviceDepthClipEnableFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDepthClipEnableFeaturesEXT: VkPhysicalDeviceDepthClipEnableFeaturesEXTConstructor

  /**
   * Structure indicating support for std430-like packing in uniform buffers
   */
  interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    uniformBufferStandardLayout: boolean
  }

  declare interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    uniformBufferStandardLayout?: boolean
  }

  declare interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
    new (
      param?: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInitializer | null
    ): VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRConstructor

  /**
   * Structure describing capability of a surface to be protected
   */
  interface VkSurfaceProtectedCapabilitiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether a protected swapchain created from 'VkPhysicalDeviceSurfaceInfo2KHR'::'surface' for a particular windowing system 'can' be displayed on screen or not. If 'supportsProtected' is 'VK_TRUE', then creation of swapchains with the 'VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR' flag set 'must' be supported for 'surface'.
     */
    supportsProtected: boolean
  }

  declare interface VkSurfaceProtectedCapabilitiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether a protected swapchain created from 'VkPhysicalDeviceSurfaceInfo2KHR'::'surface' for a particular windowing system 'can' be displayed on screen or not. If 'supportsProtected' is 'VK_TRUE', then creation of swapchains with the 'VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR' flag set 'must' be supported for 'surface'.
     */
    supportsProtected?: boolean
  }

  declare interface VkSurfaceProtectedCapabilitiesKHRConstructor {
    readonly prototype: VkSurfaceProtectedCapabilitiesKHR
    new (
      param?: VkSurfaceProtectedCapabilitiesKHRInitializer | null
    ): VkSurfaceProtectedCapabilitiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceProtectedCapabilitiesKHR: VkSurfaceProtectedCapabilitiesKHRConstructor

  /**
   * Structure indicating support for scalar block layouts
   */
  interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports the layout of resource blocks in shaders using <<interfaces-scalar-block-layout, scalar alignment>>.
     */
    scalarBlockLayout: boolean
  }

  declare interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports the layout of resource blocks in shaders using <<interfaces-scalar-block-layout, scalar alignment>>.
     */
    scalarBlockLayout?: boolean
  }

  declare interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
    new (
      param?: VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInitializer | null
    ): VkPhysicalDeviceScalarBlockLayoutFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceScalarBlockLayoutFeaturesEXT: VkPhysicalDeviceScalarBlockLayoutFeaturesEXTConstructor

  /**
   * Structure containing fragment density map attachment for render pass
   */
  interface VkRenderPassFragmentDensityMapCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the fragment density map to use for the render pass.
     */
    fragmentDensityMapAttachment: VkAttachmentReference | null
  }

  declare interface VkRenderPassFragmentDensityMapCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the fragment density map to use for the render pass.
     */
    fragmentDensityMapAttachment?: VkAttachmentReference | null
  }

  declare interface VkRenderPassFragmentDensityMapCreateInfoEXTConstructor {
    readonly prototype: VkRenderPassFragmentDensityMapCreateInfoEXT
    new (
      param?: VkRenderPassFragmentDensityMapCreateInfoEXTInitializer | null
    ): VkRenderPassFragmentDensityMapCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassFragmentDensityMapCreateInfoEXT: VkRenderPassFragmentDensityMapCreateInfoEXTConstructor

  /**
   * Structure describing fragment density map properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     * is the minimum <<glossary-fragment-density-texel-size,fragment density texel size>>.
     */
    readonly minFragmentDensityTexelSize: VkExtent2D | null

    /**
     *
     */
    readonly maxFragmentDensityTexelSize: VkExtent2D | null

    /**
     *
     */
    readonly fragmentDensityInvocations: boolean
  }

  declare interface VkPhysicalDeviceFragmentDensityMapPropertiesEXTInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     * is the minimum <<glossary-fragment-density-texel-size,fragment density texel size>>.
     */
    readonly minFragmentDensityTexelSize?: VkExtent2D | null

    /**
     *
     */
    readonly maxFragmentDensityTexelSize?: VkExtent2D | null

    /**
     *
     */
    readonly fragmentDensityInvocations?: boolean
  }

  declare interface VkPhysicalDeviceFragmentDensityMapPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceFragmentDensityMapPropertiesEXT
    new (
      param?: VkPhysicalDeviceFragmentDensityMapPropertiesEXTInitializer | null
    ): VkPhysicalDeviceFragmentDensityMapPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFragmentDensityMapPropertiesEXT: VkPhysicalDeviceFragmentDensityMapPropertiesEXTConstructor

  /**
   * Structure describing fragment density map features that can be supported by an implementation
   */
  interface VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     * specifies whether the implementation supports render passes with a fragment density map attachment. If this feature is not enabled and the 'pNext' chain of 'VkRenderPassCreateInfo' contains 'VkRenderPassFragmentDensityMapCreateInfoEXT', 'fragmentDensityMapAttachment' 'must' be 'VK_ATTACHMENT_UNUSED'.
     */
    readonly fragmentDensityMap: boolean

    /**
     * specifies whether the implementation supports dynamic fragment density map image views. If this feature is not enabled, 'VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT' 'must' not be included in 'VkImageViewCreateInfo'::'flags'.
     */
    readonly fragmentDensityMapDynamic: boolean

    /**
     * specifies whether the implementation supports regular non-subsampled image attachments with fragment density map render passes. If this feature is not enabled, render passes with a <<renderpass-fragmentdensitymapattachment,fragment density map attachment>> 'must' only have <<resources-subsampledimages,subsampled attachments>> bound.
     */
    readonly fragmentDensityMapNonSubsampledImages: boolean
  }

  declare interface VkPhysicalDeviceFragmentDensityMapFeaturesEXTInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     * specifies whether the implementation supports render passes with a fragment density map attachment. If this feature is not enabled and the 'pNext' chain of 'VkRenderPassCreateInfo' contains 'VkRenderPassFragmentDensityMapCreateInfoEXT', 'fragmentDensityMapAttachment' 'must' be 'VK_ATTACHMENT_UNUSED'.
     */
    readonly fragmentDensityMap?: boolean

    /**
     * specifies whether the implementation supports dynamic fragment density map image views. If this feature is not enabled, 'VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT' 'must' not be included in 'VkImageViewCreateInfo'::'flags'.
     */
    readonly fragmentDensityMapDynamic?: boolean

    /**
     * specifies whether the implementation supports regular non-subsampled image attachments with fragment density map render passes. If this feature is not enabled, render passes with a <<renderpass-fragmentdensitymapattachment,fragment density map attachment>> 'must' only have <<resources-subsampledimages,subsampled attachments>> bound.
     */
    readonly fragmentDensityMapNonSubsampledImages?: boolean
  }

  declare interface VkPhysicalDeviceFragmentDensityMapFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
    new (
      param?: VkPhysicalDeviceFragmentDensityMapFeaturesEXTInitializer | null
    ): VkPhysicalDeviceFragmentDensityMapFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFragmentDensityMapFeaturesEXT: VkPhysicalDeviceFragmentDensityMapFeaturesEXTConstructor

  /**
   * Specify memory overallocation behavior for a Vulkan device
   */
  interface VkDeviceMemoryOverallocationCreateInfoAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the desired overallocation behavior.
     */
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD
  }

  declare interface VkDeviceMemoryOverallocationCreateInfoAMDInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the desired overallocation behavior.
     */
    overallocationBehavior?: VkMemoryOverallocationBehaviorAMD
  }

  declare interface VkDeviceMemoryOverallocationCreateInfoAMDConstructor {
    readonly prototype: VkDeviceMemoryOverallocationCreateInfoAMD
    new (
      param?: VkDeviceMemoryOverallocationCreateInfoAMDInitializer | null
    ): VkDeviceMemoryOverallocationCreateInfoAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceMemoryOverallocationCreateInfoAMD: VkDeviceMemoryOverallocationCreateInfoAMDConstructor

  /**
   * Specify separate usage flags for the stencil aspect of a depth-stencil image
   */
  interface VkImageStencilUsageCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkImageUsageFlagBits' describing the intended usage of the stencil aspect of the image.
     */
    stencilUsage: VkImageUsageFlagBits
  }

  declare interface VkImageStencilUsageCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkImageUsageFlagBits' describing the intended usage of the stencil aspect of the image.
     */
    stencilUsage?: VkImageUsageFlagBits
  }

  declare interface VkImageStencilUsageCreateInfoEXTConstructor {
    readonly prototype: VkImageStencilUsageCreateInfoEXT
    new (
      param?: VkImageStencilUsageCreateInfoEXTInitializer | null
    ): VkImageStencilUsageCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageStencilUsageCreateInfoEXT: VkImageStencilUsageCreateInfoEXTConstructor

  /**
   * Properties of an image\
   */
  interface VkImageDrmFormatModifierPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * returns the image's <<glossary-drm-format-modifier,Linux DRM format modifier>>.
     */
    readonly drmFormatModifier: bigint | number
  }

  declare interface VkImageDrmFormatModifierPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * returns the image's <<glossary-drm-format-modifier,Linux DRM format modifier>>.
     */
    readonly drmFormatModifier?: bigint | number
  }

  declare interface VkImageDrmFormatModifierPropertiesEXTConstructor {
    readonly prototype: VkImageDrmFormatModifierPropertiesEXT
    new (
      param?: VkImageDrmFormatModifierPropertiesEXTInitializer | null
    ): VkImageDrmFormatModifierPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageDrmFormatModifierPropertiesEXT: VkImageDrmFormatModifierPropertiesEXTConstructor

  /**
   * Specify that an image be created with the provided DRM format modifier and explicit memory layout
   */
  interface VkImageDrmFormatModifierExplicitCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the _Linux DRM format modifier_ with which the image will be created.
     */
    drmFormatModifier: bigint | number

    /**
     * is the number of _memory planes_ in the image (as reported by 'VkDrmFormatModifierPropertiesEXT') as well as the length of the 'pPlaneLayouts' array.
     */
    drmFormatModifierPlaneCount: number

    /**
     * is an array of 'VkSubresourceLayout' structures describing the image's _memory planes_.
     */
    pPlaneLayouts: VkSubresourceLayout[] | null
  }

  declare interface VkImageDrmFormatModifierExplicitCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the _Linux DRM format modifier_ with which the image will be created.
     */
    drmFormatModifier?: bigint | number

    /**
     * is the number of _memory planes_ in the image (as reported by 'VkDrmFormatModifierPropertiesEXT') as well as the length of the 'pPlaneLayouts' array.
     */
    drmFormatModifierPlaneCount?: number

    /**
     * is an array of 'VkSubresourceLayout' structures describing the image's _memory planes_.
     */
    pPlaneLayouts?: VkSubresourceLayout[] | null
  }

  declare interface VkImageDrmFormatModifierExplicitCreateInfoEXTConstructor {
    readonly prototype: VkImageDrmFormatModifierExplicitCreateInfoEXT
    new (
      param?: VkImageDrmFormatModifierExplicitCreateInfoEXTInitializer | null
    ): VkImageDrmFormatModifierExplicitCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageDrmFormatModifierExplicitCreateInfoEXT: VkImageDrmFormatModifierExplicitCreateInfoEXTConstructor

  /**
   * Specify that an image must be created with a DRM format modifier from the provided list
   */
  interface VkImageDrmFormatModifierListCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the length of the 'pDrmFormatModifiers' array.
     */
    drmFormatModifierCount: number

    /**
     * is an array of _Linux DRM format modifiers_.
     */
    pDrmFormatModifiers: BigUint64Array | null
  }

  declare interface VkImageDrmFormatModifierListCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the length of the 'pDrmFormatModifiers' array.
     */
    drmFormatModifierCount?: number

    /**
     * is an array of _Linux DRM format modifiers_.
     */
    pDrmFormatModifiers?: BigUint64Array | null
  }

  declare interface VkImageDrmFormatModifierListCreateInfoEXTConstructor {
    readonly prototype: VkImageDrmFormatModifierListCreateInfoEXT
    new (
      param?: VkImageDrmFormatModifierListCreateInfoEXTInitializer | null
    ): VkImageDrmFormatModifierListCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageDrmFormatModifierListCreateInfoEXT: VkImageDrmFormatModifierListCreateInfoEXTConstructor

  /**
   * Structure specifying a DRM format modifier as image creation parameter
   */
  interface VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the image's _Linux DRM format modifier_, corresponding to 'VkImageDrmFormatModifierExplicitCreateInfoEXT'::'modifier' or to 'VkImageDrmFormatModifierListCreateInfoEXT'::'pModifiers'.
     */
    drmFormatModifier: bigint | number

    /**
     * specifies how the image will be accessed by multiple queue families.
     */
    sharingMode: VkSharingMode

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount: number

    /**
     * is a list of queue families that will access the image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices: Uint32Array | null
  }

  declare interface VkPhysicalDeviceImageDrmFormatModifierInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the image's _Linux DRM format modifier_, corresponding to 'VkImageDrmFormatModifierExplicitCreateInfoEXT'::'modifier' or to 'VkImageDrmFormatModifierListCreateInfoEXT'::'pModifiers'.
     */
    drmFormatModifier?: bigint | number

    /**
     * specifies how the image will be accessed by multiple queue families.
     */
    sharingMode?: VkSharingMode

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount?: number

    /**
     * is a list of queue families that will access the image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices?: Uint32Array | null
  }

  declare interface VkPhysicalDeviceImageDrmFormatModifierInfoEXTConstructor {
    readonly prototype: VkPhysicalDeviceImageDrmFormatModifierInfoEXT
    new (
      param?: VkPhysicalDeviceImageDrmFormatModifierInfoEXTInitializer | null
    ): VkPhysicalDeviceImageDrmFormatModifierInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceImageDrmFormatModifierInfoEXT: VkPhysicalDeviceImageDrmFormatModifierInfoEXTConstructor

  /**
   * Structure specifying properties of a format when combined with a DRM format modifier
   */
  interface VkDrmFormatModifierPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a _Linux DRM format modifier_.
     */
    readonly drmFormatModifier: bigint | number

    /**
     * is the number of _memory planes_ in any image created with 'format' and 'drmFormatModifier'. An image's _memory planecount_ is distinct from its _format planecount_, as explained below.
     */
    readonly drmFormatModifierPlaneCount: number

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' that are supported by any image created with 'format' and 'drmFormatModifier'.
     */
    readonly drmFormatModifierTilingFeatures: VkFormatFeatureFlagBits
  }

  declare interface VkDrmFormatModifierPropertiesEXTInitializer {
    /**
     * is a _Linux DRM format modifier_.
     */
    readonly drmFormatModifier?: bigint | number

    /**
     * is the number of _memory planes_ in any image created with 'format' and 'drmFormatModifier'. An image's _memory planecount_ is distinct from its _format planecount_, as explained below.
     */
    readonly drmFormatModifierPlaneCount?: number

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' that are supported by any image created with 'format' and 'drmFormatModifier'.
     */
    readonly drmFormatModifierTilingFeatures?: VkFormatFeatureFlagBits
  }

  declare interface VkDrmFormatModifierPropertiesEXTConstructor {
    readonly prototype: VkDrmFormatModifierPropertiesEXT
    new (
      param?: VkDrmFormatModifierPropertiesEXTInitializer | null
    ): VkDrmFormatModifierPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDrmFormatModifierPropertiesEXT: VkDrmFormatModifierPropertiesEXTConstructor

  /**
   * Structure specifying the list of DRM format modifiers supported for a format
   */
  interface VkDrmFormatModifierPropertiesListEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is an inout parameter related to the number of modifiers compatible with the 'format', as described below.
     */
    readonly drmFormatModifierCount: number

    /**
     * is either <i>null</i> or an array of 'VkDrmFormatModifierPropertiesEXT' structures.
     */
    readonly pDrmFormatModifierProperties:
      | VkDrmFormatModifierPropertiesEXT[]
      | null
  }

  declare interface VkDrmFormatModifierPropertiesListEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is an inout parameter related to the number of modifiers compatible with the 'format', as described below.
     */
    readonly drmFormatModifierCount?: number

    /**
     * is either <i>null</i> or an array of 'VkDrmFormatModifierPropertiesEXT' structures.
     */
    readonly pDrmFormatModifierProperties?:
      | VkDrmFormatModifierPropertiesEXT[]
      | null
  }

  declare interface VkDrmFormatModifierPropertiesListEXTConstructor {
    readonly prototype: VkDrmFormatModifierPropertiesListEXT
    new (
      param?: VkDrmFormatModifierPropertiesListEXTInitializer | null
    ): VkDrmFormatModifierPropertiesListEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDrmFormatModifierPropertiesListEXT: VkDrmFormatModifierPropertiesListEXTConstructor

  /**
   * Properties of the physical device for ray tracing
   */
  interface VkPhysicalDeviceRayTracingPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * size in bytes of the shader header.
     */
    readonly shaderGroupHandleSize: number

    /**
     * is the maximum number of levels of recursion allowed in a trace command.
     */
    readonly maxRecursionDepth: number

    /**
     * is the maximum stride in bytes allowed between shader groups in the SBT.
     */
    readonly maxShaderGroupStride: number

    /**
     * is the required alignment in bytes for the base of the SBTs.
     */
    readonly shaderGroupBaseAlignment: number

    /**
     * is the maximum number of geometries in the bottom level acceleration structure.
     */
    readonly maxGeometryCount: bigint | number

    /**
     * is the maximum number of instances in the top level acceleration structure.
     */
    readonly maxInstanceCount: bigint | number

    /**
     * is the maximum number of triangles in all geometries in the bottom level acceleration structure.
     */
    readonly maxTriangleCount: bigint | number

    /**
     * is the maximum number of acceleration structure descriptors that are allowed in a descriptor set.
     */
    readonly maxDescriptorSetAccelerationStructures: number
  }

  declare interface VkPhysicalDeviceRayTracingPropertiesNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * size in bytes of the shader header.
     */
    readonly shaderGroupHandleSize?: number

    /**
     * is the maximum number of levels of recursion allowed in a trace command.
     */
    readonly maxRecursionDepth?: number

    /**
     * is the maximum stride in bytes allowed between shader groups in the SBT.
     */
    readonly maxShaderGroupStride?: number

    /**
     * is the required alignment in bytes for the base of the SBTs.
     */
    readonly shaderGroupBaseAlignment?: number

    /**
     * is the maximum number of geometries in the bottom level acceleration structure.
     */
    readonly maxGeometryCount?: bigint | number

    /**
     * is the maximum number of instances in the top level acceleration structure.
     */
    readonly maxInstanceCount?: bigint | number

    /**
     * is the maximum number of triangles in all geometries in the bottom level acceleration structure.
     */
    readonly maxTriangleCount?: bigint | number

    /**
     * is the maximum number of acceleration structure descriptors that are allowed in a descriptor set.
     */
    readonly maxDescriptorSetAccelerationStructures?: number
  }

  declare interface VkPhysicalDeviceRayTracingPropertiesNVConstructor {
    readonly prototype: VkPhysicalDeviceRayTracingPropertiesNV
    new (
      param?: VkPhysicalDeviceRayTracingPropertiesNVInitializer | null
    ): VkPhysicalDeviceRayTracingPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceRayTracingPropertiesNV: VkPhysicalDeviceRayTracingPropertiesNVConstructor

  /**
   * Structure specifying acceleration to query for memory requirements
   */
  interface VkAccelerationStructureMemoryRequirementsInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * selects the type of memory requirement being queried. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV' returns the memory requirements for the object itself. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV' returns the memory requirements for the scratch memory when doing a build. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV' returns the memory requirements for the scratch memory when doing an update.
     */
    type: VkAccelerationStructureMemoryRequirementsTypeNV

    /**
     * is the acceleration structure to be queried for memory requirements.
     */
    accelerationStructure: VkAccelerationStructureNV | null
  }

  declare interface VkAccelerationStructureMemoryRequirementsInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * selects the type of memory requirement being queried. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV' returns the memory requirements for the object itself. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV' returns the memory requirements for the scratch memory when doing a build. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV' returns the memory requirements for the scratch memory when doing an update.
     */
    type?: VkAccelerationStructureMemoryRequirementsTypeNV

    /**
     * is the acceleration structure to be queried for memory requirements.
     */
    accelerationStructure?: VkAccelerationStructureNV | null
  }

  declare interface VkAccelerationStructureMemoryRequirementsInfoNVConstructor {
    readonly prototype: VkAccelerationStructureMemoryRequirementsInfoNV
    new (
      param?: VkAccelerationStructureMemoryRequirementsInfoNVInitializer | null
    ): VkAccelerationStructureMemoryRequirementsInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAccelerationStructureMemoryRequirementsInfoNV: VkAccelerationStructureMemoryRequirementsInfoNVConstructor

  /**
   * Structure specifying acceleration structure descriptor info
   */
  interface VkWriteDescriptorSetAccelerationStructureNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of elements in 'pAccelerationStructures'.
     */
    accelerationStructureCount: number

    /**
     * are the acceleration structures to update.
     */
    pAccelerationStructures: VkAccelerationStructureNV[] | null
  }

  declare interface VkWriteDescriptorSetAccelerationStructureNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of elements in 'pAccelerationStructures'.
     */
    accelerationStructureCount?: number

    /**
     * are the acceleration structures to update.
     */
    pAccelerationStructures?: VkAccelerationStructureNV[] | null
  }

  declare interface VkWriteDescriptorSetAccelerationStructureNVConstructor {
    readonly prototype: VkWriteDescriptorSetAccelerationStructureNV
    new (
      param?: VkWriteDescriptorSetAccelerationStructureNVInitializer | null
    ): VkWriteDescriptorSetAccelerationStructureNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkWriteDescriptorSetAccelerationStructureNV: VkWriteDescriptorSetAccelerationStructureNVConstructor

  /**
   * Structure specifying acceleration structure memory binding
   */
  interface VkBindAccelerationStructureMemoryInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the acceleration structure to be attached to memory.
     */
    accelerationStructure: VkAccelerationStructureNV | null

    /**
     * is a 'VkDeviceMemory' object describing the device memory to attach.
     */
    memory: VkDeviceMemory | null

    /**
     * is the start offset of the region of memory that is to be bound to the acceleration structure. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified acceleration structure.
     */
    memoryOffset: bigint | number

    /**
     * is the number of elements in 'pDeviceIndices'.
     */
    deviceIndexCount: number

    /**
     * is an array of device indices.
     */
    pDeviceIndices: Uint32Array | null
  }

  declare interface VkBindAccelerationStructureMemoryInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the acceleration structure to be attached to memory.
     */
    accelerationStructure?: VkAccelerationStructureNV | null

    /**
     * is a 'VkDeviceMemory' object describing the device memory to attach.
     */
    memory?: VkDeviceMemory | null

    /**
     * is the start offset of the region of memory that is to be bound to the acceleration structure. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified acceleration structure.
     */
    memoryOffset?: bigint | number

    /**
     * is the number of elements in 'pDeviceIndices'.
     */
    deviceIndexCount?: number

    /**
     * is an array of device indices.
     */
    pDeviceIndices?: Uint32Array | null
  }

  declare interface VkBindAccelerationStructureMemoryInfoNVConstructor {
    readonly prototype: VkBindAccelerationStructureMemoryInfoNV
    new (
      param?: VkBindAccelerationStructureMemoryInfoNVInitializer | null
    ): VkBindAccelerationStructureMemoryInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindAccelerationStructureMemoryInfoNV: VkBindAccelerationStructureMemoryInfoNVConstructor

  /**
   * Structure specifying the parameters of a newly created acceleration structure object
   */
  interface VkAccelerationStructureCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the size from the result of 'vkCmdWriteAccelerationStructuresPropertiesNV' if this acceleration structure is going to be the target of a compacting copy.
     */
    compactedSize: bigint | number

    /**
     * is the 'VkAccelerationStructureInfoNV' structure specifying further parameters of the created acceleration structure.
     */
    info: VkAccelerationStructureInfoNV | null
  }

  declare interface VkAccelerationStructureCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the size from the result of 'vkCmdWriteAccelerationStructuresPropertiesNV' if this acceleration structure is going to be the target of a compacting copy.
     */
    compactedSize?: bigint | number

    /**
     * is the 'VkAccelerationStructureInfoNV' structure specifying further parameters of the created acceleration structure.
     */
    info?: VkAccelerationStructureInfoNV | null
  }

  declare interface VkAccelerationStructureCreateInfoNVConstructor {
    readonly prototype: VkAccelerationStructureCreateInfoNV
    new (
      param?: VkAccelerationStructureCreateInfoNVInitializer | null
    ): VkAccelerationStructureCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAccelerationStructureCreateInfoNV: VkAccelerationStructureCreateInfoNVConstructor

  /**
   * Structure specifying the parameters of acceleration structure object
   */
  interface VkAccelerationStructureInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkAccelerationStructureTypeNV' value specifying the type of acceleration structure that will be created.
     */
    type: VkAccelerationStructureTypeNV

    /**
     * is a bitmask of 'VkBuildAccelerationStructureFlagBitsNV' specifying additional parameters of the acceleration structure.
     */
    flags: VkBuildAccelerationStructureFlagBitsNV

    /**
     * specifies the number of instances that will be in the new acceleration structure.
     */
    instanceCount: number

    /**
     * 'VkGeometryNV' structures containing the scene data being passed into the acceleration structure.
     */
    geometryCount: number

    /**
     *
     */
    pGeometries: VkGeometryNV[] | null
  }

  declare interface VkAccelerationStructureInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkAccelerationStructureTypeNV' value specifying the type of acceleration structure that will be created.
     */
    type?: VkAccelerationStructureTypeNV

    /**
     * is a bitmask of 'VkBuildAccelerationStructureFlagBitsNV' specifying additional parameters of the acceleration structure.
     */
    flags?: VkBuildAccelerationStructureFlagBitsNV

    /**
     * specifies the number of instances that will be in the new acceleration structure.
     */
    instanceCount?: number

    /**
     * 'VkGeometryNV' structures containing the scene data being passed into the acceleration structure.
     */
    geometryCount?: number

    /**
     *
     */
    pGeometries?: VkGeometryNV[] | null
  }

  declare interface VkAccelerationStructureInfoNVConstructor {
    readonly prototype: VkAccelerationStructureInfoNV
    new (
      param?: VkAccelerationStructureInfoNVInitializer | null
    ): VkAccelerationStructureInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAccelerationStructureInfoNV: VkAccelerationStructureInfoNVConstructor

  /**
   * Structure specifying a geometry in a bottom-level acceleration structure
   */
  interface VkGeometryNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * describes which type of geometry this 'VkGeometryNV' refers to.
     */
    geometryType: VkGeometryTypeNV

    /**
     * contains the geometry data as described in 'VkGeometryDataNV'.
     */
    geometry: VkGeometryDataNV | null

    /**
     * has flags describing options for this geometry.
     */
    flags: VkGeometryFlagBitsNV
  }

  declare interface VkGeometryNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * describes which type of geometry this 'VkGeometryNV' refers to.
     */
    geometryType?: VkGeometryTypeNV

    /**
     * contains the geometry data as described in 'VkGeometryDataNV'.
     */
    geometry?: VkGeometryDataNV | null

    /**
     * has flags describing options for this geometry.
     */
    flags?: VkGeometryFlagBitsNV
  }

  declare interface VkGeometryNVConstructor {
    readonly prototype: VkGeometryNV
    new (param?: VkGeometryNVInitializer | null): VkGeometryNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkGeometryNV: VkGeometryNVConstructor

  /**
   * Structure specifying geometry in a bottom-level acceleration structure
   */
  interface VkGeometryDataNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * contains triangle data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_TRIANGLES_NV'.
     */
    triangles: VkGeometryTrianglesNV | null

    /**
     * contains axis-aligned bounding box data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_AABBS_NV'.
     */
    aabbs: VkGeometryAABBNV | null
  }

  declare interface VkGeometryDataNVInitializer {
    /**
     * contains triangle data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_TRIANGLES_NV'.
     */
    triangles?: VkGeometryTrianglesNV | null

    /**
     * contains axis-aligned bounding box data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_AABBS_NV'.
     */
    aabbs?: VkGeometryAABBNV | null
  }

  declare interface VkGeometryDataNVConstructor {
    readonly prototype: VkGeometryDataNV
    new (param?: VkGeometryDataNVInitializer | null): VkGeometryDataNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkGeometryDataNV: VkGeometryDataNVConstructor

  /**
   * Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure
   */
  interface VkGeometryAABBNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the buffer containing axis-aligned bounding box data.
     */
    aabbData: VkBuffer | null

    /**
     * is the number of AABBs in this geometry.
     */
    numAABBs: number

    /**
     *
     */
    stride: number

    /**
     *
     */
    offset: bigint | number
  }

  declare interface VkGeometryAABBNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the buffer containing axis-aligned bounding box data.
     */
    aabbData?: VkBuffer | null

    /**
     * is the number of AABBs in this geometry.
     */
    numAABBs?: number

    /**
     *
     */
    stride?: number

    /**
     *
     */
    offset?: bigint | number
  }

  declare interface VkGeometryAABBNVConstructor {
    readonly prototype: VkGeometryAABBNV
    new (param?: VkGeometryAABBNVInitializer | null): VkGeometryAABBNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkGeometryAABBNV: VkGeometryAABBNVConstructor

  /**
   * Structure specifying a triangle geometry in a bottom-level acceleration structure
   */
  interface VkGeometryTrianglesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * containing vertex data for this geometry.
     */
    vertexData: VkBuffer | null

    /**
     *
     */
    vertexOffset: bigint | number

    /**
     * is the number of valid vertices.
     */
    vertexCount: number

    /**
     * is the stride in bytes between each vertex.
     */
    vertexStride: bigint | number

    /**
     * is the format of each vertex element.
     */
    vertexFormat: VkFormat

    /**
     * containing index data for this geometry.
     */
    indexData: VkBuffer | null

    /**
     *
     */
    indexOffset: bigint | number

    /**
     * is the number of indices to include in this geometry.
     */
    indexCount: number

    /**
     * is the format of each index.
     */
    indexType: VkIndexType

    /**
     * of the transform information described above.
     */
    transformData: VkBuffer | null

    /**
     *
     */
    transformOffset: bigint | number
  }

  declare interface VkGeometryTrianglesNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * containing vertex data for this geometry.
     */
    vertexData?: VkBuffer | null

    /**
     *
     */
    vertexOffset?: bigint | number

    /**
     * is the number of valid vertices.
     */
    vertexCount?: number

    /**
     * is the stride in bytes between each vertex.
     */
    vertexStride?: bigint | number

    /**
     * is the format of each vertex element.
     */
    vertexFormat?: VkFormat

    /**
     * containing index data for this geometry.
     */
    indexData?: VkBuffer | null

    /**
     *
     */
    indexOffset?: bigint | number

    /**
     * is the number of indices to include in this geometry.
     */
    indexCount?: number

    /**
     * is the format of each index.
     */
    indexType?: VkIndexType

    /**
     * of the transform information described above.
     */
    transformData?: VkBuffer | null

    /**
     *
     */
    transformOffset?: bigint | number
  }

  declare interface VkGeometryTrianglesNVConstructor {
    readonly prototype: VkGeometryTrianglesNV
    new (param?: VkGeometryTrianglesNVInitializer | null): VkGeometryTrianglesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkGeometryTrianglesNV: VkGeometryTrianglesNVConstructor

  /**
   * Structure specifying parameters of a newly created ray tracing pipeline
   */
  interface VkRayTracingPipelineCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the ray tracing pipeline.
     */
    stageCount: number

    /**
     * array.
     */
    pStages: VkPipelineShaderStageCreateInfo[] | null

    /**
     * 'VkRayTracingShaderGroupCreateInfoNV' structures describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
     */
    groupCount: number

    /**
     * array.
     */
    pGroups: VkRayTracingShaderGroupCreateInfoNV[] | null

    /**
     * is the maximum recursion that will be called from this pipeline.
     */
    maxRecursionDepth: number

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout: VkPipelineLayout | null

    /**
     * is a pipeline to derive from.
     */
    basePipelineHandle: VkPipeline | null

    /**
     *
     */
    basePipelineIndex: number
  }

  declare interface VkRayTracingPipelineCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the ray tracing pipeline.
     */
    stageCount?: number

    /**
     * array.
     */
    pStages?: VkPipelineShaderStageCreateInfo[] | null

    /**
     * 'VkRayTracingShaderGroupCreateInfoNV' structures describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
     */
    groupCount?: number

    /**
     * array.
     */
    pGroups?: VkRayTracingShaderGroupCreateInfoNV[] | null

    /**
     * is the maximum recursion that will be called from this pipeline.
     */
    maxRecursionDepth?: number

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout?: VkPipelineLayout | null

    /**
     * is a pipeline to derive from.
     */
    basePipelineHandle?: VkPipeline | null

    /**
     *
     */
    basePipelineIndex?: number
  }

  declare interface VkRayTracingPipelineCreateInfoNVConstructor {
    readonly prototype: VkRayTracingPipelineCreateInfoNV
    new (
      param?: VkRayTracingPipelineCreateInfoNVInitializer | null
    ): VkRayTracingPipelineCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRayTracingPipelineCreateInfoNV: VkRayTracingPipelineCreateInfoNVConstructor

  /**
   * Structure specifying shaders in a shader group
   */
  interface VkRayTracingShaderGroupCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the type of hit group specified in this structure.
     */
    type: VkRayTracingShaderGroupTypeNV

    /**
     * is the index of the ray generation, miss, or callable shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    generalShader: number

    /**
     * is the optional index of the closest hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    closestHitShader: number

    /**
     * is the optional index of the any-hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    anyHitShader: number

    /**
     * is the index of the intersection shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    intersectionShader: number
  }

  declare interface VkRayTracingShaderGroupCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the type of hit group specified in this structure.
     */
    type?: VkRayTracingShaderGroupTypeNV

    /**
     * is the index of the ray generation, miss, or callable shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    generalShader?: number

    /**
     * is the optional index of the closest hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    closestHitShader?: number

    /**
     * is the optional index of the any-hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    anyHitShader?: number

    /**
     * is the index of the intersection shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV' and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    intersectionShader?: number
  }

  declare interface VkRayTracingShaderGroupCreateInfoNVConstructor {
    readonly prototype: VkRayTracingShaderGroupCreateInfoNV
    new (
      param?: VkRayTracingShaderGroupCreateInfoNVInitializer | null
    ): VkRayTracingShaderGroupCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRayTracingShaderGroupCreateInfoNV: VkRayTracingShaderGroupCreateInfoNVConstructor

  /**
   * Structure specifying a mesh tasks draw indirect command
   */
  interface VkDrawMeshTasksIndirectCommandNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
     */
    taskCount: number

    /**
     * is the X component of the first workgroup ID.
     */
    firstTask: number
  }

  declare interface VkDrawMeshTasksIndirectCommandNVInitializer {
    /**
     * is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
     */
    taskCount?: number

    /**
     * is the X component of the first workgroup ID.
     */
    firstTask?: number
  }

  declare interface VkDrawMeshTasksIndirectCommandNVConstructor {
    readonly prototype: VkDrawMeshTasksIndirectCommandNV
    new (
      param?: VkDrawMeshTasksIndirectCommandNVInitializer | null
    ): VkDrawMeshTasksIndirectCommandNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDrawMeshTasksIndirectCommandNV: VkDrawMeshTasksIndirectCommandNVConstructor

  /**
   * Structure describing mesh shading properties
   */
  interface VkPhysicalDeviceMeshShaderPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum number of local workgroups that 'can' be launched by a single draw mesh tasks command. See <<drawing-mesh-shading>>.
     */
    readonly maxDrawMeshTasksCount: number

    /**
     * is the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxTaskWorkGroupInvocations: number

    /**
     *
     */
    readonly maxTaskWorkGroupSize: number[] | null

    /**
     * is the maximum number of bytes that the task shader can use in total for shared and output memory combined.
     */
    readonly maxTaskTotalMemorySize: number

    /**
     * is the maximum number of output tasks a single task shader workgroup can emit.
     */
    readonly maxTaskOutputCount: number

    /**
     * is the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxMeshWorkGroupInvocations: number

    /**
     *
     */
    readonly maxMeshWorkGroupSize: number[] | null

    /**
     * is the maximum number of bytes that the mesh shader can use in total for shared and output memory combined.
     */
    readonly maxMeshTotalMemorySize: number

    /**
     * is the maximum number of vertices a mesh shader output can store.
     */
    readonly maxMeshOutputVertices: number

    /**
     * is the maximum number of primitives a mesh shader output can store.
     */
    readonly maxMeshOutputPrimitives: number

    /**
     * is the maximum number of multi-view views a mesh shader can use.
     */
    readonly maxMeshMultiviewViewCount: number

    /**
     * is the granularity with which mesh vertex outputs are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerVertexGranularity: number

    /**
     * is the granularity with which mesh outputs qualified as per-primitive are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerPrimitiveGranularity: number
  }

  declare interface VkPhysicalDeviceMeshShaderPropertiesNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum number of local workgroups that 'can' be launched by a single draw mesh tasks command. See <<drawing-mesh-shading>>.
     */
    readonly maxDrawMeshTasksCount?: number

    /**
     * is the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxTaskWorkGroupInvocations?: number

    /**
     *
     */
    readonly maxTaskWorkGroupSize?: number[] | null

    /**
     * is the maximum number of bytes that the task shader can use in total for shared and output memory combined.
     */
    readonly maxTaskTotalMemorySize?: number

    /**
     * is the maximum number of output tasks a single task shader workgroup can emit.
     */
    readonly maxTaskOutputCount?: number

    /**
     * is the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxMeshWorkGroupInvocations?: number

    /**
     *
     */
    readonly maxMeshWorkGroupSize?: number[] | null

    /**
     * is the maximum number of bytes that the mesh shader can use in total for shared and output memory combined.
     */
    readonly maxMeshTotalMemorySize?: number

    /**
     * is the maximum number of vertices a mesh shader output can store.
     */
    readonly maxMeshOutputVertices?: number

    /**
     * is the maximum number of primitives a mesh shader output can store.
     */
    readonly maxMeshOutputPrimitives?: number

    /**
     * is the maximum number of multi-view views a mesh shader can use.
     */
    readonly maxMeshMultiviewViewCount?: number

    /**
     * is the granularity with which mesh vertex outputs are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerVertexGranularity?: number

    /**
     * is the granularity with which mesh outputs qualified as per-primitive are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerPrimitiveGranularity?: number
  }

  declare interface VkPhysicalDeviceMeshShaderPropertiesNVConstructor {
    readonly prototype: VkPhysicalDeviceMeshShaderPropertiesNV
    new (
      param?: VkPhysicalDeviceMeshShaderPropertiesNVInitializer | null
    ): VkPhysicalDeviceMeshShaderPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMeshShaderPropertiesNV: VkPhysicalDeviceMeshShaderPropertiesNVConstructor

  /**
   * Structure describing mesh shading features that can be supported by an implementation
   */
  interface VkPhysicalDeviceMeshShaderFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the task shader stage is supported.
     */
    taskShader: boolean

    /**
     * indicates whether the mesh shader stage is supported.
     */
    meshShader: boolean
  }

  declare interface VkPhysicalDeviceMeshShaderFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the task shader stage is supported.
     */
    taskShader?: boolean

    /**
     * indicates whether the mesh shader stage is supported.
     */
    meshShader?: boolean
  }

  declare interface VkPhysicalDeviceMeshShaderFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceMeshShaderFeaturesNV
    new (
      param?: VkPhysicalDeviceMeshShaderFeaturesNVInitializer | null
    ): VkPhysicalDeviceMeshShaderFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMeshShaderFeaturesNV: VkPhysicalDeviceMeshShaderFeaturesNVConstructor

  /**
   * Structure specifying parameters controlling sample order in coarse fragments
   */
  interface VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies the mechanism used to order coverage samples in fragments larger than one pixel.
     */
    sampleOrderType: VkCoarseSampleOrderTypeNV

    /**
     * specifies the number of custom sample orderings to use when ordering coverage samples.
     */
    customSampleOrderCount: number

    /**
     * is an array of 'customSampleOrderCount' 'VkCoarseSampleOrderCustomNV' structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
     */
    pCustomSampleOrders: VkCoarseSampleOrderCustomNV[] | null
  }

  declare interface VkPipelineViewportCoarseSampleOrderStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies the mechanism used to order coverage samples in fragments larger than one pixel.
     */
    sampleOrderType?: VkCoarseSampleOrderTypeNV

    /**
     * specifies the number of custom sample orderings to use when ordering coverage samples.
     */
    customSampleOrderCount?: number

    /**
     * is an array of 'customSampleOrderCount' 'VkCoarseSampleOrderCustomNV' structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
     */
    pCustomSampleOrders?: VkCoarseSampleOrderCustomNV[] | null
  }

  declare interface VkPipelineViewportCoarseSampleOrderStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
    new (
      param?: VkPipelineViewportCoarseSampleOrderStateCreateInfoNVInitializer | null
    ): VkPipelineViewportCoarseSampleOrderStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineViewportCoarseSampleOrderStateCreateInfoNV: VkPipelineViewportCoarseSampleOrderStateCreateInfoNVConstructor

  /**
   * Structure specifying parameters controlling shading rate image usage
   */
  interface VkCoarseSampleOrderCustomNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a shading rate palette entry that identifies the fragment width and height for the combination of fragment area and per-pixel coverage sample count to control.
     */
    shadingRate: VkShadingRatePaletteEntryNV

    /**
     * identifies the per-pixel coverage sample count for the combination of fragment area and coverage sample count to control.
     */
    sampleCount: number

    /**
     * specifies the number of sample locations in the custom ordering.
     */
    sampleLocationCount: number

    /**
     * is an array of 'VkCoarseSampleOrderCustomNV' structures specifying the location of each sample in the custom ordering.
     */
    pSampleLocations: VkCoarseSampleLocationNV[] | null
  }

  declare interface VkCoarseSampleOrderCustomNVInitializer {
    /**
     * is a shading rate palette entry that identifies the fragment width and height for the combination of fragment area and per-pixel coverage sample count to control.
     */
    shadingRate?: VkShadingRatePaletteEntryNV

    /**
     * identifies the per-pixel coverage sample count for the combination of fragment area and coverage sample count to control.
     */
    sampleCount?: number

    /**
     * specifies the number of sample locations in the custom ordering.
     */
    sampleLocationCount?: number

    /**
     * is an array of 'VkCoarseSampleOrderCustomNV' structures specifying the location of each sample in the custom ordering.
     */
    pSampleLocations?: VkCoarseSampleLocationNV[] | null
  }

  declare interface VkCoarseSampleOrderCustomNVConstructor {
    readonly prototype: VkCoarseSampleOrderCustomNV
    new (
      param?: VkCoarseSampleOrderCustomNVInitializer | null
    ): VkCoarseSampleOrderCustomNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCoarseSampleOrderCustomNV: VkCoarseSampleOrderCustomNVConstructor

  /**
   * Structure specifying parameters controlling shading rate image usage
   */
  interface VkCoarseSampleLocationNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is added to the x coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelX: number

    /**
     * is added to the y coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelY: number

    /**
     * is the number of the coverage sample in the pixel identified by 'pixelX' and 'pixelY'.
     */
    sample: number
  }

  declare interface VkCoarseSampleLocationNVInitializer {
    /**
     * is added to the x coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelX?: number

    /**
     * is added to the y coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelY?: number

    /**
     * is the number of the coverage sample in the pixel identified by 'pixelX' and 'pixelY'.
     */
    sample?: number
  }

  declare interface VkCoarseSampleLocationNVConstructor {
    readonly prototype: VkCoarseSampleLocationNV
    new (
      param?: VkCoarseSampleLocationNVInitializer | null
    ): VkCoarseSampleLocationNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCoarseSampleLocationNV: VkCoarseSampleLocationNVConstructor

  /**
   * Structure describing shading rate image limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceShadingRateImagePropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * indicates the width and height of the portion of the framebuffer corresponding to each texel in the shading rate image.
     */
    readonly shadingRateTexelSize: VkExtent2D | null

    /**
     *
     */
    readonly shadingRatePaletteSize: number

    /**
     *
     */
    readonly shadingRateMaxCoarseSamples: number
  }

  declare interface VkPhysicalDeviceShadingRateImagePropertiesNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * indicates the width and height of the portion of the framebuffer corresponding to each texel in the shading rate image.
     */
    readonly shadingRateTexelSize?: VkExtent2D | null

    /**
     *
     */
    readonly shadingRatePaletteSize?: number

    /**
     *
     */
    readonly shadingRateMaxCoarseSamples?: number
  }

  declare interface VkPhysicalDeviceShadingRateImagePropertiesNVConstructor {
    readonly prototype: VkPhysicalDeviceShadingRateImagePropertiesNV
    new (
      param?: VkPhysicalDeviceShadingRateImagePropertiesNVInitializer | null
    ): VkPhysicalDeviceShadingRateImagePropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShadingRateImagePropertiesNV: VkPhysicalDeviceShadingRateImagePropertiesNVConstructor

  /**
   * Structure describing shading rate image features that can be supported by an implementation
   */
  interface VkPhysicalDeviceShadingRateImageFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports the use of a shading rate image to derive an effective shading rate for fragment processing. It also indicates that the implementation supports the 'ShadingRateNV' SPIR-V execution mode.
     */
    shadingRateImage: boolean

    /**
     * indicates that the implementation supports a user-configurable ordering of coverage samples in fragments larger than one pixel.
     */
    shadingRateCoarseSampleOrder: boolean
  }

  declare interface VkPhysicalDeviceShadingRateImageFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports the use of a shading rate image to derive an effective shading rate for fragment processing. It also indicates that the implementation supports the 'ShadingRateNV' SPIR-V execution mode.
     */
    shadingRateImage?: boolean

    /**
     * indicates that the implementation supports a user-configurable ordering of coverage samples in fragments larger than one pixel.
     */
    shadingRateCoarseSampleOrder?: boolean
  }

  declare interface VkPhysicalDeviceShadingRateImageFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceShadingRateImageFeaturesNV
    new (
      param?: VkPhysicalDeviceShadingRateImageFeaturesNVInitializer | null
    ): VkPhysicalDeviceShadingRateImageFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShadingRateImageFeaturesNV: VkPhysicalDeviceShadingRateImageFeaturesNVConstructor

  /**
   * Structure specifying parameters controlling shading rate image usage
   */
  interface VkPipelineViewportShadingRateImageStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether shading rate image and palettes are used during rasterization.
     */
    shadingRateImageEnable: boolean

    /**
     * specifies the number of per-viewport palettes used to translate values stored in shading rate images.
     */
    viewportCount: number

    /**
     * is an array of 'VkShadingRatePaletteNV' structures defining the palette for each viewport. If the shading rate palette state is dynamic, this member is ignored.
     */
    pShadingRatePalettes: VkShadingRatePaletteNV[] | null
  }

  declare interface VkPipelineViewportShadingRateImageStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether shading rate image and palettes are used during rasterization.
     */
    shadingRateImageEnable?: boolean

    /**
     * specifies the number of per-viewport palettes used to translate values stored in shading rate images.
     */
    viewportCount?: number

    /**
     * is an array of 'VkShadingRatePaletteNV' structures defining the palette for each viewport. If the shading rate palette state is dynamic, this member is ignored.
     */
    pShadingRatePalettes?: VkShadingRatePaletteNV[] | null
  }

  declare interface VkPipelineViewportShadingRateImageStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineViewportShadingRateImageStateCreateInfoNV
    new (
      param?: VkPipelineViewportShadingRateImageStateCreateInfoNVInitializer | null
    ): VkPipelineViewportShadingRateImageStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineViewportShadingRateImageStateCreateInfoNV: VkPipelineViewportShadingRateImageStateCreateInfoNVConstructor

  /**
   * Structure specifying a single shading rate palette
   */
  interface VkShadingRatePaletteNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * specifies the number of entries in the shading rate image palette.
     */
    shadingRatePaletteEntryCount: number

    /**
     * is an array of 'VkShadingRatePaletteEntryNV' enums defining the shading rate for each palette entry.
     */
    pShadingRatePaletteEntries: Int32Array | null
  }

  declare interface VkShadingRatePaletteNVInitializer {
    /**
     * specifies the number of entries in the shading rate image palette.
     */
    shadingRatePaletteEntryCount?: number

    /**
     * is an array of 'VkShadingRatePaletteEntryNV' enums defining the shading rate for each palette entry.
     */
    pShadingRatePaletteEntries?: Int32Array | null
  }

  declare interface VkShadingRatePaletteNVConstructor {
    readonly prototype: VkShadingRatePaletteNV
    new (
      param?: VkShadingRatePaletteNVInitializer | null
    ): VkShadingRatePaletteNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkShadingRatePaletteNV: VkShadingRatePaletteNVConstructor

  /**
   * Structure describing dedicated allocation image aliasing features that can be supported by an implementation
   */
  interface VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    dedicatedAllocationImageAliasing: boolean
  }

  declare interface VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    dedicatedAllocationImageAliasing?: boolean
  }

  declare interface VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
    new (
      param?: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVInitializer | null
    ): VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVConstructor

  /**
   * Structure describing shader image footprint features that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderImageFootprintFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * specifies whether the implementation supports the 'ImageFootprintNV' SPIR-V capability.
     */
    imageFootprint: boolean
  }

  declare interface VkPhysicalDeviceShaderImageFootprintFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * specifies whether the implementation supports the 'ImageFootprintNV' SPIR-V capability.
     */
    imageFootprint?: boolean
  }

  declare interface VkPhysicalDeviceShaderImageFootprintFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceShaderImageFootprintFeaturesNV
    new (
      param?: VkPhysicalDeviceShaderImageFootprintFeaturesNVInitializer | null
    ): VkPhysicalDeviceShaderImageFootprintFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderImageFootprintFeaturesNV: VkPhysicalDeviceShaderImageFootprintFeaturesNVConstructor

  /**
   * Structure describing barycentric support in fragment shaders that can be supported by an implementation
   */
  interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports the 'BaryCoordNV' and 'BaryCoordNoPerspNV' SPIR-V fragment shader built-ins and supports the 'PerVertexNV' SPIR-V decoration on fragment shader input variables.
     */
    fragmentShaderBarycentric: boolean
  }

  declare interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports the 'BaryCoordNV' and 'BaryCoordNoPerspNV' SPIR-V fragment shader built-ins and supports the 'PerVertexNV' SPIR-V decoration on fragment shader input variables.
     */
    fragmentShaderBarycentric?: boolean
  }

  declare interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
    new (
      param?: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVInitializer | null
    ): VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVConstructor

  /**
   * Structure describing compute shader derivative features that can be supported by an implementation
   */
  interface VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    computeDerivativeGroupQuads: boolean

    /**
     *
     */
    computeDerivativeGroupLinear: boolean
  }

  declare interface VkPhysicalDeviceComputeShaderDerivativesFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    computeDerivativeGroupQuads?: boolean

    /**
     *
     */
    computeDerivativeGroupLinear?: boolean
  }

  declare interface VkPhysicalDeviceComputeShaderDerivativesFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
    new (
      param?: VkPhysicalDeviceComputeShaderDerivativesFeaturesNVInitializer | null
    ): VkPhysicalDeviceComputeShaderDerivativesFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceComputeShaderDerivativesFeaturesNV: VkPhysicalDeviceComputeShaderDerivativesFeaturesNVConstructor

  /**
   * Structure describing corner sampled image features that can be supported by an implementation
   */
  interface VkPhysicalDeviceCornerSampledImageFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * specifies whether images can be created with a 'VkImageCreateInfo'::'flags' containing 'VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV'. See <<resources-images-corner-sampled,Corner-Sampled Images>>.
     */
    cornerSampledImage: boolean
  }

  declare interface VkPhysicalDeviceCornerSampledImageFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * specifies whether images can be created with a 'VkImageCreateInfo'::'flags' containing 'VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV'. See <<resources-images-corner-sampled,Corner-Sampled Images>>.
     */
    cornerSampledImage?: boolean
  }

  declare interface VkPhysicalDeviceCornerSampledImageFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceCornerSampledImageFeaturesNV
    new (
      param?: VkPhysicalDeviceCornerSampledImageFeaturesNVInitializer | null
    ): VkPhysicalDeviceCornerSampledImageFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceCornerSampledImageFeaturesNV: VkPhysicalDeviceCornerSampledImageFeaturesNVConstructor

  /**
   * Structure specifying parameters controlling exclusive scissor testing
   */
  interface VkPipelineViewportExclusiveScissorStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of exclusive scissor rectangles used by the pipeline.
     */
    exclusiveScissorCount: number

    /**
     * is an array of 'VkRect2D' structures defining exclusive scissor rectangles. If the exclusive scissor state is dynamic, this member is ignored.
     */
    pExclusiveScissors: VkRect2D[] | null
  }

  declare interface VkPipelineViewportExclusiveScissorStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of exclusive scissor rectangles used by the pipeline.
     */
    exclusiveScissorCount?: number

    /**
     * is an array of 'VkRect2D' structures defining exclusive scissor rectangles. If the exclusive scissor state is dynamic, this member is ignored.
     */
    pExclusiveScissors?: VkRect2D[] | null
  }

  declare interface VkPipelineViewportExclusiveScissorStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineViewportExclusiveScissorStateCreateInfoNV
    new (
      param?: VkPipelineViewportExclusiveScissorStateCreateInfoNVInitializer | null
    ): VkPipelineViewportExclusiveScissorStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineViewportExclusiveScissorStateCreateInfoNV: VkPipelineViewportExclusiveScissorStateCreateInfoNVConstructor

  /**
   * Structure describing exclusive scissor features that can be supported by an implementation
   */
  interface VkPhysicalDeviceExclusiveScissorFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports the exclusive scissor test.
     */
    exclusiveScissor: boolean
  }

  declare interface VkPhysicalDeviceExclusiveScissorFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports the exclusive scissor test.
     */
    exclusiveScissor?: boolean
  }

  declare interface VkPhysicalDeviceExclusiveScissorFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceExclusiveScissorFeaturesNV
    new (
      param?: VkPhysicalDeviceExclusiveScissorFeaturesNVInitializer | null
    ): VkPhysicalDeviceExclusiveScissorFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExclusiveScissorFeaturesNV: VkPhysicalDeviceExclusiveScissorFeaturesNVConstructor

  /**
   * Structure specifying representative fragment test
   */
  interface VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * controls whether the representative fragment test is enabled.
     */
    representativeFragmentTestEnable: boolean
  }

  declare interface VkPipelineRepresentativeFragmentTestStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * controls whether the representative fragment test is enabled.
     */
    representativeFragmentTestEnable?: boolean
  }

  declare interface VkPipelineRepresentativeFragmentTestStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineRepresentativeFragmentTestStateCreateInfoNV
    new (
      param?: VkPipelineRepresentativeFragmentTestStateCreateInfoNVInitializer | null
    ): VkPipelineRepresentativeFragmentTestStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRepresentativeFragmentTestStateCreateInfoNV: VkPipelineRepresentativeFragmentTestStateCreateInfoNVConstructor

  /**
   * Structure describing the representative fragment test features that can be supported by an implementation
   */
  interface VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports the representative fragment test. See <<fragops-rep-frag-test, Representative Fragment Test>>.
     */
    representativeFragmentTest: boolean
  }

  declare interface VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports the representative fragment test. See <<fragops-rep-frag-test, Representative Fragment Test>>.
     */
    representativeFragmentTest?: boolean
  }

  declare interface VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVConstructor {
    readonly prototype: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
    new (
      param?: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVInitializer | null
    ): VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVConstructor

  /**
   * Structure defining the geometry stream used for rasterization
   */
  interface VkPipelineRasterizationStateStreamCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the vertex stream selected for rasterization.
     */
    rasterizationStream: number
  }

  declare interface VkPipelineRasterizationStateStreamCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the vertex stream selected for rasterization.
     */
    rasterizationStream?: number
  }

  declare interface VkPipelineRasterizationStateStreamCreateInfoEXTConstructor {
    readonly prototype: VkPipelineRasterizationStateStreamCreateInfoEXT
    new (
      param?: VkPipelineRasterizationStateStreamCreateInfoEXTInitializer | null
    ): VkPipelineRasterizationStateStreamCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRasterizationStateStreamCreateInfoEXT: VkPipelineRasterizationStateStreamCreateInfoEXTConstructor

  /**
   * Structure describing transform feedback properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum number of vertex streams that can be output from geometry shaders declared with the 'GeometryStreams' capability. If the implementation does not support 'VkPhysicalDeviceTransformFeedbackFeaturesEXT'::'geometryStreams' then 'maxTransformFeedbackStreams' 'must' be set to `1`.
     */
    readonly maxTransformFeedbackStreams: number

    /**
     *
     */
    readonly maxTransformFeedbackBuffers: number

    /**
     *
     */
    readonly maxTransformFeedbackBufferSize: bigint | number

    /**
     *
     */
    readonly maxTransformFeedbackStreamDataSize: number

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataSize: number

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataStride: number

    /**
     *
     */
    readonly transformFeedbackQueries: boolean

    /**
     *
     */
    readonly transformFeedbackStreamsLinesTriangles: boolean

    /**
     *
     */
    readonly transformFeedbackRasterizationStreamSelect: boolean

    /**
     *
     */
    readonly transformFeedbackDraw: boolean
  }

  declare interface VkPhysicalDeviceTransformFeedbackPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum number of vertex streams that can be output from geometry shaders declared with the 'GeometryStreams' capability. If the implementation does not support 'VkPhysicalDeviceTransformFeedbackFeaturesEXT'::'geometryStreams' then 'maxTransformFeedbackStreams' 'must' be set to `1`.
     */
    readonly maxTransformFeedbackStreams?: number

    /**
     *
     */
    readonly maxTransformFeedbackBuffers?: number

    /**
     *
     */
    readonly maxTransformFeedbackBufferSize?: bigint | number

    /**
     *
     */
    readonly maxTransformFeedbackStreamDataSize?: number

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataSize?: number

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataStride?: number

    /**
     *
     */
    readonly transformFeedbackQueries?: boolean

    /**
     *
     */
    readonly transformFeedbackStreamsLinesTriangles?: boolean

    /**
     *
     */
    readonly transformFeedbackRasterizationStreamSelect?: boolean

    /**
     *
     */
    readonly transformFeedbackDraw?: boolean
  }

  declare interface VkPhysicalDeviceTransformFeedbackPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceTransformFeedbackPropertiesEXT
    new (
      param?: VkPhysicalDeviceTransformFeedbackPropertiesEXTInitializer | null
    ): VkPhysicalDeviceTransformFeedbackPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTransformFeedbackPropertiesEXT: VkPhysicalDeviceTransformFeedbackPropertiesEXTConstructor

  /**
   * Structure describing transform feedback features that can be supported by an implementation
   */
  interface VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports transform feedback and shader modules 'can' declare the 'TransformFeedback' capability.
     */
    transformFeedback: boolean

    /**
     *
     */
    geometryStreams: boolean
  }

  declare interface VkPhysicalDeviceTransformFeedbackFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports transform feedback and shader modules 'can' declare the 'TransformFeedback' capability.
     */
    transformFeedback?: boolean

    /**
     *
     */
    geometryStreams?: boolean
  }

  declare interface VkPhysicalDeviceTransformFeedbackFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceTransformFeedbackFeaturesEXT
    new (
      param?: VkPhysicalDeviceTransformFeedbackFeaturesEXTInitializer | null
    ): VkPhysicalDeviceTransformFeedbackFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTransformFeedbackFeaturesEXT: VkPhysicalDeviceTransformFeedbackFeaturesEXTConstructor

  /**
   * Structure describing ASTC decode mode features
   */
  interface VkPhysicalDeviceASTCDecodeFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    decodeModeSharedExponent: boolean
  }

  declare interface VkPhysicalDeviceASTCDecodeFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    decodeModeSharedExponent?: boolean
  }

  declare interface VkPhysicalDeviceASTCDecodeFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceASTCDecodeFeaturesEXT
    new (
      param?: VkPhysicalDeviceASTCDecodeFeaturesEXTInitializer | null
    ): VkPhysicalDeviceASTCDecodeFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceASTCDecodeFeaturesEXT: VkPhysicalDeviceASTCDecodeFeaturesEXTConstructor

  /**
   * Structure describing the ASTC decode mode for an image view
   */
  interface VkImageViewASTCDecodeModeEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the intermediate format used to decode ASTC compressed formats.
     */
    decodeMode: VkFormat
  }

  declare interface VkImageViewASTCDecodeModeEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the intermediate format used to decode ASTC compressed formats.
     */
    decodeMode?: VkFormat
  }

  declare interface VkImageViewASTCDecodeModeEXTConstructor {
    readonly prototype: VkImageViewASTCDecodeModeEXT
    new (
      param?: VkImageViewASTCDecodeModeEXTInitializer | null
    ): VkImageViewASTCDecodeModeEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageViewASTCDecodeModeEXT: VkImageViewASTCDecodeModeEXTConstructor

  /**
   * Structure specifying depth/stencil resolve operations for a subpass
   */
  interface VkSubpassDescriptionDepthStencilResolveKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' describing the depth resolve mode.
     */
    depthResolveMode: VkResolveModeFlagBitsKHR

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' describing the stencil resolve mode.
     */
    stencilResolveMode: VkResolveModeFlagBitsKHR

    /**
     * is an optional 'VkAttachmentReference' structure defining the depth/stencil resolve attachment for this subpass and its layout.
     */
    pDepthStencilResolveAttachment: VkAttachmentReference2KHR | null
  }

  declare interface VkSubpassDescriptionDepthStencilResolveKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' describing the depth resolve mode.
     */
    depthResolveMode?: VkResolveModeFlagBitsKHR

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' describing the stencil resolve mode.
     */
    stencilResolveMode?: VkResolveModeFlagBitsKHR

    /**
     * is an optional 'VkAttachmentReference' structure defining the depth/stencil resolve attachment for this subpass and its layout.
     */
    pDepthStencilResolveAttachment?: VkAttachmentReference2KHR | null
  }

  declare interface VkSubpassDescriptionDepthStencilResolveKHRConstructor {
    readonly prototype: VkSubpassDescriptionDepthStencilResolveKHR
    new (
      param?: VkSubpassDescriptionDepthStencilResolveKHRInitializer | null
    ): VkSubpassDescriptionDepthStencilResolveKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassDescriptionDepthStencilResolveKHR: VkSubpassDescriptionDepthStencilResolveKHRConstructor

  /**
   * Structure describing depth/stencil resolve properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' indicating the set of supported depth resolve modes. 'VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR' 'must' be included in the set but implementations 'may' support additional modes.
     */
    readonly supportedDepthResolveModes: VkResolveModeFlagBitsKHR

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' indicating the set of supported stencil resolve modes. 'VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR' 'must' be included in the set but implementations 'may' support additional modes. 'VK_RESOLVE_MODE_AVERAGE_BIT_KHR' 'must' not be included in the set.
     */
    readonly supportedStencilResolveModes: VkResolveModeFlagBitsKHR

    /**
     * is 'VK_TRUE' if the implementation supports setting the depth and stencil resolve modes to different values when one of those modes is 'VK_RESOLVE_MODE_NONE_KHR'. Otherwise the implementation only supports setting both modes to the same value.
     */
    readonly independentResolveNone: boolean

    /**
     * is 'VK_TRUE' if the implementation supports all combinations of the supported depth and stencil resolve modes, including setting either depth or stencil resolve mode to 'VK_RESOLVE_MODE_NONE_KHR'. An implementation that supports 'independentResolve' 'must' also support 'independentResolveNone'.
     */
    readonly independentResolve: boolean
  }

  declare interface VkPhysicalDeviceDepthStencilResolvePropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' indicating the set of supported depth resolve modes. 'VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR' 'must' be included in the set but implementations 'may' support additional modes.
     */
    readonly supportedDepthResolveModes?: VkResolveModeFlagBitsKHR

    /**
     * is a bitmask of 'VkResolveModeFlagBitsKHR' indicating the set of supported stencil resolve modes. 'VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR' 'must' be included in the set but implementations 'may' support additional modes. 'VK_RESOLVE_MODE_AVERAGE_BIT_KHR' 'must' not be included in the set.
     */
    readonly supportedStencilResolveModes?: VkResolveModeFlagBitsKHR

    /**
     * is 'VK_TRUE' if the implementation supports setting the depth and stencil resolve modes to different values when one of those modes is 'VK_RESOLVE_MODE_NONE_KHR'. Otherwise the implementation only supports setting both modes to the same value.
     */
    readonly independentResolveNone?: boolean

    /**
     * is 'VK_TRUE' if the implementation supports all combinations of the supported depth and stencil resolve modes, including setting either depth or stencil resolve mode to 'VK_RESOLVE_MODE_NONE_KHR'. An implementation that supports 'independentResolve' 'must' also support 'independentResolveNone'.
     */
    readonly independentResolve?: boolean
  }

  declare interface VkPhysicalDeviceDepthStencilResolvePropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceDepthStencilResolvePropertiesKHR
    new (
      param?: VkPhysicalDeviceDepthStencilResolvePropertiesKHRInitializer | null
    ): VkPhysicalDeviceDepthStencilResolvePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDepthStencilResolvePropertiesKHR: VkPhysicalDeviceDepthStencilResolvePropertiesKHRConstructor

  /**
   * return structure for command buffer checkpoint data
   */
  interface VkCheckpointDataNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * indicates which pipeline stage the checkpoint marker data refers to.
     */
    readonly stage: VkPipelineStageFlagBits

    /**
     * contains the value of the last checkpoint marker executed in the stage that 'stage' refers to.
     */
    readonly pCheckpointMarker: ArrayBuffer | null
  }

  declare interface VkCheckpointDataNVInitializer {
    /**
     * is the type of this structure
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * indicates which pipeline stage the checkpoint marker data refers to.
     */
    readonly stage?: VkPipelineStageFlagBits

    /**
     * contains the value of the last checkpoint marker executed in the stage that 'stage' refers to.
     */
    readonly pCheckpointMarker?: ArrayBuffer | null
  }

  declare interface VkCheckpointDataNVConstructor {
    readonly prototype: VkCheckpointDataNV
    new (param?: VkCheckpointDataNVInitializer | null): VkCheckpointDataNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCheckpointDataNV: VkCheckpointDataNVConstructor

  /**
   * return structure for queue family checkpoint info query
   */
  interface VkQueueFamilyCheckpointPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a mask indicating which pipeline stages the implementation can execute checkpoint markers in.
     */
    readonly checkpointExecutionStageMask: VkPipelineStageFlagBits
  }

  declare interface VkQueueFamilyCheckpointPropertiesNVInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a mask indicating which pipeline stages the implementation can execute checkpoint markers in.
     */
    readonly checkpointExecutionStageMask?: VkPipelineStageFlagBits
  }

  declare interface VkQueueFamilyCheckpointPropertiesNVConstructor {
    readonly prototype: VkQueueFamilyCheckpointPropertiesNV
    new (
      param?: VkQueueFamilyCheckpointPropertiesNVInitializer | null
    ): VkQueueFamilyCheckpointPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkQueueFamilyCheckpointPropertiesNV: VkQueueFamilyCheckpointPropertiesNVConstructor

  /**
   * Structure describing if fetching of vertex attribute may be repeated for instanced rendering
   */
  interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether vertex attribute fetching may be repeated in case of instanced rendering.
     */
    vertexAttributeInstanceRateDivisor: boolean

    /**
     * specifies whether a zero value for 'VkVertexInputBindingDivisorDescriptionEXT'::'divisor' is supported.
     */
    vertexAttributeInstanceRateZeroDivisor: boolean
  }

  declare interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether vertex attribute fetching may be repeated in case of instanced rendering.
     */
    vertexAttributeInstanceRateDivisor?: boolean

    /**
     * specifies whether a zero value for 'VkVertexInputBindingDivisorDescriptionEXT'::'divisor' is supported.
     */
    vertexAttributeInstanceRateZeroDivisor?: boolean
  }

  declare interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
    new (
      param?: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInitializer | null
    ): VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTConstructor

  /**
   * Structure describing features supported by VK_KHR_shader_atomic_int64
   */
  interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * indicates whether shaders 'can' support 64-bit unsigned and signed integer atomic operations on buffers.
     */
    shaderBufferInt64Atomics: boolean

    /**
     * indicates whether shaders 'can' support 64-bit unsigned and signed integer atomic operations on shared memory.
     */
    shaderSharedInt64Atomics: boolean
  }

  declare interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * indicates whether shaders 'can' support 64-bit unsigned and signed integer atomic operations on buffers.
     */
    shaderBufferInt64Atomics?: boolean

    /**
     * indicates whether shaders 'can' support 64-bit unsigned and signed integer atomic operations on shared memory.
     */
    shaderSharedInt64Atomics?: boolean
  }

  declare interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
    new (
      param?: VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInitializer | null
    ): VkPhysicalDeviceShaderAtomicInt64FeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderAtomicInt64FeaturesKHR: VkPhysicalDeviceShaderAtomicInt64FeaturesKHRConstructor

  /**
   * Structure describing features supported by VK_KHR_vulkan_memory_model
   */
  interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * indicates whether the Vulkan Memory Model is supported, as defined in <<memory-model,Vulkan Memory Model>>. This also indicates whether shader modules 'can' declare the 'VulkanMemoryModelKHR' capability.
     */
    vulkanMemoryModel: boolean

    /**
     * indicates whether the Vulkan Memory Model can use 'Device' scope synchronization. This also indicates whether shader modules 'can' declare the 'VulkanMemoryModelDeviceScopeKHR' capability.
     */
    vulkanMemoryModelDeviceScope: boolean

    /**
     * indicates whether the Vulkan Memory Model can use <<memory-model-availability-visibility, availability and visibility chains>> with more than one element.
     */
    vulkanMemoryModelAvailabilityVisibilityChains: boolean
  }

  declare interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * indicates whether the Vulkan Memory Model is supported, as defined in <<memory-model,Vulkan Memory Model>>. This also indicates whether shader modules 'can' declare the 'VulkanMemoryModelKHR' capability.
     */
    vulkanMemoryModel?: boolean

    /**
     * indicates whether the Vulkan Memory Model can use 'Device' scope synchronization. This also indicates whether shader modules 'can' declare the 'VulkanMemoryModelDeviceScopeKHR' capability.
     */
    vulkanMemoryModelDeviceScope?: boolean

    /**
     * indicates whether the Vulkan Memory Model can use <<memory-model-availability-visibility, availability and visibility chains>> with more than one element.
     */
    vulkanMemoryModelAvailabilityVisibilityChains?: boolean
  }

  declare interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
    new (
      param?: VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInitializer | null
    ): VkPhysicalDeviceVulkanMemoryModelFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVulkanMemoryModelFeaturesKHR: VkPhysicalDeviceVulkanMemoryModelFeaturesKHRConstructor

  /**
   * Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer
   */
  interface VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether conditional rendering is supported.
     */
    conditionalRendering: boolean

    /**
     * specifies whether a secondary command buffer 'can' be executed while conditional rendering is active in the primary command buffer.
     */
    inheritedConditionalRendering: boolean
  }

  declare interface VkPhysicalDeviceConditionalRenderingFeaturesEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether conditional rendering is supported.
     */
    conditionalRendering?: boolean

    /**
     * specifies whether a secondary command buffer 'can' be executed while conditional rendering is active in the primary command buffer.
     */
    inheritedConditionalRendering?: boolean
  }

  declare interface VkPhysicalDeviceConditionalRenderingFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceConditionalRenderingFeaturesEXT
    new (
      param?: VkPhysicalDeviceConditionalRenderingFeaturesEXTInitializer | null
    ): VkPhysicalDeviceConditionalRenderingFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceConditionalRenderingFeaturesEXT: VkPhysicalDeviceConditionalRenderingFeaturesEXTConstructor

  /**
   * Structure describing features supported by VK_KHR_8bit_storage
   */
  interface VkPhysicalDevice8BitStorageFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * indicates whether objects in the 'StorageBuffer' or 'PhysicalStorageBufferEXT'
     */
    storageBuffer8BitAccess: boolean

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess: boolean

    /**
     *
     */
    storagePushConstant8: boolean
  }

  declare interface VkPhysicalDevice8BitStorageFeaturesKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * indicates whether objects in the 'StorageBuffer' or 'PhysicalStorageBufferEXT'
     */
    storageBuffer8BitAccess?: boolean

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess?: boolean

    /**
     *
     */
    storagePushConstant8?: boolean
  }

  declare interface VkPhysicalDevice8BitStorageFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDevice8BitStorageFeaturesKHR
    new (
      param?: VkPhysicalDevice8BitStorageFeaturesKHRInitializer | null
    ): VkPhysicalDevice8BitStorageFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevice8BitStorageFeaturesKHR: VkPhysicalDevice8BitStorageFeaturesKHRConstructor

  /**
   * Structure specifying command buffer inheritance info
   */
  interface VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure
     */
    pNext: null

    /**
     * specifies whether the command buffer 'can' be executed while conditional rendering is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has active conditional rendering or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have conditional rendering active.
     */
    conditionalRenderingEnable: boolean
  }

  declare interface VkCommandBufferInheritanceConditionalRenderingInfoEXTInitializer {
    /**
     * is the type of this structure
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure
     */
    pNext?: null

    /**
     * specifies whether the command buffer 'can' be executed while conditional rendering is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has active conditional rendering or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have conditional rendering active.
     */
    conditionalRenderingEnable?: boolean
  }

  declare interface VkCommandBufferInheritanceConditionalRenderingInfoEXTConstructor {
    readonly prototype: VkCommandBufferInheritanceConditionalRenderingInfoEXT
    new (
      param?: VkCommandBufferInheritanceConditionalRenderingInfoEXTInitializer | null
    ): VkCommandBufferInheritanceConditionalRenderingInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCommandBufferInheritanceConditionalRenderingInfoEXT: VkCommandBufferInheritanceConditionalRenderingInfoEXTConstructor

  /**
   * Structure containing PCI bus information of a physical device
   */
  interface VkPhysicalDevicePCIBusInfoPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the PCI bus domain.
     */
    readonly pciDomain: number

    /**
     * is the PCI bus identifier.
     */
    readonly pciBus: number

    /**
     * is the PCI device identifier.
     */
    readonly pciDevice: number

    /**
     * is the PCI device function identifier.
     */
    readonly pciFunction: number
  }

  declare interface VkPhysicalDevicePCIBusInfoPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the PCI bus domain.
     */
    readonly pciDomain?: number

    /**
     * is the PCI bus identifier.
     */
    readonly pciBus?: number

    /**
     * is the PCI device identifier.
     */
    readonly pciDevice?: number

    /**
     * is the PCI device function identifier.
     */
    readonly pciFunction?: number
  }

  declare interface VkPhysicalDevicePCIBusInfoPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDevicePCIBusInfoPropertiesEXT
    new (
      param?: VkPhysicalDevicePCIBusInfoPropertiesEXTInitializer | null
    ): VkPhysicalDevicePCIBusInfoPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevicePCIBusInfoPropertiesEXT: VkPhysicalDevicePCIBusInfoPropertiesEXTConstructor

  /**
   * Structure describing max value of vertex attribute divisor that can be supported by an implementation
   */
  interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled.
     */
    readonly maxVertexAttribDivisor: number
  }

  declare interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled.
     */
    readonly maxVertexAttribDivisor?: number
  }

  declare interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
    new (
      param?: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInitializer | null
    ): VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTConstructor

  /**
   * Structure specifying vertex attributes assignment during instanced rendering
   */
  interface VkPipelineVertexInputDivisorStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure
     */
    pNext: null

    /**
     * is the number of elements in the 'pVertexBindingDivisors' array.
     */
    vertexBindingDivisorCount: number

    /**
     * is an array of 'VkVertexInputBindingDivisorDescriptionEXT' structures, which specifies the divisor value for each binding.
     */
    pVertexBindingDivisors: VkVertexInputBindingDivisorDescriptionEXT[] | null
  }

  declare interface VkPipelineVertexInputDivisorStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure
     */
    pNext?: null

    /**
     * is the number of elements in the 'pVertexBindingDivisors' array.
     */
    vertexBindingDivisorCount?: number

    /**
     * is an array of 'VkVertexInputBindingDivisorDescriptionEXT' structures, which specifies the divisor value for each binding.
     */
    pVertexBindingDivisors?: VkVertexInputBindingDivisorDescriptionEXT[] | null
  }

  declare interface VkPipelineVertexInputDivisorStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineVertexInputDivisorStateCreateInfoEXT
    new (
      param?: VkPipelineVertexInputDivisorStateCreateInfoEXTInitializer | null
    ): VkPipelineVertexInputDivisorStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineVertexInputDivisorStateCreateInfoEXT: VkPipelineVertexInputDivisorStateCreateInfoEXTConstructor

  /**
   * Structure specifying a divisor used in instanced rendering
   */
  interface VkVertexInputBindingDivisorDescriptionEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the binding number for which the divisor is specified.
     */
    binding: number

    /**
     * is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT'::'maxVertexAttribDivisor'. A value of `0` 'can' be used for the divisor if the <<features-vertexAttributeInstanceRateZeroDivisor,'vertexAttributeInstanceRateZeroDivisor'>> feature is enabled. In this case, the same vertex attribute will be applied to all instances.
     */
    divisor: number
  }

  declare interface VkVertexInputBindingDivisorDescriptionEXTInitializer {
    /**
     * is the binding number for which the divisor is specified.
     */
    binding?: number

    /**
     * is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT'::'maxVertexAttribDivisor'. A value of `0` 'can' be used for the divisor if the <<features-vertexAttributeInstanceRateZeroDivisor,'vertexAttributeInstanceRateZeroDivisor'>> feature is enabled. In this case, the same vertex attribute will be applied to all instances.
     */
    divisor?: number
  }

  declare interface VkVertexInputBindingDivisorDescriptionEXTConstructor {
    readonly prototype: VkVertexInputBindingDivisorDescriptionEXT
    new (
      param?: VkVertexInputBindingDivisorDescriptionEXTInitializer | null
    ): VkVertexInputBindingDivisorDescriptionEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkVertexInputBindingDivisorDescriptionEXT: VkVertexInputBindingDivisorDescriptionEXTConstructor

  /**
   * Structure containing information about a semaphore signal operation
   */
  interface VkSemaphoreSignalInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the handle of the semaphore to signal.
     */
    semaphore: VkSemaphore | null

    /**
     * is the value to signal.
     */
    value: bigint | number
  }

  declare interface VkSemaphoreSignalInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the handle of the semaphore to signal.
     */
    semaphore?: VkSemaphore | null

    /**
     * is the value to signal.
     */
    value?: bigint | number
  }

  declare interface VkSemaphoreSignalInfoKHRConstructor {
    readonly prototype: VkSemaphoreSignalInfoKHR
    new (
      param?: VkSemaphoreSignalInfoKHRInitializer | null
    ): VkSemaphoreSignalInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSemaphoreSignalInfoKHR: VkSemaphoreSignalInfoKHRConstructor

  /**
   * Structure containing information about the semaphore wait condition
   */
  interface VkSemaphoreWaitInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkSemaphoreWaitFlagBitsKHR' specifying additional parameters for the semaphore wait operation.
     */
    flags: VkSemaphoreWaitFlagBitsKHR

    /**
     * timeline semaphore values.
     */
    semaphoreCount: number

    /**
     *
     */
    pSemaphores: VkSemaphore[] | null

    /**
     *
     */
    pValues: BigUint64Array | null
  }

  declare interface VkSemaphoreWaitInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkSemaphoreWaitFlagBitsKHR' specifying additional parameters for the semaphore wait operation.
     */
    flags?: VkSemaphoreWaitFlagBitsKHR

    /**
     * timeline semaphore values.
     */
    semaphoreCount?: number

    /**
     *
     */
    pSemaphores?: VkSemaphore[] | null

    /**
     *
     */
    pValues?: BigUint64Array | null
  }

  declare interface VkSemaphoreWaitInfoKHRConstructor {
    readonly prototype: VkSemaphoreWaitInfoKHR
    new (
      param?: VkSemaphoreWaitInfoKHRInitializer | null
    ): VkSemaphoreWaitInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSemaphoreWaitInfoKHR: VkSemaphoreWaitInfoKHRConstructor

  /**
   * Structure specifying signal and wait values for timeline semaphores
   */
  interface VkTimelineSemaphoreSubmitInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of semaphore wait values specified in 'pWaitSemaphoreValues'.
     */
    waitSemaphoreValueCount: number

    /**
     * is an array of length 'waitSemaphoreValueCount' containing values for the corresponding semaphores in 'VkSubmitInfo'::'pWaitSemaphores' to wait for.
     */
    pWaitSemaphoreValues: BigUint64Array | null

    /**
     * is the number of semaphore signal values specified in 'pSignalSemaphoreValues'.
     */
    signalSemaphoreValueCount: number

    /**
     * is an array of length 'signalSemaphoreValueCount' containing values for the corresponding semaphores in 'VkSubmitInfo'::'pSignalSemaphores' to set when signaled.
     */
    pSignalSemaphoreValues: BigUint64Array | null
  }

  declare interface VkTimelineSemaphoreSubmitInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of semaphore wait values specified in 'pWaitSemaphoreValues'.
     */
    waitSemaphoreValueCount?: number

    /**
     * is an array of length 'waitSemaphoreValueCount' containing values for the corresponding semaphores in 'VkSubmitInfo'::'pWaitSemaphores' to wait for.
     */
    pWaitSemaphoreValues?: BigUint64Array | null

    /**
     * is the number of semaphore signal values specified in 'pSignalSemaphoreValues'.
     */
    signalSemaphoreValueCount?: number

    /**
     * is an array of length 'signalSemaphoreValueCount' containing values for the corresponding semaphores in 'VkSubmitInfo'::'pSignalSemaphores' to set when signaled.
     */
    pSignalSemaphoreValues?: BigUint64Array | null
  }

  declare interface VkTimelineSemaphoreSubmitInfoKHRConstructor {
    readonly prototype: VkTimelineSemaphoreSubmitInfoKHR
    new (
      param?: VkTimelineSemaphoreSubmitInfoKHRInitializer | null
    ): VkTimelineSemaphoreSubmitInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkTimelineSemaphoreSubmitInfoKHR: VkTimelineSemaphoreSubmitInfoKHRConstructor

  /**
   * Structure specifying the type of a newly created semaphore
   */
  interface VkSemaphoreTypeCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is 'VK_SEMAPHORE_TYPE_TIMELINE_KHR'.
     */
    semaphoreType: VkSemaphoreTypeKHR

    /**
     *
     */
    initialValue: bigint | number
  }

  declare interface VkSemaphoreTypeCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is 'VK_SEMAPHORE_TYPE_TIMELINE_KHR'.
     */
    semaphoreType?: VkSemaphoreTypeKHR

    /**
     *
     */
    initialValue?: bigint | number
  }

  declare interface VkSemaphoreTypeCreateInfoKHRConstructor {
    readonly prototype: VkSemaphoreTypeCreateInfoKHR
    new (
      param?: VkSemaphoreTypeCreateInfoKHRInitializer | null
    ): VkSemaphoreTypeCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSemaphoreTypeCreateInfoKHR: VkSemaphoreTypeCreateInfoKHRConstructor

  /**
   * Structure describing timeline semaphore properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceTimelineSemaphorePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference: bigint | number
  }

  declare interface VkPhysicalDeviceTimelineSemaphorePropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference?: bigint | number
  }

  declare interface VkPhysicalDeviceTimelineSemaphorePropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceTimelineSemaphorePropertiesKHR
    new (
      param?: VkPhysicalDeviceTimelineSemaphorePropertiesKHRInitializer | null
    ): VkPhysicalDeviceTimelineSemaphorePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTimelineSemaphorePropertiesKHR: VkPhysicalDeviceTimelineSemaphorePropertiesKHRConstructor

  /**
   * Structure describing timeline semaphore features that can be supported by an implementation
   */
  interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether semaphores created with a 'VkSemaphoreTypeKHR' of 'VK_SEMAPHORE_TYPE_TIMELINE_KHR' are supported.
     */
    timelineSemaphore: boolean
  }

  declare interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether semaphores created with a 'VkSemaphoreTypeKHR' of 'VK_SEMAPHORE_TYPE_TIMELINE_KHR' are supported.
     */
    timelineSemaphore?: boolean
  }

  declare interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
    new (
      param?: VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInitializer | null
    ): VkPhysicalDeviceTimelineSemaphoreFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceTimelineSemaphoreFeaturesKHR: VkPhysicalDeviceTimelineSemaphoreFeaturesKHRConstructor

  /**
   * Structure specifying subpass end info
   */
  interface VkSubpassEndInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null
  }

  declare interface VkSubpassEndInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null
  }

  declare interface VkSubpassEndInfoKHRConstructor {
    readonly prototype: VkSubpassEndInfoKHR
    new (param?: VkSubpassEndInfoKHRInitializer | null): VkSubpassEndInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassEndInfoKHR: VkSubpassEndInfoKHRConstructor

  /**
   * Structure specifying subpass begin info
   */
  interface VkSubpassBeginInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkSubpassContents' value specifying how the commands in the next subpass will be provided.
     */
    contents: VkSubpassContents
  }

  declare interface VkSubpassBeginInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkSubpassContents' value specifying how the commands in the next subpass will be provided.
     */
    contents?: VkSubpassContents
  }

  declare interface VkSubpassBeginInfoKHRConstructor {
    readonly prototype: VkSubpassBeginInfoKHR
    new (param?: VkSubpassBeginInfoKHRInitializer | null): VkSubpassBeginInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassBeginInfoKHR: VkSubpassBeginInfoKHRConstructor

  /**
   * Structure specifying parameters of a newly created render pass
   */
  interface VkRenderPassCreateInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: VkRenderPassCreateFlagBits

    /**
     * 'VkAttachmentDescription2KHR' structures describing the attachments used by the render pass.
     */
    attachmentCount: number

    /**
     *
     */
    pAttachments: VkAttachmentDescription2KHR[] | null

    /**
     * 'VkSubpassDescription2KHR' structures describing each subpass.
     */
    subpassCount: number

    /**
     *
     */
    pSubpasses: VkSubpassDescription2KHR[] | null

    /**
     * 'VkSubpassDependency2KHR' structures describing dependencies between pairs of subpasses.
     */
    dependencyCount: number

    /**
     *
     */
    pDependencies: VkSubpassDependency2KHR[] | null

    /**
     * is the number of correlation masks.
     */
    correlatedViewMaskCount: number

    /**
     * is an array of view masks indicating sets of views that 'may' be more efficient to render concurrently.
     */
    pCorrelatedViewMasks: Uint32Array | null
  }

  declare interface VkRenderPassCreateInfo2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: VkRenderPassCreateFlagBits

    /**
     * 'VkAttachmentDescription2KHR' structures describing the attachments used by the render pass.
     */
    attachmentCount?: number

    /**
     *
     */
    pAttachments?: VkAttachmentDescription2KHR[] | null

    /**
     * 'VkSubpassDescription2KHR' structures describing each subpass.
     */
    subpassCount?: number

    /**
     *
     */
    pSubpasses?: VkSubpassDescription2KHR[] | null

    /**
     * 'VkSubpassDependency2KHR' structures describing dependencies between pairs of subpasses.
     */
    dependencyCount?: number

    /**
     *
     */
    pDependencies?: VkSubpassDependency2KHR[] | null

    /**
     * is the number of correlation masks.
     */
    correlatedViewMaskCount?: number

    /**
     * is an array of view masks indicating sets of views that 'may' be more efficient to render concurrently.
     */
    pCorrelatedViewMasks?: Uint32Array | null
  }

  declare interface VkRenderPassCreateInfo2KHRConstructor {
    readonly prototype: VkRenderPassCreateInfo2KHR
    new (
      param?: VkRenderPassCreateInfo2KHRInitializer | null
    ): VkRenderPassCreateInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassCreateInfo2KHR: VkRenderPassCreateInfo2KHRConstructor

  /**
   * Structure specifying a subpass dependency
   */
  interface VkSubpassDependency2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the subpass index of the first subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    srcSubpass: number

    /**
     * is the subpass index of the second subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    dstSubpass: number

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
     */
    srcStageMask: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>
     */
    dstStageMask: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkDependencyFlagBits'.
     */
    dependencyFlags: VkDependencyFlagBits

    /**
     * controls which views in the source subpass the views in the destination subpass depend on.
     */
    viewOffset: number
  }

  declare interface VkSubpassDependency2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the subpass index of the first subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    srcSubpass?: number

    /**
     * is the subpass index of the second subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    dstSubpass?: number

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
     */
    srcStageMask?: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>
     */
    dstStageMask?: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkDependencyFlagBits'.
     */
    dependencyFlags?: VkDependencyFlagBits

    /**
     * controls which views in the source subpass the views in the destination subpass depend on.
     */
    viewOffset?: number
  }

  declare interface VkSubpassDependency2KHRConstructor {
    readonly prototype: VkSubpassDependency2KHR
    new (
      param?: VkSubpassDependency2KHRInitializer | null
    ): VkSubpassDependency2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassDependency2KHR: VkSubpassDependency2KHRConstructor

  /**
   * Structure specifying a subpass description
   */
  interface VkSubpassDescription2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkSubpassDescriptionFlagBits' specifying usage of the subpass.
     */
    flags: VkSubpassDescriptionFlagBits

    /**
     * is a 'VkPipelineBindPoint' value specifying the pipeline type supported for this subpass.
     */
    pipelineBindPoint: VkPipelineBindPoint

    /**
     * is a bitfield of view indices describing which views rendering is broadcast to in this subpass, when multiview is enabled.
     */
    viewMask: number

    /**
     * is the number of input attachments.
     */
    inputAttachmentCount: number

    /**
     * is an array of 'VkAttachmentReference2KHR' structures defining the input attachments for this subpass and their layouts.
     */
    pInputAttachments: VkAttachmentReference2KHR[] | null

    /**
     * is the number of color attachments.
     */
    colorAttachmentCount: number

    /**
     * is an array of 'VkAttachmentReference2KHR' structures defining the color attachments for this subpass and their layouts.
     */
    pColorAttachments: VkAttachmentReference2KHR[] | null

    /**
     * is an optional array of 'colorAttachmentCount' 'VkAttachmentReference2KHR' structures defining the resolve attachments for this subpass and their layouts.
     */
    pResolveAttachments: VkAttachmentReference2KHR[] | null

    /**
     * is a reference to a 'VkAttachmentReference2KHR' structure specifying the depth/stencil attachment for this subpass and its layout.
     */
    pDepthStencilAttachment: VkAttachmentReference2KHR | null

    /**
     * is the number of preserved attachments.
     */
    preserveAttachmentCount: number

    /**
     * is an array of 'preserveAttachmentCount' render pass attachment indices identifying attachments that are not used by this subpass, but whose contents 'must' be preserved throughout the subpass.
     */
    pPreserveAttachments: Uint32Array | null
  }

  declare interface VkSubpassDescription2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkSubpassDescriptionFlagBits' specifying usage of the subpass.
     */
    flags?: VkSubpassDescriptionFlagBits

    /**
     * is a 'VkPipelineBindPoint' value specifying the pipeline type supported for this subpass.
     */
    pipelineBindPoint?: VkPipelineBindPoint

    /**
     * is a bitfield of view indices describing which views rendering is broadcast to in this subpass, when multiview is enabled.
     */
    viewMask?: number

    /**
     * is the number of input attachments.
     */
    inputAttachmentCount?: number

    /**
     * is an array of 'VkAttachmentReference2KHR' structures defining the input attachments for this subpass and their layouts.
     */
    pInputAttachments?: VkAttachmentReference2KHR[] | null

    /**
     * is the number of color attachments.
     */
    colorAttachmentCount?: number

    /**
     * is an array of 'VkAttachmentReference2KHR' structures defining the color attachments for this subpass and their layouts.
     */
    pColorAttachments?: VkAttachmentReference2KHR[] | null

    /**
     * is an optional array of 'colorAttachmentCount' 'VkAttachmentReference2KHR' structures defining the resolve attachments for this subpass and their layouts.
     */
    pResolveAttachments?: VkAttachmentReference2KHR[] | null

    /**
     * is a reference to a 'VkAttachmentReference2KHR' structure specifying the depth/stencil attachment for this subpass and its layout.
     */
    pDepthStencilAttachment?: VkAttachmentReference2KHR | null

    /**
     * is the number of preserved attachments.
     */
    preserveAttachmentCount?: number

    /**
     * is an array of 'preserveAttachmentCount' render pass attachment indices identifying attachments that are not used by this subpass, but whose contents 'must' be preserved throughout the subpass.
     */
    pPreserveAttachments?: Uint32Array | null
  }

  declare interface VkSubpassDescription2KHRConstructor {
    readonly prototype: VkSubpassDescription2KHR
    new (
      param?: VkSubpassDescription2KHRInitializer | null
    ): VkSubpassDescription2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassDescription2KHR: VkSubpassDescription2KHRConstructor

  /**
   * Structure specifying an attachment reference
   */
  interface VkAttachmentReference2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is either a number value identifying an attachment at the corresponding index in 'VkRenderPassCreateInfo'::'pAttachments', or 'VK_ATTACHMENT_UNUSED' to signify that this attachment is not used.
     */
    attachment: number

    /**
     * is a 'VkImageLayout' value specifying the layout the attachment uses during the subpass.
     */
    layout: VkImageLayout

    /**
     * is a mask of which aspect(s) 'can' be accessed within the specified subpass as an input attachment.
     */
    aspectMask: VkImageAspectFlagBits
  }

  declare interface VkAttachmentReference2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is either a number value identifying an attachment at the corresponding index in 'VkRenderPassCreateInfo'::'pAttachments', or 'VK_ATTACHMENT_UNUSED' to signify that this attachment is not used.
     */
    attachment?: number

    /**
     * is a 'VkImageLayout' value specifying the layout the attachment uses during the subpass.
     */
    layout?: VkImageLayout

    /**
     * is a mask of which aspect(s) 'can' be accessed within the specified subpass as an input attachment.
     */
    aspectMask?: VkImageAspectFlagBits
  }

  declare interface VkAttachmentReference2KHRConstructor {
    readonly prototype: VkAttachmentReference2KHR
    new (
      param?: VkAttachmentReference2KHRInitializer | null
    ): VkAttachmentReference2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAttachmentReference2KHR: VkAttachmentReference2KHRConstructor

  /**
   * Structure specifying an attachment description
   */
  interface VkAttachmentDescription2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkAttachmentDescriptionFlagBits' specifying additional properties of the attachment.
     */
    flags: VkAttachmentDescriptionFlagBits

    /**
     * is a 'VkFormat' value specifying the format of the image that will be used for the attachment.
     */
    format: VkFormat

    /**
     * is the number of samples of the image as defined in 'VkSampleCountFlagBits'.
     */
    samples: VkSampleCountFlagBits

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    loadOp: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
     */
    storeOp: VkAttachmentStoreOp

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    stencilLoadOp: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
     */
    stencilStoreOp: VkAttachmentStoreOp

    /**
     * is the layout the attachment image subresource will be in when a render pass instance begins.
     */
    initialLayout: VkImageLayout

    /**
     * is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
     */
    finalLayout: VkImageLayout
  }

  declare interface VkAttachmentDescription2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkAttachmentDescriptionFlagBits' specifying additional properties of the attachment.
     */
    flags?: VkAttachmentDescriptionFlagBits

    /**
     * is a 'VkFormat' value specifying the format of the image that will be used for the attachment.
     */
    format?: VkFormat

    /**
     * is the number of samples of the image as defined in 'VkSampleCountFlagBits'.
     */
    samples?: VkSampleCountFlagBits

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    loadOp?: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
     */
    storeOp?: VkAttachmentStoreOp

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    stencilLoadOp?: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
     */
    stencilStoreOp?: VkAttachmentStoreOp

    /**
     * is the layout the attachment image subresource will be in when a render pass instance begins.
     */
    initialLayout?: VkImageLayout

    /**
     * is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
     */
    finalLayout?: VkImageLayout
  }

  declare interface VkAttachmentDescription2KHRConstructor {
    readonly prototype: VkAttachmentDescription2KHR
    new (
      param?: VkAttachmentDescription2KHRInitializer | null
    ): VkAttachmentDescription2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAttachmentDescription2KHR: VkAttachmentDescription2KHRConstructor

  /**
   * Structure returning information about whether a descriptor set layout can be supported
   */
  interface VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * indicates the maximum number of descriptors supported in the highest numbered binding of the layout, if that binding is variable-sized. If the highest numbered binding of the layout has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'maxVariableDescriptorCount' indicates the maximum byte size supported for the binding, if that binding is variable-sized.
     */
    readonly maxVariableDescriptorCount: number
  }

  declare interface VkDescriptorSetVariableDescriptorCountLayoutSupportEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * indicates the maximum number of descriptors supported in the highest numbered binding of the layout, if that binding is variable-sized. If the highest numbered binding of the layout has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'maxVariableDescriptorCount' indicates the maximum byte size supported for the binding, if that binding is variable-sized.
     */
    readonly maxVariableDescriptorCount?: number
  }

  declare interface VkDescriptorSetVariableDescriptorCountLayoutSupportEXTConstructor {
    readonly prototype: VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
    new (
      param?: VkDescriptorSetVariableDescriptorCountLayoutSupportEXTInitializer | null
    ): VkDescriptorSetVariableDescriptorCountLayoutSupportEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetVariableDescriptorCountLayoutSupportEXT: VkDescriptorSetVariableDescriptorCountLayoutSupportEXTConstructor

  /**
   * Structure specifying additional allocation parameters for descriptor sets
   */
  interface VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is zero or the number of elements in 'pDescriptorCounts'.
     */
    descriptorSetCount: number

    /**
     * is an array of descriptor counts, with each member specifying the number of descriptors in a variable descriptor count binding in the corresponding descriptor set being allocated.
     */
    pDescriptorCounts: Uint32Array | null
  }

  declare interface VkDescriptorSetVariableDescriptorCountAllocateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is zero or the number of elements in 'pDescriptorCounts'.
     */
    descriptorSetCount?: number

    /**
     * is an array of descriptor counts, with each member specifying the number of descriptors in a variable descriptor count binding in the corresponding descriptor set being allocated.
     */
    pDescriptorCounts?: Uint32Array | null
  }

  declare interface VkDescriptorSetVariableDescriptorCountAllocateInfoEXTConstructor {
    readonly prototype: VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
    new (
      param?: VkDescriptorSetVariableDescriptorCountAllocateInfoEXTInitializer | null
    ): VkDescriptorSetVariableDescriptorCountAllocateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetVariableDescriptorCountAllocateInfoEXT: VkDescriptorSetVariableDescriptorCountAllocateInfoEXTConstructor

  /**
   * Structure specifying creation flags for descriptor set layout bindings
   */
  interface VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is zero or the number of elements in 'pBindingFlags'.
     */
    bindingCount: number

    /**
     * is an array of 'VkDescriptorBindingFlagsEXT' bitfields, one for each descriptor set layout binding.
     */
    pBindingFlags: Int32Array | null
  }

  declare interface VkDescriptorSetLayoutBindingFlagsCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is zero or the number of elements in 'pBindingFlags'.
     */
    bindingCount?: number

    /**
     * is an array of 'VkDescriptorBindingFlagsEXT' bitfields, one for each descriptor set layout binding.
     */
    pBindingFlags?: Int32Array | null
  }

  declare interface VkDescriptorSetLayoutBindingFlagsCreateInfoEXTConstructor {
    readonly prototype: VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
    new (
      param?: VkDescriptorSetLayoutBindingFlagsCreateInfoEXTInitializer | null
    ): VkDescriptorSetLayoutBindingFlagsCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetLayoutBindingFlagsCreateInfoEXT: VkDescriptorSetLayoutBindingFlagsCreateInfoEXTConstructor

  /**
   * Structure describing descriptor indexing properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum number of descriptors (summed over all descriptor types) that 'can' be created across all pools that are created with the 'VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT' bit set. Pool creation 'may' fail when this limit is exceeded, or when the space this limit represents is unable to satisfy a pool creation due to fragmentation.
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools: number

    /**
     * is a boolean value indicating whether uniform buffer descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of uniform buffers 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative: boolean

    /**
     * is a boolean value indicating whether sampler and image descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of samplers or images 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative: boolean

    /**
     * is a boolean value indicating whether storage buffer descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of storage buffers 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative: boolean

    /**
     * is a boolean value indicating whether storage image descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of storage images 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative: boolean

    /**
     * is a boolean value indicating whether input attachment descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of input attachments 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative: boolean

    /**
     * is a boolean value indicating whether <<features-robustBufferAccess, 'robustBufferAccess'>> 'can' be enabled in a device simultaneously with 'descriptorBindingUniformBufferUpdateAfterBind', 'descriptorBindingStorageBufferUpdateAfterBind', 'descriptorBindingUniformTexelBufferUpdateAfterBind', and/or 'descriptorBindingStorageTexelBufferUpdateAfterBind'. If this is 'VK_FALSE', then either 'robustBufferAccess' 'must' be disabled or all of these update-after-bind features 'must' be disabled.
     */
    readonly robustBufferAccessUpdateAfterBind: boolean

    /**
     * is a boolean value indicating whether implicit level of detail calculations for image operations have well-defined results when the image and/or sampler objects used for the instruction are not uniform within a quad. See <<textures-derivative-image-operations,Derivative Image Operations>>.
     */
    readonly quadDivergentImplicitLod: boolean

    /**
     * is similar to 'maxPerStageDescriptorSamplers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers: number

    /**
     * is similar to 'maxPerStageDescriptorUniformBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers: number

    /**
     * is similar to 'maxPerStageDescriptorStorageBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers: number

    /**
     * is similar to 'maxPerStageDescriptorSampledImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages: number

    /**
     * is similar to 'maxPerStageDescriptorStorageImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages: number

    /**
     * is similar to 'maxPerStageDescriptorInputAttachments' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments: number

    /**
     * is similar to 'maxPerStageResources' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageUpdateAfterBindResources: number

    /**
     * is similar to 'maxDescriptorSetSamplers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers: number

    /**
     * is similar to 'maxDescriptorSetUniformBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers: number

    /**
     * is similar to 'maxDescriptorSetUniformBuffersDynamic' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number

    /**
     * is similar to 'maxDescriptorSetStorageBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers: number

    /**
     * is similar to 'maxDescriptorSetStorageBuffersDynamic' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number

    /**
     * is similar to 'maxDescriptorSetSampledImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages: number

    /**
     * is similar to 'maxDescriptorSetStorageImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages: number

    /**
     * is similar to 'maxDescriptorSetInputAttachments' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments: number
  }

  declare interface VkPhysicalDeviceDescriptorIndexingPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum number of descriptors (summed over all descriptor types) that 'can' be created across all pools that are created with the 'VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT' bit set. Pool creation 'may' fail when this limit is exceeded, or when the space this limit represents is unable to satisfy a pool creation due to fragmentation.
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools?: number

    /**
     * is a boolean value indicating whether uniform buffer descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of uniform buffers 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative?: boolean

    /**
     * is a boolean value indicating whether sampler and image descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of samplers or images 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative?: boolean

    /**
     * is a boolean value indicating whether storage buffer descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of storage buffers 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative?: boolean

    /**
     * is a boolean value indicating whether storage image descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of storage images 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative?: boolean

    /**
     * is a boolean value indicating whether input attachment descriptors natively support nonuniform indexing. If this is 'VK_FALSE', then a single dynamic instance of an instruction that nonuniformly indexes an array of input attachments 'may' execute multiple times in order to access all the descriptors.
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative?: boolean

    /**
     * is a boolean value indicating whether <<features-robustBufferAccess, 'robustBufferAccess'>> 'can' be enabled in a device simultaneously with 'descriptorBindingUniformBufferUpdateAfterBind', 'descriptorBindingStorageBufferUpdateAfterBind', 'descriptorBindingUniformTexelBufferUpdateAfterBind', and/or 'descriptorBindingStorageTexelBufferUpdateAfterBind'. If this is 'VK_FALSE', then either 'robustBufferAccess' 'must' be disabled or all of these update-after-bind features 'must' be disabled.
     */
    readonly robustBufferAccessUpdateAfterBind?: boolean

    /**
     * is a boolean value indicating whether implicit level of detail calculations for image operations have well-defined results when the image and/or sampler objects used for the instruction are not uniform within a quad. See <<textures-derivative-image-operations,Derivative Image Operations>>.
     */
    readonly quadDivergentImplicitLod?: boolean

    /**
     * is similar to 'maxPerStageDescriptorSamplers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers?: number

    /**
     * is similar to 'maxPerStageDescriptorUniformBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers?: number

    /**
     * is similar to 'maxPerStageDescriptorStorageBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers?: number

    /**
     * is similar to 'maxPerStageDescriptorSampledImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages?: number

    /**
     * is similar to 'maxPerStageDescriptorStorageImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages?: number

    /**
     * is similar to 'maxPerStageDescriptorInputAttachments' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments?: number

    /**
     * is similar to 'maxPerStageResources' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxPerStageUpdateAfterBindResources?: number

    /**
     * is similar to 'maxDescriptorSetSamplers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers?: number

    /**
     * is similar to 'maxDescriptorSetUniformBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers?: number

    /**
     * is similar to 'maxDescriptorSetUniformBuffersDynamic' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic?: number

    /**
     * is similar to 'maxDescriptorSetStorageBuffers' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers?: number

    /**
     * is similar to 'maxDescriptorSetStorageBuffersDynamic' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic?: number

    /**
     * is similar to 'maxDescriptorSetSampledImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages?: number

    /**
     * is similar to 'maxDescriptorSetStorageImages' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages?: number

    /**
     * is similar to 'maxDescriptorSetInputAttachments' but counts descriptors from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments?: number
  }

  declare interface VkPhysicalDeviceDescriptorIndexingPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceDescriptorIndexingPropertiesEXT
    new (
      param?: VkPhysicalDeviceDescriptorIndexingPropertiesEXTInitializer | null
    ): VkPhysicalDeviceDescriptorIndexingPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDescriptorIndexingPropertiesEXT: VkPhysicalDeviceDescriptorIndexingPropertiesEXTConstructor

  /**
   * Structure describing descriptor indexing features that can be supported by an implementation
   */
  interface VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing: boolean

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing: boolean

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing: boolean

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing: boolean

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing: boolean

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing: boolean

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing: boolean

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind: boolean

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind: boolean

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind: boolean

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind: boolean

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind: boolean

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind: boolean

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending: boolean

    /**
     *
     */
    descriptorBindingPartiallyBound: boolean

    /**
     *
     */
    descriptorBindingVariableDescriptorCount: boolean

    /**
     * indicates whether the implementation supports the SPIR-V 'RuntimeDescriptorArrayEXT' capability. If this feature is not enabled, descriptors 'must' not be declared in runtime arrays.
     */
    runtimeDescriptorArray: boolean
  }

  declare interface VkPhysicalDeviceDescriptorIndexingFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing?: boolean

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing?: boolean

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing?: boolean

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing?: boolean

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing?: boolean

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing?: boolean

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing?: boolean

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind?: boolean

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind?: boolean

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind?: boolean

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind?: boolean

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind?: boolean

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind?: boolean

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending?: boolean

    /**
     *
     */
    descriptorBindingPartiallyBound?: boolean

    /**
     *
     */
    descriptorBindingVariableDescriptorCount?: boolean

    /**
     * indicates whether the implementation supports the SPIR-V 'RuntimeDescriptorArrayEXT' capability. If this feature is not enabled, descriptors 'must' not be declared in runtime arrays.
     */
    runtimeDescriptorArray?: boolean
  }

  declare interface VkPhysicalDeviceDescriptorIndexingFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
    new (
      param?: VkPhysicalDeviceDescriptorIndexingFeaturesEXTInitializer | null
    ): VkPhysicalDeviceDescriptorIndexingFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDescriptorIndexingFeaturesEXT: VkPhysicalDeviceDescriptorIndexingFeaturesEXTConstructor

  /**
   * Structure specifying conservative raster state
   */
  interface VkPipelineRasterizationConservativeStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the conservative rasterization mode to use.
     */
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT

    /**
     * is the extra size in pixels to increase the generating primitive during conservative rasterization at each of its edges in `X` and `Y` equally in screen space beyond the base overestimation specified in 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT'::'primitiveOverestimationSize'.
     */
    extraPrimitiveOverestimationSize: number
  }

  declare interface VkPipelineRasterizationConservativeStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the conservative rasterization mode to use.
     */
    conservativeRasterizationMode?: VkConservativeRasterizationModeEXT

    /**
     * is the extra size in pixels to increase the generating primitive during conservative rasterization at each of its edges in `X` and `Y` equally in screen space beyond the base overestimation specified in 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT'::'primitiveOverestimationSize'.
     */
    extraPrimitiveOverestimationSize?: number
  }

  declare interface VkPipelineRasterizationConservativeStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineRasterizationConservativeStateCreateInfoEXT
    new (
      param?: VkPipelineRasterizationConservativeStateCreateInfoEXTInitializer | null
    ): VkPipelineRasterizationConservativeStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRasterizationConservativeStateCreateInfoEXT: VkPipelineRasterizationConservativeStateCreateInfoEXTConstructor

  /**
   * Structure describing shader core properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderCoreProperties2AMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask of 'VkShaderCorePropertiesFlagBitsAMD' indicating the set of features supported by the shader core.
     */
    readonly shaderCoreFeatures: VkShaderCorePropertiesFlagBitsAMD

    /**
     * is a number value indicating the number of compute units that have been enabled.
     */
    readonly activeComputeUnitCount: number
  }

  declare interface VkPhysicalDeviceShaderCoreProperties2AMDInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask of 'VkShaderCorePropertiesFlagBitsAMD' indicating the set of features supported by the shader core.
     */
    readonly shaderCoreFeatures?: VkShaderCorePropertiesFlagBitsAMD

    /**
     * is a number value indicating the number of compute units that have been enabled.
     */
    readonly activeComputeUnitCount?: number
  }

  declare interface VkPhysicalDeviceShaderCoreProperties2AMDConstructor {
    readonly prototype: VkPhysicalDeviceShaderCoreProperties2AMD
    new (
      param?: VkPhysicalDeviceShaderCoreProperties2AMDInitializer | null
    ): VkPhysicalDeviceShaderCoreProperties2AMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderCoreProperties2AMD: VkPhysicalDeviceShaderCoreProperties2AMDConstructor

  /**
   * Structure describing shader core properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderCorePropertiesAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a number value indicating the number of shader engines found inside the shader core of the physical device.
     */
    readonly shaderEngineCount: number

    /**
     * is a number value indicating the number of shader arrays inside a shader engine. Each shader array has its own scan converter, set of compute units, and a render back end (color and depth buffers). Shader arrays within a shader engine share shader processor input (wave launcher) and shader export (export buffer) units. Currently, a shader engine can have one or two shader arrays.
     */
    readonly shaderArraysPerEngineCount: number

    /**
     * is a number value indicating the physical number of compute units within a shader array. The active number of compute units in a shader array 'may' be lower. A compute unit houses a set of SIMDs along with a sequencer module and a local data store.
     */
    readonly computeUnitsPerShaderArray: number

    /**
     * is a number value indicating the number of SIMDs inside a compute unit. Each SIMD processes a single instruction at a time.
     */
    readonly simdPerComputeUnit: number

    /**
     *
     */
    readonly wavefrontsPerSimd: number

    /**
     * is a number value indicating the maximum size of a subgroup.
     */
    readonly wavefrontSize: number

    /**
     * is a number value indicating the number of physical Scalar General Purpose Registers (SGPRs) per SIMD.
     */
    readonly sgprsPerSimd: number

    /**
     * is a number value indicating the minimum number of SGPRs allocated for a wave.
     */
    readonly minSgprAllocation: number

    /**
     * is a number value indicating the maximum number of SGPRs allocated for a wave.
     */
    readonly maxSgprAllocation: number

    /**
     * is a number value indicating the granularity of SGPR allocation for a wave.
     */
    readonly sgprAllocationGranularity: number

    /**
     * is a number value indicating the number of physical Vector General Purpose Registers (VGPRs) per SIMD.
     */
    readonly vgprsPerSimd: number

    /**
     * is a number value indicating the minimum number of VGPRs allocated for a wave.
     */
    readonly minVgprAllocation: number

    /**
     * is a number value indicating the maximum number of VGPRs allocated for a wave.
     */
    readonly maxVgprAllocation: number

    /**
     * is a number value indicating the granularity of VGPR allocation for a wave.
     */
    readonly vgprAllocationGranularity: number
  }

  declare interface VkPhysicalDeviceShaderCorePropertiesAMDInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a number value indicating the number of shader engines found inside the shader core of the physical device.
     */
    readonly shaderEngineCount?: number

    /**
     * is a number value indicating the number of shader arrays inside a shader engine. Each shader array has its own scan converter, set of compute units, and a render back end (color and depth buffers). Shader arrays within a shader engine share shader processor input (wave launcher) and shader export (export buffer) units. Currently, a shader engine can have one or two shader arrays.
     */
    readonly shaderArraysPerEngineCount?: number

    /**
     * is a number value indicating the physical number of compute units within a shader array. The active number of compute units in a shader array 'may' be lower. A compute unit houses a set of SIMDs along with a sequencer module and a local data store.
     */
    readonly computeUnitsPerShaderArray?: number

    /**
     * is a number value indicating the number of SIMDs inside a compute unit. Each SIMD processes a single instruction at a time.
     */
    readonly simdPerComputeUnit?: number

    /**
     *
     */
    readonly wavefrontsPerSimd?: number

    /**
     * is a number value indicating the maximum size of a subgroup.
     */
    readonly wavefrontSize?: number

    /**
     * is a number value indicating the number of physical Scalar General Purpose Registers (SGPRs) per SIMD.
     */
    readonly sgprsPerSimd?: number

    /**
     * is a number value indicating the minimum number of SGPRs allocated for a wave.
     */
    readonly minSgprAllocation?: number

    /**
     * is a number value indicating the maximum number of SGPRs allocated for a wave.
     */
    readonly maxSgprAllocation?: number

    /**
     * is a number value indicating the granularity of SGPR allocation for a wave.
     */
    readonly sgprAllocationGranularity?: number

    /**
     * is a number value indicating the number of physical Vector General Purpose Registers (VGPRs) per SIMD.
     */
    readonly vgprsPerSimd?: number

    /**
     * is a number value indicating the minimum number of VGPRs allocated for a wave.
     */
    readonly minVgprAllocation?: number

    /**
     * is a number value indicating the maximum number of VGPRs allocated for a wave.
     */
    readonly maxVgprAllocation?: number

    /**
     * is a number value indicating the granularity of VGPR allocation for a wave.
     */
    readonly vgprAllocationGranularity?: number
  }

  declare interface VkPhysicalDeviceShaderCorePropertiesAMDConstructor {
    readonly prototype: VkPhysicalDeviceShaderCorePropertiesAMD
    new (
      param?: VkPhysicalDeviceShaderCorePropertiesAMDInitializer | null
    ): VkPhysicalDeviceShaderCorePropertiesAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderCorePropertiesAMD: VkPhysicalDeviceShaderCorePropertiesAMDConstructor

  /**
   * Structure specifying the input parameters of a calibrated timestamp query
   */
  interface VkCalibratedTimestampInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkTimeDomainEXT' value specifying the time domain from which the calibrated timestamp value should be returned.
     */
    timeDomain: VkTimeDomainEXT
  }

  declare interface VkCalibratedTimestampInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkTimeDomainEXT' value specifying the time domain from which the calibrated timestamp value should be returned.
     */
    timeDomain?: VkTimeDomainEXT
  }

  declare interface VkCalibratedTimestampInfoEXTConstructor {
    readonly prototype: VkCalibratedTimestampInfoEXT
    new (
      param?: VkCalibratedTimestampInfoEXTInitializer | null
    ): VkCalibratedTimestampInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCalibratedTimestampInfoEXT: VkCalibratedTimestampInfoEXTConstructor

  /**
   * Structure describing conservative raster properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the size in pixels the generating primitive is increased at each of its edges during conservative rasterization overestimation mode. Even with a size of 0.0, conservative rasterization overestimation rules still apply and if any part of the pixel rectangle is covered by the generating primitive, fragments are generated for the entire pixel. However implementations 'may' make the pixel coverage area even more conservative by increasing the size of the generating primitive.
     */
    readonly primitiveOverestimationSize: number

    /**
     *
     */
    readonly maxExtraPrimitiveOverestimationSize: number

    /**
     *
     */
    readonly extraPrimitiveOverestimationSizeGranularity: number

    /**
     *
     */
    readonly primitiveUnderestimation: boolean

    /**
     *
     */
    readonly conservativePointAndLineRasterization: boolean

    /**
     *
     */
    readonly degenerateTrianglesRasterized: boolean

    /**
     *
     */
    readonly degenerateLinesRasterized: boolean

    /**
     *
     */
    readonly fullyCoveredFragmentShaderInputVariable: boolean

    /**
     *
     */
    readonly conservativeRasterizationPostDepthCoverage: boolean
  }

  declare interface VkPhysicalDeviceConservativeRasterizationPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the size in pixels the generating primitive is increased at each of its edges during conservative rasterization overestimation mode. Even with a size of 0.0, conservative rasterization overestimation rules still apply and if any part of the pixel rectangle is covered by the generating primitive, fragments are generated for the entire pixel. However implementations 'may' make the pixel coverage area even more conservative by increasing the size of the generating primitive.
     */
    readonly primitiveOverestimationSize?: number

    /**
     *
     */
    readonly maxExtraPrimitiveOverestimationSize?: number

    /**
     *
     */
    readonly extraPrimitiveOverestimationSizeGranularity?: number

    /**
     *
     */
    readonly primitiveUnderestimation?: boolean

    /**
     *
     */
    readonly conservativePointAndLineRasterization?: boolean

    /**
     *
     */
    readonly degenerateTrianglesRasterized?: boolean

    /**
     *
     */
    readonly degenerateLinesRasterized?: boolean

    /**
     *
     */
    readonly fullyCoveredFragmentShaderInputVariable?: boolean

    /**
     *
     */
    readonly conservativeRasterizationPostDepthCoverage?: boolean
  }

  declare interface VkPhysicalDeviceConservativeRasterizationPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceConservativeRasterizationPropertiesEXT
    new (
      param?: VkPhysicalDeviceConservativeRasterizationPropertiesEXTInitializer | null
    ): VkPhysicalDeviceConservativeRasterizationPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceConservativeRasterizationPropertiesEXT: VkPhysicalDeviceConservativeRasterizationPropertiesEXTConstructor

  /**
   * Structure describing external memory host reference limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the minimum 'required' alignment, in bytes, for the base address and size of host references that 'can' be imported to a Vulkan memory object.
     */
    readonly minImportedHostPointerAlignment: bigint | number
  }

  declare interface VkPhysicalDeviceExternalMemoryHostPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the minimum 'required' alignment, in bytes, for the base address and size of host references that 'can' be imported to a Vulkan memory object.
     */
    readonly minImportedHostPointerAlignment?: bigint | number
  }

  declare interface VkPhysicalDeviceExternalMemoryHostPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceExternalMemoryHostPropertiesEXT
    new (
      param?: VkPhysicalDeviceExternalMemoryHostPropertiesEXTInitializer | null
    ): VkPhysicalDeviceExternalMemoryHostPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalMemoryHostPropertiesEXT: VkPhysicalDeviceExternalMemoryHostPropertiesEXTConstructor

  /**
   * Properties of external memory host reference
   */
  interface VkMemoryHostPointerPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask containing one bit set for every memory type which the specified host reference 'can' be imported as.
     */
    readonly memoryTypeBits: number
  }

  declare interface VkMemoryHostPointerPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask containing one bit set for every memory type which the specified host reference 'can' be imported as.
     */
    readonly memoryTypeBits?: number
  }

  declare interface VkMemoryHostPointerPropertiesEXTConstructor {
    readonly prototype: VkMemoryHostPointerPropertiesEXT
    new (
      param?: VkMemoryHostPointerPropertiesEXTInitializer | null
    ): VkMemoryHostPointerPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryHostPointerPropertiesEXT: VkMemoryHostPointerPropertiesEXTConstructor

  /**
   * import memory from a host reference
   */
  interface VkImportMemoryHostPointerInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies the handle type.
     */
    handleType: VkExternalMemoryHandleTypeFlagBits

    /**
     * is the host reference to import from.
     */
    pHostPointer: ArrayBuffer | null
  }

  declare interface VkImportMemoryHostPointerInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies the handle type.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits

    /**
     * is the host reference to import from.
     */
    pHostPointer?: ArrayBuffer | null
  }

  declare interface VkImportMemoryHostPointerInfoEXTConstructor {
    readonly prototype: VkImportMemoryHostPointerInfoEXT
    new (
      param?: VkImportMemoryHostPointerInfoEXTInitializer | null
    ): VkImportMemoryHostPointerInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportMemoryHostPointerInfoEXT: VkImportMemoryHostPointerInfoEXTConstructor

  /**
   * Structure specifying parameters returned to the callback
   */
  interface VkDebugUtilsMessengerCallbackDataEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is 0 and reserved for future use.
     */
    flags: number

    /**
     * is a string that identifies the particular message ID that is associated with the provided message. If the message corresponds to a validation layer message, then this string may contain the portion of the Vulkan specification that is believed to have been violated.
     */
    pMessageIdName: string | null

    /**
     * is the ID number of the triggering message. If the message corresponds to a validation layer message, then this number is related to the internal number associated with the message being triggered.
     */
    messageIdNumber: number

    /**
     * is a string detailing the trigger conditions.
     */
    pMessage: string | null

    /**
     * is a count of items contained in the 'pQueueLabels' array.
     */
    queueLabelCount: number

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkQueue' at the time the callback was triggered. Refer to <<debugging-queue-labels,Queue Labels>> for more information.
     */
    pQueueLabels: VkDebugUtilsLabelEXT[] | null

    /**
     * is a count of items contained in the 'pCmdBufLabels' array.
     */
    cmdBufLabelCount: number

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkCommandBuffer' at the time the callback was triggered. Refer to <<debugging-command-buffer-labels, Command Buffer Labels>> for more information.
     */
    pCmdBufLabels: VkDebugUtilsLabelEXT[] | null

    /**
     *
     */
    objectCount: number

    /**
     * is an array of 'VkDebugUtilsObjectNameInfoEXT' objects related to the detected issue. The array is roughly in order or importance, but the 0th element is always guaranteed to be the most important object for this message.
     */
    pObjects: VkDebugUtilsObjectNameInfoEXT[] | null
  }

  declare interface VkDebugUtilsMessengerCallbackDataEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is 0 and reserved for future use.
     */
    flags?: number

    /**
     * is a string that identifies the particular message ID that is associated with the provided message. If the message corresponds to a validation layer message, then this string may contain the portion of the Vulkan specification that is believed to have been violated.
     */
    pMessageIdName?: string | null

    /**
     * is the ID number of the triggering message. If the message corresponds to a validation layer message, then this number is related to the internal number associated with the message being triggered.
     */
    messageIdNumber?: number

    /**
     * is a string detailing the trigger conditions.
     */
    pMessage?: string | null

    /**
     * is a count of items contained in the 'pQueueLabels' array.
     */
    queueLabelCount?: number

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkQueue' at the time the callback was triggered. Refer to <<debugging-queue-labels,Queue Labels>> for more information.
     */
    pQueueLabels?: VkDebugUtilsLabelEXT[] | null

    /**
     * is a count of items contained in the 'pCmdBufLabels' array.
     */
    cmdBufLabelCount?: number

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkCommandBuffer' at the time the callback was triggered. Refer to <<debugging-command-buffer-labels, Command Buffer Labels>> for more information.
     */
    pCmdBufLabels?: VkDebugUtilsLabelEXT[] | null

    /**
     *
     */
    objectCount?: number

    /**
     * is an array of 'VkDebugUtilsObjectNameInfoEXT' objects related to the detected issue. The array is roughly in order or importance, but the 0th element is always guaranteed to be the most important object for this message.
     */
    pObjects?: VkDebugUtilsObjectNameInfoEXT[] | null
  }

  declare interface VkDebugUtilsMessengerCallbackDataEXTConstructor {
    readonly prototype: VkDebugUtilsMessengerCallbackDataEXT
    new (
      param?: VkDebugUtilsMessengerCallbackDataEXTInitializer | null
    ): VkDebugUtilsMessengerCallbackDataEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugUtilsMessengerCallbackDataEXT: VkDebugUtilsMessengerCallbackDataEXTConstructor

  /**
   * Structure specifying parameters of a newly created debug messenger
   */
  interface VkDebugUtilsMessengerCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is 0 and reserved for future use.
     */
    flags: number

    /**
     * is a bitmask of 'VkDebugUtilsMessageSeverityFlagBitsEXT' specifying which severity of event(s) will cause this callback to be called.
     */
    messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT

    /**
     * is a bitmask of 'VkDebugUtilsMessageTypeFlagBitsEXT' specifying which type of event(s) will cause this callback to be called.
     */
    messageType: VkDebugUtilsMessageTypeFlagBitsEXT

    /**
     * is the application callback function to call.
     */
    pfnUserCallback: vkDebugUtilsMessengerCallbackEXT | null

    /**
     * is user data to be passed to the callback.
     */
    pUserData: ArrayBuffer | null
  }

  declare interface VkDebugUtilsMessengerCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is 0 and reserved for future use.
     */
    flags?: number

    /**
     * is a bitmask of 'VkDebugUtilsMessageSeverityFlagBitsEXT' specifying which severity of event(s) will cause this callback to be called.
     */
    messageSeverity?: VkDebugUtilsMessageSeverityFlagBitsEXT

    /**
     * is a bitmask of 'VkDebugUtilsMessageTypeFlagBitsEXT' specifying which type of event(s) will cause this callback to be called.
     */
    messageType?: VkDebugUtilsMessageTypeFlagBitsEXT

    /**
     * is the application callback function to call.
     */
    pfnUserCallback?: vkDebugUtilsMessengerCallbackEXT | null

    /**
     * is user data to be passed to the callback.
     */
    pUserData?: ArrayBuffer | null
  }

  declare interface VkDebugUtilsMessengerCreateInfoEXTConstructor {
    readonly prototype: VkDebugUtilsMessengerCreateInfoEXT
    new (
      param?: VkDebugUtilsMessengerCreateInfoEXTInitializer | null
    ): VkDebugUtilsMessengerCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugUtilsMessengerCreateInfoEXT: VkDebugUtilsMessengerCreateInfoEXTConstructor

  /**
   * Specify parameters of a label region
   */
  interface VkDebugUtilsLabelEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a string containing the name of the label.
     */
    pLabelName: string | null

    /**
     * is an optional RGBA color value that can be associated with the label. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color: number[] | null
  }

  declare interface VkDebugUtilsLabelEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a string containing the name of the label.
     */
    pLabelName?: string | null

    /**
     * is an optional RGBA color value that can be associated with the label. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color?: number[] | null
  }

  declare interface VkDebugUtilsLabelEXTConstructor {
    readonly prototype: VkDebugUtilsLabelEXT
    new (param?: VkDebugUtilsLabelEXTInitializer | null): VkDebugUtilsLabelEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugUtilsLabelEXT: VkDebugUtilsLabelEXTConstructor

  /**
   * Specify parameters of a tag to attach to an object
   */
  interface VkDebugUtilsObjectTagInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType: VkObjectType

    /**
     * is the object to be tagged.
     */
    objectHandle: bigint | number

    /**
     * is a numerical identifier of the tag.
     */
    tagName: bigint | number

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize: bigint | number

    /**
     *
     */
    pTag: ArrayBuffer | null
  }

  declare interface VkDebugUtilsObjectTagInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType?: VkObjectType

    /**
     * is the object to be tagged.
     */
    objectHandle?: bigint | number

    /**
     * is a numerical identifier of the tag.
     */
    tagName?: bigint | number

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize?: bigint | number

    /**
     *
     */
    pTag?: ArrayBuffer | null
  }

  declare interface VkDebugUtilsObjectTagInfoEXTConstructor {
    readonly prototype: VkDebugUtilsObjectTagInfoEXT
    new (
      param?: VkDebugUtilsObjectTagInfoEXTInitializer | null
    ): VkDebugUtilsObjectTagInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugUtilsObjectTagInfoEXT: VkDebugUtilsObjectTagInfoEXTConstructor

  /**
   * Specify parameters of a name to give to an object
   */
  interface VkDebugUtilsObjectNameInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType: VkObjectType

    /**
     * is the object to be named.
     */
    objectHandle: bigint | number

    /**
     * is a string specifying the name to apply to 'objectHandle'.
     */
    pObjectName: string | null
  }

  declare interface VkDebugUtilsObjectNameInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType?: VkObjectType

    /**
     * is the object to be named.
     */
    objectHandle?: bigint | number

    /**
     * is a string specifying the name to apply to 'objectHandle'.
     */
    pObjectName?: string | null
  }

  declare interface VkDebugUtilsObjectNameInfoEXTConstructor {
    readonly prototype: VkDebugUtilsObjectNameInfoEXT
    new (
      param?: VkDebugUtilsObjectNameInfoEXTInitializer | null
    ): VkDebugUtilsObjectNameInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugUtilsObjectNameInfoEXT: VkDebugUtilsObjectNameInfoEXTConstructor

  /**
   * Specify a system wide priority
   */
  interface VkDeviceQueueGlobalPriorityCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the system-wide priority associated to this queue as specified by 'VkQueueGlobalPriorityEXT'
     */
    globalPriority: VkQueueGlobalPriorityEXT
  }

  declare interface VkDeviceQueueGlobalPriorityCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the system-wide priority associated to this queue as specified by 'VkQueueGlobalPriorityEXT'
     */
    globalPriority?: VkQueueGlobalPriorityEXT
  }

  declare interface VkDeviceQueueGlobalPriorityCreateInfoEXTConstructor {
    readonly prototype: VkDeviceQueueGlobalPriorityCreateInfoEXT
    new (
      param?: VkDeviceQueueGlobalPriorityCreateInfoEXTInitializer | null
    ): VkDeviceQueueGlobalPriorityCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceQueueGlobalPriorityCreateInfoEXT: VkDeviceQueueGlobalPriorityCreateInfoEXTConstructor

  /**
   * Statistical information about a particular shader within a pipeline
   */
  interface VkShaderStatisticsInfoAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly shaderStageMask: VkShaderStageFlagBits

    /**
     *
     */
    readonly resourceUsage: VkShaderResourceUsageAMD | null

    /**
     *
     */
    readonly numPhysicalVgprs: number

    /**
     *
     */
    readonly numPhysicalSgprs: number

    /**
     *
     */
    readonly numAvailableVgprs: number

    /**
     *
     */
    readonly numAvailableSgprs: number

    /**
     *
     */
    readonly computeWorkGroupSize: number[] | null
  }

  declare interface VkShaderStatisticsInfoAMDInitializer {
    /**
     *
     */
    readonly shaderStageMask?: VkShaderStageFlagBits

    /**
     *
     */
    readonly resourceUsage?: VkShaderResourceUsageAMD | null

    /**
     *
     */
    readonly numPhysicalVgprs?: number

    /**
     *
     */
    readonly numPhysicalSgprs?: number

    /**
     *
     */
    readonly numAvailableVgprs?: number

    /**
     *
     */
    readonly numAvailableSgprs?: number

    /**
     *
     */
    readonly computeWorkGroupSize?: number[] | null
  }

  declare interface VkShaderStatisticsInfoAMDConstructor {
    readonly prototype: VkShaderStatisticsInfoAMD
    new (
      param?: VkShaderStatisticsInfoAMDInitializer | null
    ): VkShaderStatisticsInfoAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkShaderStatisticsInfoAMD: VkShaderStatisticsInfoAMDConstructor

  /**
   * Resource usage information about a particular shader within a pipeline
   */
  interface VkShaderResourceUsageAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of vector instruction general-purpose registers used by this shader.
     */
    readonly numUsedVgprs: number

    /**
     * is the number of scalar instruction general-purpose registers used by this shader.
     */
    readonly numUsedSgprs: number

    /**
     * is the maximum local data store size per work group in bytes.
     */
    readonly ldsSizePerLocalWorkGroup: number

    /**
     * is the LDS usage size in bytes per work group by this shader.
     */
    readonly ldsUsageSizeInBytes: bigint | number

    /**
     * is the scratch memory usage in bytes by this shader.
     */
    readonly scratchMemUsageInBytes: bigint | number
  }

  declare interface VkShaderResourceUsageAMDInitializer {
    /**
     * is the number of vector instruction general-purpose registers used by this shader.
     */
    readonly numUsedVgprs?: number

    /**
     * is the number of scalar instruction general-purpose registers used by this shader.
     */
    readonly numUsedSgprs?: number

    /**
     * is the maximum local data store size per work group in bytes.
     */
    readonly ldsSizePerLocalWorkGroup?: number

    /**
     * is the LDS usage size in bytes per work group by this shader.
     */
    readonly ldsUsageSizeInBytes?: bigint | number

    /**
     * is the scratch memory usage in bytes by this shader.
     */
    readonly scratchMemUsageInBytes?: bigint | number
  }

  declare interface VkShaderResourceUsageAMDConstructor {
    readonly prototype: VkShaderResourceUsageAMD
    new (
      param?: VkShaderResourceUsageAMDInitializer | null
    ): VkShaderResourceUsageAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkShaderResourceUsageAMD: VkShaderResourceUsageAMDConstructor

  /**
   * Structure describing whether queries can be reset from the host
   */
  interface VkPhysicalDeviceHostQueryResetFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates that the implementation supports resetting queries from the host with 'vkResetQueryPoolEXT'.
     */
    hostQueryReset: boolean
  }

  declare interface VkPhysicalDeviceHostQueryResetFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates that the implementation supports resetting queries from the host with 'vkResetQueryPoolEXT'.
     */
    hostQueryReset?: boolean
  }

  declare interface VkPhysicalDeviceHostQueryResetFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceHostQueryResetFeaturesEXT
    new (
      param?: VkPhysicalDeviceHostQueryResetFeaturesEXTInitializer | null
    ): VkPhysicalDeviceHostQueryResetFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceHostQueryResetFeaturesEXT: VkPhysicalDeviceHostQueryResetFeaturesEXTConstructor

  /**
   * Structure describing properties supported by VK_KHR_shader_float_controls
   */
  interface VkPhysicalDeviceFloatControlsPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     * is a 'VkShaderFloatControlsIndependenceKHR' value indicating whether, and how, denorm behavior can be set independently for different bit widths.
     */
    readonly denormBehaviorIndependence: VkShaderFloatControlsIndependenceKHR

    /**
     * is a 'VkShaderFloatControlsIndependenceKHR' value indicating whether, and how, rounding modes can be set independently for different bit widths.
     */
    readonly roundingModeIndependence: VkShaderFloatControlsIndependenceKHR

    /**
     * is a boolean value indicating whether sign of a zero, [eq]##Nan##s and latexmath:[\pm\infty] 'can' be preserved in 16-bit floating-point computations. It also indicates whether the 'SignedZeroInfNanPreserve' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderSignedZeroInfNanPreserveFloat16: boolean

    /**
     * is a boolean value indicating whether sign of a zero, [eq]##Nan##s and latexmath:[\pm\infty] 'can' be preserved in 32-bit floating-point computations. It also indicates whether the 'SignedZeroInfNanPreserve' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderSignedZeroInfNanPreserveFloat32: boolean

    /**
     * is a boolean value indicating whether sign of a zero, [eq]##Nan##s and latexmath:[\pm\infty] 'can' be preserved in 64-bit floating-point computations. It also indicates whether the 'SignedZeroInfNanPreserve' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderSignedZeroInfNanPreserveFloat64: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be preserved in 16-bit floating-point computations. It also indicates whether the 'DenormPreserve' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderDenormPreserveFloat16: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be preserved in 32-bit floating-point computations. It also indicates whether the 'DenormPreserve' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderDenormPreserveFloat32: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be preserved in 64-bit floating-point computations. It also indicates whether the 'DenormPreserve' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderDenormPreserveFloat64: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be flushed to zero in 16-bit floating-point computations. It also indicates whether the 'DenormFlushToZero' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderDenormFlushToZeroFloat16: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be flushed to zero in 32-bit floating-point computations. It also indicates whether the 'DenormFlushToZero' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderDenormFlushToZeroFloat32: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be flushed to zero in 64-bit floating-point computations. It also indicates whether the 'DenormFlushToZero' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderDenormFlushToZeroFloat64: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTE' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderRoundingModeRTEFloat16: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTE' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderRoundingModeRTEFloat32: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTE' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderRoundingModeRTEFloat64: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTZ' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderRoundingModeRTZFloat16: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTZ' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderRoundingModeRTZFloat32: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTZ' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderRoundingModeRTZFloat64: boolean
  }

  declare interface VkPhysicalDeviceFloatControlsPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     * is a 'VkShaderFloatControlsIndependenceKHR' value indicating whether, and how, denorm behavior can be set independently for different bit widths.
     */
    readonly denormBehaviorIndependence?: VkShaderFloatControlsIndependenceKHR

    /**
     * is a 'VkShaderFloatControlsIndependenceKHR' value indicating whether, and how, rounding modes can be set independently for different bit widths.
     */
    readonly roundingModeIndependence?: VkShaderFloatControlsIndependenceKHR

    /**
     * is a boolean value indicating whether sign of a zero, [eq]##Nan##s and latexmath:[\pm\infty] 'can' be preserved in 16-bit floating-point computations. It also indicates whether the 'SignedZeroInfNanPreserve' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderSignedZeroInfNanPreserveFloat16?: boolean

    /**
     * is a boolean value indicating whether sign of a zero, [eq]##Nan##s and latexmath:[\pm\infty] 'can' be preserved in 32-bit floating-point computations. It also indicates whether the 'SignedZeroInfNanPreserve' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderSignedZeroInfNanPreserveFloat32?: boolean

    /**
     * is a boolean value indicating whether sign of a zero, [eq]##Nan##s and latexmath:[\pm\infty] 'can' be preserved in 64-bit floating-point computations. It also indicates whether the 'SignedZeroInfNanPreserve' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderSignedZeroInfNanPreserveFloat64?: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be preserved in 16-bit floating-point computations. It also indicates whether the 'DenormPreserve' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderDenormPreserveFloat16?: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be preserved in 32-bit floating-point computations. It also indicates whether the 'DenormPreserve' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderDenormPreserveFloat32?: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be preserved in 64-bit floating-point computations. It also indicates whether the 'DenormPreserve' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderDenormPreserveFloat64?: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be flushed to zero in 16-bit floating-point computations. It also indicates whether the 'DenormFlushToZero' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderDenormFlushToZeroFloat16?: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be flushed to zero in 32-bit floating-point computations. It also indicates whether the 'DenormFlushToZero' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderDenormFlushToZeroFloat32?: boolean

    /**
     * is a boolean value indicating whether denormals 'can' be flushed to zero in 64-bit floating-point computations. It also indicates whether the 'DenormFlushToZero' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderDenormFlushToZeroFloat64?: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTE' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderRoundingModeRTEFloat16?: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTE' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderRoundingModeRTEFloat32?: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTE' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderRoundingModeRTEFloat64?: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTZ' execution mode 'can' be used for 16-bit floating-point types.
     */
    readonly shaderRoundingModeRTZFloat16?: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTZ' execution mode 'can' be used for 32-bit floating-point types.
     */
    readonly shaderRoundingModeRTZFloat32?: boolean

    /**
     * is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the 'RoundingModeRTZ' execution mode 'can' be used for 64-bit floating-point types.
     */
    readonly shaderRoundingModeRTZFloat64?: boolean
  }

  declare interface VkPhysicalDeviceFloatControlsPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceFloatControlsPropertiesKHR
    new (
      param?: VkPhysicalDeviceFloatControlsPropertiesKHRInitializer | null
    ): VkPhysicalDeviceFloatControlsPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFloatControlsPropertiesKHR: VkPhysicalDeviceFloatControlsPropertiesKHRConstructor

  /**
   *
   */
  interface VkPhysicalDeviceFloat16Int8FeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    shaderFloat16: boolean

    /**
     *
     */
    shaderInt8: boolean
  }

  declare interface VkPhysicalDeviceFloat16Int8FeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    shaderFloat16?: boolean

    /**
     *
     */
    shaderInt8?: boolean
  }

  declare interface VkPhysicalDeviceFloat16Int8FeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceFloat16Int8FeaturesKHR
    new (
      param?: VkPhysicalDeviceFloat16Int8FeaturesKHRInitializer | null
    ): VkPhysicalDeviceFloat16Int8FeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFloat16Int8FeaturesKHR: VkPhysicalDeviceFloat16Int8FeaturesKHRConstructor

  /**
   * Structure describing features supported by VK_KHR_shader_float16_int8
   */
  interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    shaderFloat16: boolean

    /**
     *
     */
    shaderInt8: boolean
  }

  declare interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    shaderFloat16?: boolean

    /**
     *
     */
    shaderInt8?: boolean
  }

  declare interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
    new (
      param?: VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInitializer | null
    ): VkPhysicalDeviceShaderFloat16Int8FeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderFloat16Int8FeaturesKHR: VkPhysicalDeviceShaderFloat16Int8FeaturesKHRConstructor

  /**
   *
   */
  interface VkPhysicalDeviceShaderDrawParameterFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    shaderDrawParameters: boolean
  }

  declare interface VkPhysicalDeviceShaderDrawParameterFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    shaderDrawParameters?: boolean
  }

  declare interface VkPhysicalDeviceShaderDrawParameterFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceShaderDrawParameterFeatures
    new (
      param?: VkPhysicalDeviceShaderDrawParameterFeaturesInitializer | null
    ): VkPhysicalDeviceShaderDrawParameterFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderDrawParameterFeatures: VkPhysicalDeviceShaderDrawParameterFeaturesConstructor

  /**
   * Structure describing shader draw parameter features that can be supported by an implementation
   */
  interface VkPhysicalDeviceShaderDrawParametersFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    shaderDrawParameters: boolean
  }

  declare interface VkPhysicalDeviceShaderDrawParametersFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    shaderDrawParameters?: boolean
  }

  declare interface VkPhysicalDeviceShaderDrawParametersFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceShaderDrawParametersFeatures
    new (
      param?: VkPhysicalDeviceShaderDrawParametersFeaturesInitializer | null
    ): VkPhysicalDeviceShaderDrawParametersFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderDrawParametersFeatures: VkPhysicalDeviceShaderDrawParametersFeaturesConstructor

  /**
   *
   */
  interface VkDescriptorSetLayoutSupportKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly supported: boolean
  }

  declare interface VkDescriptorSetLayoutSupportKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly supported?: boolean
  }

  declare interface VkDescriptorSetLayoutSupportKHRConstructor {
    readonly prototype: VkDescriptorSetLayoutSupportKHR
    new (
      param?: VkDescriptorSetLayoutSupportKHRInitializer | null
    ): VkDescriptorSetLayoutSupportKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetLayoutSupportKHR: VkDescriptorSetLayoutSupportKHRConstructor

  /**
   * Structure returning information about whether a descriptor set layout can be supported
   */
  interface VkDescriptorSetLayoutSupport {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly supported: boolean
  }

  declare interface VkDescriptorSetLayoutSupportInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly supported?: boolean
  }

  declare interface VkDescriptorSetLayoutSupportConstructor {
    readonly prototype: VkDescriptorSetLayoutSupport
    new (
      param?: VkDescriptorSetLayoutSupportInitializer | null
    ): VkDescriptorSetLayoutSupport

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetLayoutSupport: VkDescriptorSetLayoutSupportConstructor

  /**
   *
   */
  interface VkPhysicalDeviceMaintenance3PropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly maxPerSetDescriptors: number

    /**
     *
     */
    readonly maxMemoryAllocationSize: bigint | number
  }

  declare interface VkPhysicalDeviceMaintenance3PropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly maxPerSetDescriptors?: number

    /**
     *
     */
    readonly maxMemoryAllocationSize?: bigint | number
  }

  declare interface VkPhysicalDeviceMaintenance3PropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceMaintenance3PropertiesKHR
    new (
      param?: VkPhysicalDeviceMaintenance3PropertiesKHRInitializer | null
    ): VkPhysicalDeviceMaintenance3PropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMaintenance3PropertiesKHR: VkPhysicalDeviceMaintenance3PropertiesKHRConstructor

  /**
   * Structure describing descriptor set properties
   */
  interface VkPhysicalDeviceMaintenance3Properties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly maxPerSetDescriptors: number

    /**
     *
     */
    readonly maxMemoryAllocationSize: bigint | number
  }

  declare interface VkPhysicalDeviceMaintenance3PropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly maxPerSetDescriptors?: number

    /**
     *
     */
    readonly maxMemoryAllocationSize?: bigint | number
  }

  declare interface VkPhysicalDeviceMaintenance3PropertiesConstructor {
    readonly prototype: VkPhysicalDeviceMaintenance3Properties
    new (
      param?: VkPhysicalDeviceMaintenance3PropertiesInitializer | null
    ): VkPhysicalDeviceMaintenance3Properties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMaintenance3Properties: VkPhysicalDeviceMaintenance3PropertiesConstructor

  /**
   * Specify validation cache to use during shader module creation
   */
  interface VkShaderModuleValidationCacheCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the validation cache object from which the results of prior validation attempts will be written, and to which new validation results for this 'VkShaderModule' will be written (if not already present).
     */
    validationCache: VkValidationCacheEXT | null
  }

  declare interface VkShaderModuleValidationCacheCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the validation cache object from which the results of prior validation attempts will be written, and to which new validation results for this 'VkShaderModule' will be written (if not already present).
     */
    validationCache?: VkValidationCacheEXT | null
  }

  declare interface VkShaderModuleValidationCacheCreateInfoEXTConstructor {
    readonly prototype: VkShaderModuleValidationCacheCreateInfoEXT
    new (
      param?: VkShaderModuleValidationCacheCreateInfoEXTInitializer | null
    ): VkShaderModuleValidationCacheCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkShaderModuleValidationCacheCreateInfoEXT: VkShaderModuleValidationCacheCreateInfoEXTConstructor

  /**
   * Structure specifying parameters of a newly created validation cache
   */
  interface VkValidationCacheCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     *
     */
    initialDataSize: bigint | number

    /**
     * is a reference to previously retrieved validation cache data. If the validation cache data is incompatible (as defined below) with the device, the validation cache will be initially empty. If 'initialDataSize' is zero, 'pInitialData' is ignored.
     */
    pInitialData: ArrayBuffer | null
  }

  declare interface VkValidationCacheCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     *
     */
    initialDataSize?: bigint | number

    /**
     * is a reference to previously retrieved validation cache data. If the validation cache data is incompatible (as defined below) with the device, the validation cache will be initially empty. If 'initialDataSize' is zero, 'pInitialData' is ignored.
     */
    pInitialData?: ArrayBuffer | null
  }

  declare interface VkValidationCacheCreateInfoEXTConstructor {
    readonly prototype: VkValidationCacheCreateInfoEXT
    new (
      param?: VkValidationCacheCreateInfoEXTInitializer | null
    ): VkValidationCacheCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkValidationCacheCreateInfoEXT: VkValidationCacheCreateInfoEXTConstructor

  /**
   * Specify that an image {#0#} be used with a particular set of formats
   */
  interface VkImageFormatListCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    viewFormatCount: number

    /**
     * is an array which lists of all formats which 'can' be used when creating views of this image.
     */
    pViewFormats: Int32Array | null
  }

  declare interface VkImageFormatListCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    viewFormatCount?: number

    /**
     * is an array which lists of all formats which 'can' be used when creating views of this image.
     */
    pViewFormats?: Int32Array | null
  }

  declare interface VkImageFormatListCreateInfoKHRConstructor {
    readonly prototype: VkImageFormatListCreateInfoKHR
    new (
      param?: VkImageFormatListCreateInfoKHRInitializer | null
    ): VkImageFormatListCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageFormatListCreateInfoKHR: VkImageFormatListCreateInfoKHRConstructor

  /**
   * Structure specifying parameters controlling coverage modulation
   */
  interface VkPipelineCoverageModulationStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is a 'VkCoverageModulationModeNV' value controlling which color components are modulated.
     */
    coverageModulationMode: VkCoverageModulationModeNV

    /**
     * controls whether the modulation factor is looked up from a table in 'pCoverageModulationTable'.
     */
    coverageModulationTableEnable: boolean

    /**
     * is the number of elements in 'pCoverageModulationTable'.
     */
    coverageModulationTableCount: number

    /**
     * is a table of modulation factors containing a value for each number of covered samples.
     */
    pCoverageModulationTable: Float32Array | null
  }

  declare interface VkPipelineCoverageModulationStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is a 'VkCoverageModulationModeNV' value controlling which color components are modulated.
     */
    coverageModulationMode?: VkCoverageModulationModeNV

    /**
     * controls whether the modulation factor is looked up from a table in 'pCoverageModulationTable'.
     */
    coverageModulationTableEnable?: boolean

    /**
     * is the number of elements in 'pCoverageModulationTable'.
     */
    coverageModulationTableCount?: number

    /**
     * is a table of modulation factors containing a value for each number of covered samples.
     */
    pCoverageModulationTable?: Float32Array | null
  }

  declare interface VkPipelineCoverageModulationStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineCoverageModulationStateCreateInfoNV
    new (
      param?: VkPipelineCoverageModulationStateCreateInfoNVInitializer | null
    ): VkPipelineCoverageModulationStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCoverageModulationStateCreateInfoNV: VkPipelineCoverageModulationStateCreateInfoNVConstructor

  /**
   * Structure specifying the maximum number of inline uniform block bindings of a newly created descriptor pool
   */
  interface VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of inline uniform block bindings to allocate.
     */
    maxInlineUniformBlockBindings: number
  }

  declare interface VkDescriptorPoolInlineUniformBlockCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of inline uniform block bindings to allocate.
     */
    maxInlineUniformBlockBindings?: number
  }

  declare interface VkDescriptorPoolInlineUniformBlockCreateInfoEXTConstructor {
    readonly prototype: VkDescriptorPoolInlineUniformBlockCreateInfoEXT
    new (
      param?: VkDescriptorPoolInlineUniformBlockCreateInfoEXTInitializer | null
    ): VkDescriptorPoolInlineUniformBlockCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorPoolInlineUniformBlockCreateInfoEXT: VkDescriptorPoolInlineUniformBlockCreateInfoEXTConstructor

  /**
   * Structure specifying inline uniform block data
   */
  interface VkWriteDescriptorSetInlineUniformBlockEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * number of bytes of data to write to the inline uniform block.
     */
    dataSize: number

    /**
     *
     */
    pData: ArrayBuffer | null
  }

  declare interface VkWriteDescriptorSetInlineUniformBlockEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * number of bytes of data to write to the inline uniform block.
     */
    dataSize?: number

    /**
     *
     */
    pData?: ArrayBuffer | null
  }

  declare interface VkWriteDescriptorSetInlineUniformBlockEXTConstructor {
    readonly prototype: VkWriteDescriptorSetInlineUniformBlockEXT
    new (
      param?: VkWriteDescriptorSetInlineUniformBlockEXTInitializer | null
    ): VkWriteDescriptorSetInlineUniformBlockEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkWriteDescriptorSetInlineUniformBlockEXT: VkWriteDescriptorSetInlineUniformBlockEXTConstructor

  /**
   * Structure describing inline uniform block properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum size in bytes of an <<descriptorsets-inlineuniformblock, inline uniform block>> binding.
     */
    readonly maxInlineUniformBlockSize: number

    /**
     *
     */
    readonly maxPerStageDescriptorInlineUniformBlocks: number

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: number

    /**
     *
     */
    readonly maxDescriptorSetInlineUniformBlocks: number

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInlineUniformBlocks: number
  }

  declare interface VkPhysicalDeviceInlineUniformBlockPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum size in bytes of an <<descriptorsets-inlineuniformblock, inline uniform block>> binding.
     */
    readonly maxInlineUniformBlockSize?: number

    /**
     *
     */
    readonly maxPerStageDescriptorInlineUniformBlocks?: number

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks?: number

    /**
     *
     */
    readonly maxDescriptorSetInlineUniformBlocks?: number

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInlineUniformBlocks?: number
  }

  declare interface VkPhysicalDeviceInlineUniformBlockPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceInlineUniformBlockPropertiesEXT
    new (
      param?: VkPhysicalDeviceInlineUniformBlockPropertiesEXTInitializer | null
    ): VkPhysicalDeviceInlineUniformBlockPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceInlineUniformBlockPropertiesEXT: VkPhysicalDeviceInlineUniformBlockPropertiesEXTConstructor

  /**
   * Structure describing inline uniform block features that can be supported by an implementation
   */
  interface VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * indicates whether the implementation supports inline uniform block descriptors. If this feature is not enabled, 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' 'must' not be used.
     */
    inlineUniformBlock: boolean

    /**
     *ifndef::VK_EXT_descriptor_indexing[] is 'VK_FALSE' and reserved for future use.endif::VK_EXT_descriptor_indexing[] indicates whether the implementation supports updating inline uniform block descriptors after a set is bound. If this feature is not enabled, 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT' 'must' not be used with 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT'.
     */
    descriptorBindingInlineUniformBlockUpdateAfterBind: boolean
  }

  declare interface VkPhysicalDeviceInlineUniformBlockFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * indicates whether the implementation supports inline uniform block descriptors. If this feature is not enabled, 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' 'must' not be used.
     */
    inlineUniformBlock?: boolean

    /**
     *ifndef::VK_EXT_descriptor_indexing[] is 'VK_FALSE' and reserved for future use.endif::VK_EXT_descriptor_indexing[] indicates whether the implementation supports updating inline uniform block descriptors after a set is bound. If this feature is not enabled, 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT' 'must' not be used with 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT'.
     */
    descriptorBindingInlineUniformBlockUpdateAfterBind?: boolean
  }

  declare interface VkPhysicalDeviceInlineUniformBlockFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceInlineUniformBlockFeaturesEXT
    new (
      param?: VkPhysicalDeviceInlineUniformBlockFeaturesEXTInitializer | null
    ): VkPhysicalDeviceInlineUniformBlockFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceInlineUniformBlockFeaturesEXT: VkPhysicalDeviceInlineUniformBlockFeaturesEXTConstructor

  /**
   * Structure specifying parameters that affect advanced blend operations
   */
  interface VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether the source color of the blend operation is treated as premultiplied.
     */
    srcPremultiplied: boolean

    /**
     * specifies whether the destination color of the blend operation is treated as premultiplied.
     */
    dstPremultiplied: boolean

    /**
     * is a 'VkBlendOverlapEXT' value specifying how the source and destination sample's coverage is correlated.
     */
    blendOverlap: VkBlendOverlapEXT
  }

  declare interface VkPipelineColorBlendAdvancedStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether the source color of the blend operation is treated as premultiplied.
     */
    srcPremultiplied?: boolean

    /**
     * specifies whether the destination color of the blend operation is treated as premultiplied.
     */
    dstPremultiplied?: boolean

    /**
     * is a 'VkBlendOverlapEXT' value specifying how the source and destination sample's coverage is correlated.
     */
    blendOverlap?: VkBlendOverlapEXT
  }

  declare interface VkPipelineColorBlendAdvancedStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineColorBlendAdvancedStateCreateInfoEXT
    new (
      param?: VkPipelineColorBlendAdvancedStateCreateInfoEXTInitializer | null
    ): VkPipelineColorBlendAdvancedStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineColorBlendAdvancedStateCreateInfoEXT: VkPipelineColorBlendAdvancedStateCreateInfoEXTConstructor

  /**
   * Structure describing advanced blending limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is one greater than the highest color attachment index that 'can' be used in a subpass, for a pipeline that uses an <<framebuffer-blend-advanced,advanced blend operation>>.
     */
    readonly advancedBlendMaxColorAttachments: number

    /**
     * specifies whether advanced blend operations 'can' vary per-attachment.
     */
    readonly advancedBlendIndependentBlend: boolean

    /**
     * specifies whether the source color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'srcPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedSrcColor: boolean

    /**
     * specifies whether the destination color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'dstPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedDstColor: boolean

    /**
     * specifies whether the overlap mode 'can' be treated as correlated. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'blendOverlap' 'must' be 'VK_BLEND_OVERLAP_UNCORRELATED_EXT'.
     */
    readonly advancedBlendCorrelatedOverlap: boolean

    /**
     * specifies whether all advanced blend operation enums are supported. See the valid usage of 'VkPipelineColorBlendAttachmentState'.
     */
    readonly advancedBlendAllOperations: boolean
  }

  declare interface VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is one greater than the highest color attachment index that 'can' be used in a subpass, for a pipeline that uses an <<framebuffer-blend-advanced,advanced blend operation>>.
     */
    readonly advancedBlendMaxColorAttachments?: number

    /**
     * specifies whether advanced blend operations 'can' vary per-attachment.
     */
    readonly advancedBlendIndependentBlend?: boolean

    /**
     * specifies whether the source color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'srcPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedSrcColor?: boolean

    /**
     * specifies whether the destination color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'dstPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedDstColor?: boolean

    /**
     * specifies whether the overlap mode 'can' be treated as correlated. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'blendOverlap' 'must' be 'VK_BLEND_OVERLAP_UNCORRELATED_EXT'.
     */
    readonly advancedBlendCorrelatedOverlap?: boolean

    /**
     * specifies whether all advanced blend operation enums are supported. See the valid usage of 'VkPipelineColorBlendAttachmentState'.
     */
    readonly advancedBlendAllOperations?: boolean
  }

  declare interface VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
    new (
      param?: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTInitializer | null
    ): VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTConstructor

  /**
   * Structure describing advanced blending features that can be supported by an implementation
   */
  interface VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    advancedBlendCoherentOperations: boolean
  }

  declare interface VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    advancedBlendCoherentOperations?: boolean
  }

  declare interface VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTConstructor {
    readonly prototype: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
    new (
      param?: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTInitializer | null
    ): VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTConstructor

  /**
   * Structure specifying sampler reduction mode
   */
  interface VkSamplerReductionModeCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkSamplerReductionModeEXT' value controlling how texture filtering combines texel values.
     */
    reductionMode: VkSamplerReductionModeEXT
  }

  declare interface VkSamplerReductionModeCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkSamplerReductionModeEXT' value controlling how texture filtering combines texel values.
     */
    reductionMode?: VkSamplerReductionModeEXT
  }

  declare interface VkSamplerReductionModeCreateInfoEXTConstructor {
    readonly prototype: VkSamplerReductionModeCreateInfoEXT
    new (
      param?: VkSamplerReductionModeCreateInfoEXTInitializer | null
    ): VkSamplerReductionModeCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerReductionModeCreateInfoEXT: VkSamplerReductionModeCreateInfoEXTConstructor

  /**
   * Structure returning information about sample count specific additional multisampling capabilities
   */
  interface VkMultisamplePropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary.
     */
    readonly maxSampleLocationGridSize: VkExtent2D | null
  }

  declare interface VkMultisamplePropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary.
     */
    readonly maxSampleLocationGridSize?: VkExtent2D | null
  }

  declare interface VkMultisamplePropertiesEXTConstructor {
    readonly prototype: VkMultisamplePropertiesEXT
    new (
      param?: VkMultisamplePropertiesEXTInitializer | null
    ): VkMultisamplePropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMultisamplePropertiesEXT: VkMultisamplePropertiesEXTConstructor

  /**
   * Structure describing sample location limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceSampleLocationsPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask of 'VkSampleCountFlagBits' indicating the sample counts supporting custom sample locations.
     */
    readonly sampleLocationSampleCounts: VkSampleCountFlagBits

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary that is supported for all sample counts in 'sampleLocationSampleCounts'.
     */
    readonly maxSampleLocationGridSize: VkExtent2D | null

    /**
     *
     */
    readonly sampleLocationCoordinateRange: number[] | null

    /**
     * is the number of bits of subpixel precision for sample locations.
     */
    readonly sampleLocationSubPixelBits: number

    /**
     * specifies whether the sample locations used by all pipelines that will be bound to a command buffer during a subpass 'must' match. If set to 'VK_TRUE', the implementation supports variable sample locations in a subpass. If set to 'VK_FALSE', then the sample locations 'must' stay constant in each subpass.
     */
    readonly variableSampleLocations: boolean
  }

  declare interface VkPhysicalDeviceSampleLocationsPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask of 'VkSampleCountFlagBits' indicating the sample counts supporting custom sample locations.
     */
    readonly sampleLocationSampleCounts?: VkSampleCountFlagBits

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary that is supported for all sample counts in 'sampleLocationSampleCounts'.
     */
    readonly maxSampleLocationGridSize?: VkExtent2D | null

    /**
     *
     */
    readonly sampleLocationCoordinateRange?: number[] | null

    /**
     * is the number of bits of subpixel precision for sample locations.
     */
    readonly sampleLocationSubPixelBits?: number

    /**
     * specifies whether the sample locations used by all pipelines that will be bound to a command buffer during a subpass 'must' match. If set to 'VK_TRUE', the implementation supports variable sample locations in a subpass. If set to 'VK_FALSE', then the sample locations 'must' stay constant in each subpass.
     */
    readonly variableSampleLocations?: boolean
  }

  declare interface VkPhysicalDeviceSampleLocationsPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceSampleLocationsPropertiesEXT
    new (
      param?: VkPhysicalDeviceSampleLocationsPropertiesEXTInitializer | null
    ): VkPhysicalDeviceSampleLocationsPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSampleLocationsPropertiesEXT: VkPhysicalDeviceSampleLocationsPropertiesEXTConstructor

  /**
   * Structure specifying sample locations for a pipeline
   */
  interface VkPipelineSampleLocationsStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * controls whether custom sample locations are used. If 'sampleLocationsEnable' is 'VK_FALSE', the default sample locations are used and the values specified in 'sampleLocationsInfo' are ignored.
     */
    sampleLocationsEnable: boolean

    /**
     * is the sample locations to use during rasterization if 'sampleLocationsEnable' is 'VK_TRUE' and the graphics pipeline is not created with 'VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT'.
     */
    sampleLocationsInfo: VkSampleLocationsInfoEXT | null
  }

  declare interface VkPipelineSampleLocationsStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * controls whether custom sample locations are used. If 'sampleLocationsEnable' is 'VK_FALSE', the default sample locations are used and the values specified in 'sampleLocationsInfo' are ignored.
     */
    sampleLocationsEnable?: boolean

    /**
     * is the sample locations to use during rasterization if 'sampleLocationsEnable' is 'VK_TRUE' and the graphics pipeline is not created with 'VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT'.
     */
    sampleLocationsInfo?: VkSampleLocationsInfoEXT | null
  }

  declare interface VkPipelineSampleLocationsStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineSampleLocationsStateCreateInfoEXT
    new (
      param?: VkPipelineSampleLocationsStateCreateInfoEXTInitializer | null
    ): VkPipelineSampleLocationsStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineSampleLocationsStateCreateInfoEXT: VkPipelineSampleLocationsStateCreateInfoEXTConstructor

  /**
   * Structure specifying sample locations to use for the layout transition of custom sample locations compatible depth/stencil attachments
   */
  interface VkRenderPassSampleLocationsBeginInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of elements in the 'pAttachmentInitialSampleLocations' array.
     */
    attachmentInitialSampleLocationsCount: number

    /**
     * is an array of 'attachmentInitialSampleLocationsCount' 'VkAttachmentSampleLocationsEXT' structures specifying the attachment indices and their corresponding sample location state. Each element of 'pAttachmentInitialSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition a depth/stencil attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    pAttachmentInitialSampleLocations: VkAttachmentSampleLocationsEXT[] | null

    /**
     * is the number of elements in the 'pPostSubpassSampleLocations' array.
     */
    postSubpassSampleLocationsCount: number

    /**
     * is an array of 'postSubpassSampleLocationsCount' 'VkSubpassSampleLocationsEXT' structures specifying the subpass indices and their corresponding sample location state. Each element of 'pPostSubpassSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition the depth/stencil attachment used by the specified subpass to the image layout specified in a dependent subpass or to the final layout of the attachment in case the specified subpass is the last subpass using that attachment. In addition, if 'VkPhysicalDeviceSampleLocationsPropertiesEXT'::'variableSampleLocations' is 'VK_FALSE', each element of 'pPostSubpassSampleLocations' 'must' specify the sample location state that matches the sample locations used by all pipelines that will be bound to a command buffer during the specified subpass. If 'variableSampleLocations' is 'VK_TRUE', the sample locations used for rasterization do not depend on 'pPostSubpassSampleLocations'.
     */
    pPostSubpassSampleLocations: VkSubpassSampleLocationsEXT[] | null
  }

  declare interface VkRenderPassSampleLocationsBeginInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of elements in the 'pAttachmentInitialSampleLocations' array.
     */
    attachmentInitialSampleLocationsCount?: number

    /**
     * is an array of 'attachmentInitialSampleLocationsCount' 'VkAttachmentSampleLocationsEXT' structures specifying the attachment indices and their corresponding sample location state. Each element of 'pAttachmentInitialSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition a depth/stencil attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    pAttachmentInitialSampleLocations?: VkAttachmentSampleLocationsEXT[] | null

    /**
     * is the number of elements in the 'pPostSubpassSampleLocations' array.
     */
    postSubpassSampleLocationsCount?: number

    /**
     * is an array of 'postSubpassSampleLocationsCount' 'VkSubpassSampleLocationsEXT' structures specifying the subpass indices and their corresponding sample location state. Each element of 'pPostSubpassSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition the depth/stencil attachment used by the specified subpass to the image layout specified in a dependent subpass or to the final layout of the attachment in case the specified subpass is the last subpass using that attachment. In addition, if 'VkPhysicalDeviceSampleLocationsPropertiesEXT'::'variableSampleLocations' is 'VK_FALSE', each element of 'pPostSubpassSampleLocations' 'must' specify the sample location state that matches the sample locations used by all pipelines that will be bound to a command buffer during the specified subpass. If 'variableSampleLocations' is 'VK_TRUE', the sample locations used for rasterization do not depend on 'pPostSubpassSampleLocations'.
     */
    pPostSubpassSampleLocations?: VkSubpassSampleLocationsEXT[] | null
  }

  declare interface VkRenderPassSampleLocationsBeginInfoEXTConstructor {
    readonly prototype: VkRenderPassSampleLocationsBeginInfoEXT
    new (
      param?: VkRenderPassSampleLocationsBeginInfoEXTInitializer | null
    ): VkRenderPassSampleLocationsBeginInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassSampleLocationsBeginInfoEXT: VkRenderPassSampleLocationsBeginInfoEXTConstructor

  /**
   * Structure specifying the sample locations state to use for layout transitions of attachments performed after a given subpass
   */
  interface VkSubpassSampleLocationsEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the index of the subpass for which the sample locations state is provided.
     */
    subpassIndex: number

    /**
     * is the sample locations state to use for the layout transition of the depth/stencil attachment away from the image layout the attachment is used with in the subpass specified in 'subpassIndex'.
     */
    sampleLocationsInfo: VkSampleLocationsInfoEXT | null
  }

  declare interface VkSubpassSampleLocationsEXTInitializer {
    /**
     * is the index of the subpass for which the sample locations state is provided.
     */
    subpassIndex?: number

    /**
     * is the sample locations state to use for the layout transition of the depth/stencil attachment away from the image layout the attachment is used with in the subpass specified in 'subpassIndex'.
     */
    sampleLocationsInfo?: VkSampleLocationsInfoEXT | null
  }

  declare interface VkSubpassSampleLocationsEXTConstructor {
    readonly prototype: VkSubpassSampleLocationsEXT
    new (
      param?: VkSubpassSampleLocationsEXTInitializer | null
    ): VkSubpassSampleLocationsEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassSampleLocationsEXT: VkSubpassSampleLocationsEXTConstructor

  /**
   * Structure specifying the sample locations state to use in the initial layout transition of attachments
   */
  interface VkAttachmentSampleLocationsEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the index of the attachment for which the sample locations state is provided.
     */
    attachmentIndex: number

    /**
     * is the sample locations state to use for the layout transition of the given attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    sampleLocationsInfo: VkSampleLocationsInfoEXT | null
  }

  declare interface VkAttachmentSampleLocationsEXTInitializer {
    /**
     * is the index of the attachment for which the sample locations state is provided.
     */
    attachmentIndex?: number

    /**
     * is the sample locations state to use for the layout transition of the given attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    sampleLocationsInfo?: VkSampleLocationsInfoEXT | null
  }

  declare interface VkAttachmentSampleLocationsEXTConstructor {
    readonly prototype: VkAttachmentSampleLocationsEXT
    new (
      param?: VkAttachmentSampleLocationsEXTInitializer | null
    ): VkAttachmentSampleLocationsEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAttachmentSampleLocationsEXT: VkAttachmentSampleLocationsEXTConstructor

  /**
   * Structure specifying a set of sample locations
   */
  interface VkSampleLocationsInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of sample locations per pixel.
     */
    sampleLocationsPerPixel: VkSampleCountFlagBits

    /**
     * is the size of the sample location grid to select custom sample locations for.
     */
    sampleLocationGridSize: VkExtent2D | null

    /**
     * is the number of sample locations in 'pSampleLocations'.
     */
    sampleLocationsCount: number

    /**
     * is an array of 'sampleLocationsCount' 'VkSampleLocationEXT' structures.
     */
    pSampleLocations: VkSampleLocationEXT[] | null
  }

  declare interface VkSampleLocationsInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of sample locations per pixel.
     */
    sampleLocationsPerPixel?: VkSampleCountFlagBits

    /**
     * is the size of the sample location grid to select custom sample locations for.
     */
    sampleLocationGridSize?: VkExtent2D | null

    /**
     * is the number of sample locations in 'pSampleLocations'.
     */
    sampleLocationsCount?: number

    /**
     * is an array of 'sampleLocationsCount' 'VkSampleLocationEXT' structures.
     */
    pSampleLocations?: VkSampleLocationEXT[] | null
  }

  declare interface VkSampleLocationsInfoEXTConstructor {
    readonly prototype: VkSampleLocationsInfoEXT
    new (
      param?: VkSampleLocationsInfoEXTInitializer | null
    ): VkSampleLocationsInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSampleLocationsInfoEXT: VkSampleLocationsInfoEXTConstructor

  /**
   * Structure specifying the coordinates of a sample location
   */
  interface VkSampleLocationEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the horizontal coordinate of the sample's location.
     */
    x: number

    /**
     * is the vertical coordinate of the sample's location.
     */
    y: number
  }

  declare interface VkSampleLocationEXTInitializer {
    /**
     * is the horizontal coordinate of the sample's location.
     */
    x?: number

    /**
     * is the vertical coordinate of the sample's location.
     */
    y?: number
  }

  declare interface VkSampleLocationEXTConstructor {
    readonly prototype: VkSampleLocationEXT
    new (param?: VkSampleLocationEXTInitializer | null): VkSampleLocationEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSampleLocationEXT: VkSampleLocationEXTConstructor

  /**
   * Structure describing sampler filter minmax limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a boolean value indicating whether a minimum set of required formats support min/max filtering.
     */
    readonly filterMinmaxSingleComponentFormats: boolean

    /**
     * is a boolean value indicating whether the implementation supports non-identity component mapping of the image when doing min/max filtering.
     */
    readonly filterMinmaxImageComponentMapping: boolean
  }

  declare interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a boolean value indicating whether a minimum set of required formats support min/max filtering.
     */
    readonly filterMinmaxSingleComponentFormats?: boolean

    /**
     * is a boolean value indicating whether the implementation supports non-identity component mapping of the image when doing min/max filtering.
     */
    readonly filterMinmaxImageComponentMapping?: boolean
  }

  declare interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
    new (
      param?: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInitializer | null
    ): VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTConstructor

  /**
   * Structure specifying whether fragment coverage replaces a color
   */
  interface VkPipelineCoverageToColorStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * controls whether the fragment coverage value replaces a fragment color output.
     */
    coverageToColorEnable: boolean

    /**
     * controls which fragment shader color output value is replaced.
     */
    coverageToColorLocation: number
  }

  declare interface VkPipelineCoverageToColorStateCreateInfoNVInitializer {
    /**
     * is the type of this structure
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * controls whether the fragment coverage value replaces a fragment color output.
     */
    coverageToColorEnable?: boolean

    /**
     * controls which fragment shader color output value is replaced.
     */
    coverageToColorLocation?: number
  }

  declare interface VkPipelineCoverageToColorStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineCoverageToColorStateCreateInfoNV
    new (
      param?: VkPipelineCoverageToColorStateCreateInfoNVInitializer | null
    ): VkPipelineCoverageToColorStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCoverageToColorStateCreateInfoNV: VkPipelineCoverageToColorStateCreateInfoNVConstructor

  /**
   * Structure specifying the parameters used for device queue creation
   */
  interface VkDeviceQueueInfo2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure. The 'pNext' chain of 'VkDeviceQueueInfo2' is used to provide additional image parameters to 'vkGetDeviceQueue2'.
     */
    pNext: null

    /**
     * is a 'VkDeviceQueueCreateFlags' value indicating the flags used to create the device queue.
     */
    flags: VkDeviceQueueCreateFlagBits

    /**
     * is the index of the queue family to which the queue belongs.
     */
    queueFamilyIndex: number

    /**
     * is the index within this queue family of the queue to retrieve.
     */
    queueIndex: number
  }

  declare interface VkDeviceQueueInfo2Initializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure. The 'pNext' chain of 'VkDeviceQueueInfo2' is used to provide additional image parameters to 'vkGetDeviceQueue2'.
     */
    pNext?: null

    /**
     * is a 'VkDeviceQueueCreateFlags' value indicating the flags used to create the device queue.
     */
    flags?: VkDeviceQueueCreateFlagBits

    /**
     * is the index of the queue family to which the queue belongs.
     */
    queueFamilyIndex?: number

    /**
     * is the index within this queue family of the queue to retrieve.
     */
    queueIndex?: number
  }

  declare interface VkDeviceQueueInfo2Constructor {
    readonly prototype: VkDeviceQueueInfo2
    new (param?: VkDeviceQueueInfo2Initializer | null): VkDeviceQueueInfo2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceQueueInfo2: VkDeviceQueueInfo2Constructor

  /**
   * Structure describing protected memory properties that can be supported by an implementation
   */
  interface VkPhysicalDeviceProtectedMemoryProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * specifies the behavior of the implementation when <<memory-protected-access-rules, protected memory access rules>> are broken. If 'protectedNoFault' is 'VK_TRUE', breaking those rules will not result in process termination or device loss.
     */
    readonly protectedNoFault: boolean
  }

  declare interface VkPhysicalDeviceProtectedMemoryPropertiesInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * specifies the behavior of the implementation when <<memory-protected-access-rules, protected memory access rules>> are broken. If 'protectedNoFault' is 'VK_TRUE', breaking those rules will not result in process termination or device loss.
     */
    readonly protectedNoFault?: boolean
  }

  declare interface VkPhysicalDeviceProtectedMemoryPropertiesConstructor {
    readonly prototype: VkPhysicalDeviceProtectedMemoryProperties
    new (
      param?: VkPhysicalDeviceProtectedMemoryPropertiesInitializer | null
    ): VkPhysicalDeviceProtectedMemoryProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceProtectedMemoryProperties: VkPhysicalDeviceProtectedMemoryPropertiesConstructor

  /**
   * Structure describing protected memory features that can be supported by an implementation
   */
  interface VkPhysicalDeviceProtectedMemoryFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * specifies whether protected memory is supported.
     */
    protectedMemory: boolean
  }

  declare interface VkPhysicalDeviceProtectedMemoryFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * specifies whether protected memory is supported.
     */
    protectedMemory?: boolean
  }

  declare interface VkPhysicalDeviceProtectedMemoryFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceProtectedMemoryFeatures
    new (
      param?: VkPhysicalDeviceProtectedMemoryFeaturesInitializer | null
    ): VkPhysicalDeviceProtectedMemoryFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceProtectedMemoryFeatures: VkPhysicalDeviceProtectedMemoryFeaturesConstructor

  /**
   * Structure indicating whether the submission is protected
   */
  interface VkProtectedSubmitInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     * specifies whether the batch is protected. If 'protectedSubmit' is 'VK_TRUE', the batch is protected. If 'protectedSubmit' is 'VK_FALSE', the batch is unprotected. If the 'VkSubmitInfo'::'pNext' chain does not contain this structure, the batch is unprotected.
     */
    protectedSubmit: boolean
  }

  declare interface VkProtectedSubmitInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     * specifies whether the batch is protected. If 'protectedSubmit' is 'VK_TRUE', the batch is protected. If 'protectedSubmit' is 'VK_FALSE', the batch is unprotected. If the 'VkSubmitInfo'::'pNext' chain does not contain this structure, the batch is unprotected.
     */
    protectedSubmit?: boolean
  }

  declare interface VkProtectedSubmitInfoConstructor {
    readonly prototype: VkProtectedSubmitInfo
    new (param?: VkProtectedSubmitInfoInitializer | null): VkProtectedSubmitInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkProtectedSubmitInfo: VkProtectedSubmitInfoConstructor

  /**
   * Structure specifying conditional rendering begin info
   */
  interface VkConditionalRenderingBeginInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * where the predicate is located.
     */
    buffer: VkBuffer | null

    /**
     *
     */
    offset: bigint | number

    /**
     * is a bitmask of 'VkConditionalRenderingFlagsEXT' specifying the behavior of conditional rendering.
     */
    flags: VkConditionalRenderingFlagBitsEXT
  }

  declare interface VkConditionalRenderingBeginInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * where the predicate is located.
     */
    buffer?: VkBuffer | null

    /**
     *
     */
    offset?: bigint | number

    /**
     * is a bitmask of 'VkConditionalRenderingFlagsEXT' specifying the behavior of conditional rendering.
     */
    flags?: VkConditionalRenderingFlagBitsEXT
  }

  declare interface VkConditionalRenderingBeginInfoEXTConstructor {
    readonly prototype: VkConditionalRenderingBeginInfoEXT
    new (
      param?: VkConditionalRenderingBeginInfoEXTInitializer | null
    ): VkConditionalRenderingBeginInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkConditionalRenderingBeginInfoEXT: VkConditionalRenderingBeginInfoEXTConstructor

  /**
   * Structure informing whether or not texture gather bias/LOD functionality is supported for a given image format and a given physical device.
   */
  interface VkTextureLODGatherFormatPropertiesAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i>.
     */
    readonly pNext: null

    /**
     * tells if the image format can be used with texture gather bias/LOD functions, as introduced by the `<<VK_AMD_texture_gather_bias_lod>>` extension. This field is set by the implementation. User-specified value is ignored.
     */
    readonly supportsTextureGatherLODBiasAMD: boolean
  }

  declare interface VkTextureLODGatherFormatPropertiesAMDInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i>.
     */
    readonly pNext?: null

    /**
     * tells if the image format can be used with texture gather bias/LOD functions, as introduced by the `<<VK_AMD_texture_gather_bias_lod>>` extension. This field is set by the implementation. User-specified value is ignored.
     */
    readonly supportsTextureGatherLODBiasAMD?: boolean
  }

  declare interface VkTextureLODGatherFormatPropertiesAMDConstructor {
    readonly prototype: VkTextureLODGatherFormatPropertiesAMD
    new (
      param?: VkTextureLODGatherFormatPropertiesAMDInitializer | null
    ): VkTextureLODGatherFormatPropertiesAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkTextureLODGatherFormatPropertiesAMD: VkTextureLODGatherFormatPropertiesAMDConstructor

  /**
   *
   */
  interface VkSamplerYcbcrConversionImageFormatPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount: number
  }

  declare interface VkSamplerYcbcrConversionImageFormatPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount?: number
  }

  declare interface VkSamplerYcbcrConversionImageFormatPropertiesKHRConstructor {
    readonly prototype: VkSamplerYcbcrConversionImageFormatPropertiesKHR
    new (
      param?: VkSamplerYcbcrConversionImageFormatPropertiesKHRInitializer | null
    ): VkSamplerYcbcrConversionImageFormatPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerYcbcrConversionImageFormatPropertiesKHR: VkSamplerYcbcrConversionImageFormatPropertiesKHRConstructor

  /**
   * Structure specifying combined image sampler descriptor count for multi-planar images
   */
  interface VkSamplerYcbcrConversionImageFormatProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount: number
  }

  declare interface VkSamplerYcbcrConversionImageFormatPropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount?: number
  }

  declare interface VkSamplerYcbcrConversionImageFormatPropertiesConstructor {
    readonly prototype: VkSamplerYcbcrConversionImageFormatProperties
    new (
      param?: VkSamplerYcbcrConversionImageFormatPropertiesInitializer | null
    ): VkSamplerYcbcrConversionImageFormatProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerYcbcrConversionImageFormatProperties: VkSamplerYcbcrConversionImageFormatPropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    samplerYcbcrConversion: boolean
  }

  declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    samplerYcbcrConversion?: boolean
  }

  declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
    new (
      param?: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInitializer | null
    ): VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRConstructor

  /**
   * Structure describing Y\
   */
  interface VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    samplerYcbcrConversion: boolean
  }

  declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    samplerYcbcrConversion?: boolean
  }

  declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceSamplerYcbcrConversionFeatures
    new (
      param?: VkPhysicalDeviceSamplerYcbcrConversionFeaturesInitializer | null
    ): VkPhysicalDeviceSamplerYcbcrConversionFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSamplerYcbcrConversionFeatures: VkPhysicalDeviceSamplerYcbcrConversionFeaturesConstructor

  /**
   *
   */
  interface VkImagePlaneMemoryRequirementsInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits
  }

  declare interface VkImagePlaneMemoryRequirementsInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits
  }

  declare interface VkImagePlaneMemoryRequirementsInfoKHRConstructor {
    readonly prototype: VkImagePlaneMemoryRequirementsInfoKHR
    new (
      param?: VkImagePlaneMemoryRequirementsInfoKHRInitializer | null
    ): VkImagePlaneMemoryRequirementsInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImagePlaneMemoryRequirementsInfoKHR: VkImagePlaneMemoryRequirementsInfoKHRConstructor

  /**
   * Structure specifying image plane for memory requirements
   */
  interface VkImagePlaneMemoryRequirementsInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits
  }

  declare interface VkImagePlaneMemoryRequirementsInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits
  }

  declare interface VkImagePlaneMemoryRequirementsInfoConstructor {
    readonly prototype: VkImagePlaneMemoryRequirementsInfo
    new (
      param?: VkImagePlaneMemoryRequirementsInfoInitializer | null
    ): VkImagePlaneMemoryRequirementsInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImagePlaneMemoryRequirementsInfo: VkImagePlaneMemoryRequirementsInfoConstructor

  /**
   *
   */
  interface VkBindImagePlaneMemoryInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits
  }

  declare interface VkBindImagePlaneMemoryInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits
  }

  declare interface VkBindImagePlaneMemoryInfoKHRConstructor {
    readonly prototype: VkBindImagePlaneMemoryInfoKHR
    new (
      param?: VkBindImagePlaneMemoryInfoKHRInitializer | null
    ): VkBindImagePlaneMemoryInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImagePlaneMemoryInfoKHR: VkBindImagePlaneMemoryInfoKHRConstructor

  /**
   * Structure specifying how to bind an image plane to memory
   */
  interface VkBindImagePlaneMemoryInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits
  }

  declare interface VkBindImagePlaneMemoryInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits
  }

  declare interface VkBindImagePlaneMemoryInfoConstructor {
    readonly prototype: VkBindImagePlaneMemoryInfo
    new (
      param?: VkBindImagePlaneMemoryInfoInitializer | null
    ): VkBindImagePlaneMemoryInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImagePlaneMemoryInfo: VkBindImagePlaneMemoryInfoConstructor

  /**
   *
   */
  interface VkSamplerYcbcrConversionCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    format: VkFormat

    /**
     *
     */
    ycbcrModel: VkSamplerYcbcrModelConversion

    /**
     *
     */
    ycbcrRange: VkSamplerYcbcrRange

    /**
     *
     */
    components: VkComponentMapping | null

    /**
     *
     */
    xChromaOffset: VkChromaLocation

    /**
     *
     */
    yChromaOffset: VkChromaLocation

    /**
     *
     */
    chromaFilter: VkFilter

    /**
     *
     */
    forceExplicitReconstruction: boolean
  }

  declare interface VkSamplerYcbcrConversionCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    format?: VkFormat

    /**
     *
     */
    ycbcrModel?: VkSamplerYcbcrModelConversion

    /**
     *
     */
    ycbcrRange?: VkSamplerYcbcrRange

    /**
     *
     */
    components?: VkComponentMapping | null

    /**
     *
     */
    xChromaOffset?: VkChromaLocation

    /**
     *
     */
    yChromaOffset?: VkChromaLocation

    /**
     *
     */
    chromaFilter?: VkFilter

    /**
     *
     */
    forceExplicitReconstruction?: boolean
  }

  declare interface VkSamplerYcbcrConversionCreateInfoKHRConstructor {
    readonly prototype: VkSamplerYcbcrConversionCreateInfoKHR
    new (
      param?: VkSamplerYcbcrConversionCreateInfoKHRInitializer | null
    ): VkSamplerYcbcrConversionCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerYcbcrConversionCreateInfoKHR: VkSamplerYcbcrConversionCreateInfoKHRConstructor

  /**
   * Structure specifying the parameters of the newly created conversion
   */
  interface VkSamplerYcbcrConversionCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    format: VkFormat

    /**
     *
     */
    ycbcrModel: VkSamplerYcbcrModelConversion

    /**
     *
     */
    ycbcrRange: VkSamplerYcbcrRange

    /**
     *
     */
    components: VkComponentMapping | null

    /**
     *
     */
    xChromaOffset: VkChromaLocation

    /**
     *
     */
    yChromaOffset: VkChromaLocation

    /**
     *
     */
    chromaFilter: VkFilter

    /**
     *
     */
    forceExplicitReconstruction: boolean
  }

  declare interface VkSamplerYcbcrConversionCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    format?: VkFormat

    /**
     *
     */
    ycbcrModel?: VkSamplerYcbcrModelConversion

    /**
     *
     */
    ycbcrRange?: VkSamplerYcbcrRange

    /**
     *
     */
    components?: VkComponentMapping | null

    /**
     *
     */
    xChromaOffset?: VkChromaLocation

    /**
     *
     */
    yChromaOffset?: VkChromaLocation

    /**
     *
     */
    chromaFilter?: VkFilter

    /**
     *
     */
    forceExplicitReconstruction?: boolean
  }

  declare interface VkSamplerYcbcrConversionCreateInfoConstructor {
    readonly prototype: VkSamplerYcbcrConversionCreateInfo
    new (
      param?: VkSamplerYcbcrConversionCreateInfoInitializer | null
    ): VkSamplerYcbcrConversionCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerYcbcrConversionCreateInfo: VkSamplerYcbcrConversionCreateInfoConstructor

  /**
   *
   */
  interface VkSamplerYcbcrConversionInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    conversion: VkSamplerYcbcrConversion | null
  }

  declare interface VkSamplerYcbcrConversionInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    conversion?: VkSamplerYcbcrConversion | null
  }

  declare interface VkSamplerYcbcrConversionInfoKHRConstructor {
    readonly prototype: VkSamplerYcbcrConversionInfoKHR
    new (
      param?: VkSamplerYcbcrConversionInfoKHRInitializer | null
    ): VkSamplerYcbcrConversionInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerYcbcrConversionInfoKHR: VkSamplerYcbcrConversionInfoKHRConstructor

  /**
   * Structure specifying Y\
   */
  interface VkSamplerYcbcrConversionInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    conversion: VkSamplerYcbcrConversion | null
  }

  declare interface VkSamplerYcbcrConversionInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    conversion?: VkSamplerYcbcrConversion | null
  }

  declare interface VkSamplerYcbcrConversionInfoConstructor {
    readonly prototype: VkSamplerYcbcrConversionInfo
    new (
      param?: VkSamplerYcbcrConversionInfoInitializer | null
    ): VkSamplerYcbcrConversionInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerYcbcrConversionInfo: VkSamplerYcbcrConversionInfoConstructor

  /**
   *
   */
  interface VkPipelineTessellationDomainOriginStateCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    domainOrigin: VkTessellationDomainOrigin
  }

  declare interface VkPipelineTessellationDomainOriginStateCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    domainOrigin?: VkTessellationDomainOrigin
  }

  declare interface VkPipelineTessellationDomainOriginStateCreateInfoKHRConstructor {
    readonly prototype: VkPipelineTessellationDomainOriginStateCreateInfoKHR
    new (
      param?: VkPipelineTessellationDomainOriginStateCreateInfoKHRInitializer | null
    ): VkPipelineTessellationDomainOriginStateCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineTessellationDomainOriginStateCreateInfoKHR: VkPipelineTessellationDomainOriginStateCreateInfoKHRConstructor

  /**
   * Structure specifying the orientation of the tessellation domain
   */
  interface VkPipelineTessellationDomainOriginStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    domainOrigin: VkTessellationDomainOrigin
  }

  declare interface VkPipelineTessellationDomainOriginStateCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    domainOrigin?: VkTessellationDomainOrigin
  }

  declare interface VkPipelineTessellationDomainOriginStateCreateInfoConstructor {
    readonly prototype: VkPipelineTessellationDomainOriginStateCreateInfo
    new (
      param?: VkPipelineTessellationDomainOriginStateCreateInfoInitializer | null
    ): VkPipelineTessellationDomainOriginStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineTessellationDomainOriginStateCreateInfo: VkPipelineTessellationDomainOriginStateCreateInfoConstructor

  /**
   *
   */
  interface VkImageViewUsageCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    usage: VkImageUsageFlagBits
  }

  declare interface VkImageViewUsageCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    usage?: VkImageUsageFlagBits
  }

  declare interface VkImageViewUsageCreateInfoKHRConstructor {
    readonly prototype: VkImageViewUsageCreateInfoKHR
    new (
      param?: VkImageViewUsageCreateInfoKHRInitializer | null
    ): VkImageViewUsageCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageViewUsageCreateInfoKHR: VkImageViewUsageCreateInfoKHRConstructor

  /**
   * Specify the intended usage of an image view
   */
  interface VkImageViewUsageCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    usage: VkImageUsageFlagBits
  }

  declare interface VkImageViewUsageCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    usage?: VkImageUsageFlagBits
  }

  declare interface VkImageViewUsageCreateInfoConstructor {
    readonly prototype: VkImageViewUsageCreateInfo
    new (
      param?: VkImageViewUsageCreateInfoInitializer | null
    ): VkImageViewUsageCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageViewUsageCreateInfo: VkImageViewUsageCreateInfoConstructor

  /**
   *
   */
  interface VkMemoryDedicatedAllocateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null

    /**
     *
     */
    buffer: VkBuffer | null
  }

  declare interface VkMemoryDedicatedAllocateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null

    /**
     *
     */
    buffer?: VkBuffer | null
  }

  declare interface VkMemoryDedicatedAllocateInfoKHRConstructor {
    readonly prototype: VkMemoryDedicatedAllocateInfoKHR
    new (
      param?: VkMemoryDedicatedAllocateInfoKHRInitializer | null
    ): VkMemoryDedicatedAllocateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryDedicatedAllocateInfoKHR: VkMemoryDedicatedAllocateInfoKHRConstructor

  /**
   * Specify a dedicated memory allocation resource
   */
  interface VkMemoryDedicatedAllocateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null

    /**
     *
     */
    buffer: VkBuffer | null
  }

  declare interface VkMemoryDedicatedAllocateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null

    /**
     *
     */
    buffer?: VkBuffer | null
  }

  declare interface VkMemoryDedicatedAllocateInfoConstructor {
    readonly prototype: VkMemoryDedicatedAllocateInfo
    new (
      param?: VkMemoryDedicatedAllocateInfoInitializer | null
    ): VkMemoryDedicatedAllocateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryDedicatedAllocateInfo: VkMemoryDedicatedAllocateInfoConstructor

  /**
   *
   */
  interface VkMemoryDedicatedRequirementsKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly prefersDedicatedAllocation: boolean

    /**
     *
     */
    readonly requiresDedicatedAllocation: boolean
  }

  declare interface VkMemoryDedicatedRequirementsKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly prefersDedicatedAllocation?: boolean

    /**
     *
     */
    readonly requiresDedicatedAllocation?: boolean
  }

  declare interface VkMemoryDedicatedRequirementsKHRConstructor {
    readonly prototype: VkMemoryDedicatedRequirementsKHR
    new (
      param?: VkMemoryDedicatedRequirementsKHRInitializer | null
    ): VkMemoryDedicatedRequirementsKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryDedicatedRequirementsKHR: VkMemoryDedicatedRequirementsKHRConstructor

  /**
   * Structure describing dedicated allocation requirements of buffer and image resources
   */
  interface VkMemoryDedicatedRequirements {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly prefersDedicatedAllocation: boolean

    /**
     *
     */
    readonly requiresDedicatedAllocation: boolean
  }

  declare interface VkMemoryDedicatedRequirementsInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly prefersDedicatedAllocation?: boolean

    /**
     *
     */
    readonly requiresDedicatedAllocation?: boolean
  }

  declare interface VkMemoryDedicatedRequirementsConstructor {
    readonly prototype: VkMemoryDedicatedRequirements
    new (
      param?: VkMemoryDedicatedRequirementsInitializer | null
    ): VkMemoryDedicatedRequirements

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryDedicatedRequirements: VkMemoryDedicatedRequirementsConstructor

  /**
   *
   */
  interface VkPhysicalDevicePointClippingPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly pointClippingBehavior: VkPointClippingBehavior
  }

  declare interface VkPhysicalDevicePointClippingPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly pointClippingBehavior?: VkPointClippingBehavior
  }

  declare interface VkPhysicalDevicePointClippingPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDevicePointClippingPropertiesKHR
    new (
      param?: VkPhysicalDevicePointClippingPropertiesKHRInitializer | null
    ): VkPhysicalDevicePointClippingPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevicePointClippingPropertiesKHR: VkPhysicalDevicePointClippingPropertiesKHRConstructor

  /**
   * Structure describing the point clipping behavior supported by an implementation
   */
  interface VkPhysicalDevicePointClippingProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly pointClippingBehavior: VkPointClippingBehavior
  }

  declare interface VkPhysicalDevicePointClippingPropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly pointClippingBehavior?: VkPointClippingBehavior
  }

  declare interface VkPhysicalDevicePointClippingPropertiesConstructor {
    readonly prototype: VkPhysicalDevicePointClippingProperties
    new (
      param?: VkPhysicalDevicePointClippingPropertiesInitializer | null
    ): VkPhysicalDevicePointClippingProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevicePointClippingProperties: VkPhysicalDevicePointClippingPropertiesConstructor

  /**
   *
   */
  interface VkSparseImageMemoryRequirements2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly memoryRequirements: VkSparseImageMemoryRequirements | null
  }

  declare interface VkSparseImageMemoryRequirements2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly memoryRequirements?: VkSparseImageMemoryRequirements | null
  }

  declare interface VkSparseImageMemoryRequirements2KHRConstructor {
    readonly prototype: VkSparseImageMemoryRequirements2KHR
    new (
      param?: VkSparseImageMemoryRequirements2KHRInitializer | null
    ): VkSparseImageMemoryRequirements2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageMemoryRequirements2KHR: VkSparseImageMemoryRequirements2KHRConstructor

  /**
   * (None)
   */
  interface VkSparseImageMemoryRequirements2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly memoryRequirements: VkSparseImageMemoryRequirements | null
  }

  declare interface VkSparseImageMemoryRequirements2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly memoryRequirements?: VkSparseImageMemoryRequirements | null
  }

  declare interface VkSparseImageMemoryRequirements2Constructor {
    readonly prototype: VkSparseImageMemoryRequirements2
    new (
      param?: VkSparseImageMemoryRequirements2Initializer | null
    ): VkSparseImageMemoryRequirements2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageMemoryRequirements2: VkSparseImageMemoryRequirements2Constructor

  /**
   *
   */
  interface VkMemoryRequirements2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly memoryRequirements: VkMemoryRequirements | null
  }

  declare interface VkMemoryRequirements2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly memoryRequirements?: VkMemoryRequirements | null
  }

  declare interface VkMemoryRequirements2KHRConstructor {
    readonly prototype: VkMemoryRequirements2KHR
    new (
      param?: VkMemoryRequirements2KHRInitializer | null
    ): VkMemoryRequirements2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryRequirements2KHR: VkMemoryRequirements2KHRConstructor

  /**
   * Structure specifying memory requirements
   */
  interface VkMemoryRequirements2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly memoryRequirements: VkMemoryRequirements | null
  }

  declare interface VkMemoryRequirements2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly memoryRequirements?: VkMemoryRequirements | null
  }

  declare interface VkMemoryRequirements2Constructor {
    readonly prototype: VkMemoryRequirements2
    new (param?: VkMemoryRequirements2Initializer | null): VkMemoryRequirements2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryRequirements2: VkMemoryRequirements2Constructor

  /**
   *
   */
  interface VkImageSparseMemoryRequirementsInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null
  }

  declare interface VkImageSparseMemoryRequirementsInfo2KHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null
  }

  declare interface VkImageSparseMemoryRequirementsInfo2KHRConstructor {
    readonly prototype: VkImageSparseMemoryRequirementsInfo2KHR
    new (
      param?: VkImageSparseMemoryRequirementsInfo2KHRInitializer | null
    ): VkImageSparseMemoryRequirementsInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageSparseMemoryRequirementsInfo2KHR: VkImageSparseMemoryRequirementsInfo2KHRConstructor

  /**
   * (None)
   */
  interface VkImageSparseMemoryRequirementsInfo2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null
  }

  declare interface VkImageSparseMemoryRequirementsInfo2Initializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null
  }

  declare interface VkImageSparseMemoryRequirementsInfo2Constructor {
    readonly prototype: VkImageSparseMemoryRequirementsInfo2
    new (
      param?: VkImageSparseMemoryRequirementsInfo2Initializer | null
    ): VkImageSparseMemoryRequirementsInfo2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageSparseMemoryRequirementsInfo2: VkImageSparseMemoryRequirementsInfo2Constructor

  /**
   *
   */
  interface VkImageMemoryRequirementsInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null
  }

  declare interface VkImageMemoryRequirementsInfo2KHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null
  }

  declare interface VkImageMemoryRequirementsInfo2KHRConstructor {
    readonly prototype: VkImageMemoryRequirementsInfo2KHR
    new (
      param?: VkImageMemoryRequirementsInfo2KHRInitializer | null
    ): VkImageMemoryRequirementsInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageMemoryRequirementsInfo2KHR: VkImageMemoryRequirementsInfo2KHRConstructor

  /**
   * (None)
   */
  interface VkImageMemoryRequirementsInfo2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null
  }

  declare interface VkImageMemoryRequirementsInfo2Initializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null
  }

  declare interface VkImageMemoryRequirementsInfo2Constructor {
    readonly prototype: VkImageMemoryRequirementsInfo2
    new (
      param?: VkImageMemoryRequirementsInfo2Initializer | null
    ): VkImageMemoryRequirementsInfo2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageMemoryRequirementsInfo2: VkImageMemoryRequirementsInfo2Constructor

  /**
   *
   */
  interface VkBufferMemoryRequirementsInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    buffer: VkBuffer | null
  }

  declare interface VkBufferMemoryRequirementsInfo2KHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    buffer?: VkBuffer | null
  }

  declare interface VkBufferMemoryRequirementsInfo2KHRConstructor {
    readonly prototype: VkBufferMemoryRequirementsInfo2KHR
    new (
      param?: VkBufferMemoryRequirementsInfo2KHRInitializer | null
    ): VkBufferMemoryRequirementsInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferMemoryRequirementsInfo2KHR: VkBufferMemoryRequirementsInfo2KHRConstructor

  /**
   * (None)
   */
  interface VkBufferMemoryRequirementsInfo2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    buffer: VkBuffer | null
  }

  declare interface VkBufferMemoryRequirementsInfo2Initializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    buffer?: VkBuffer | null
  }

  declare interface VkBufferMemoryRequirementsInfo2Constructor {
    readonly prototype: VkBufferMemoryRequirementsInfo2
    new (
      param?: VkBufferMemoryRequirementsInfo2Initializer | null
    ): VkBufferMemoryRequirementsInfo2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferMemoryRequirementsInfo2: VkBufferMemoryRequirementsInfo2Constructor

  /**
   * Structure describing the extended types subgroups support feature for an implementation
   */
  interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a boolean that specifies whether subgroup operations can use 8-bit integer, 16-bit integer, 64-bit integer, 16-bit floating-point, and vectors of these types if the implementation supports the types.
     */
    shaderSubgroupExtendedTypes: boolean
  }

  declare interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a boolean that specifies whether subgroup operations can use 8-bit integer, 16-bit integer, 64-bit integer, 16-bit floating-point, and vectors of these types if the implementation supports the types.
     */
    shaderSubgroupExtendedTypes?: boolean
  }

  declare interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
    new (
      param?: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInitializer | null
    ): VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRConstructor

  /**
   * Structure describing subgroup support for an implementation
   */
  interface VkPhysicalDeviceSubgroupProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the default number of invocations in each subgroup. 'subgroupSize' is at least 1 if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'subgroupSize' is a power-of-two.
     */
    readonly subgroupSize: number

    /**
     * is a bitfield of 'VkShaderStageFlagBits' describing the shader stages that subgroup operations are supported in. 'supportedStages' will have the 'VK_SHADER_STAGE_COMPUTE_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly supportedStages: VkShaderStageFlagBits

    /**
     * is a bitmask of 'VkSubgroupFeatureFlagBits' specifying the sets of subgroup operations supported on this device. 'supportedOperations' will have the 'VK_SUBGROUP_FEATURE_BASIC_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly supportedOperations: VkSubgroupFeatureFlagBits

    /**
     * is a boolean specifying whether <<features-subgroup-quad,quad subgroup operations>> are available in all stages, or are restricted to fragment and compute stages.
     */
    readonly quadOperationsInAllStages: boolean
  }

  declare interface VkPhysicalDeviceSubgroupPropertiesInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the default number of invocations in each subgroup. 'subgroupSize' is at least 1 if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'subgroupSize' is a power-of-two.
     */
    readonly subgroupSize?: number

    /**
     * is a bitfield of 'VkShaderStageFlagBits' describing the shader stages that subgroup operations are supported in. 'supportedStages' will have the 'VK_SHADER_STAGE_COMPUTE_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly supportedStages?: VkShaderStageFlagBits

    /**
     * is a bitmask of 'VkSubgroupFeatureFlagBits' specifying the sets of subgroup operations supported on this device. 'supportedOperations' will have the 'VK_SUBGROUP_FEATURE_BASIC_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly supportedOperations?: VkSubgroupFeatureFlagBits

    /**
     * is a boolean specifying whether <<features-subgroup-quad,quad subgroup operations>> are available in all stages, or are restricted to fragment and compute stages.
     */
    readonly quadOperationsInAllStages?: boolean
  }

  declare interface VkPhysicalDeviceSubgroupPropertiesConstructor {
    readonly prototype: VkPhysicalDeviceSubgroupProperties
    new (
      param?: VkPhysicalDeviceSubgroupPropertiesInitializer | null
    ): VkPhysicalDeviceSubgroupProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSubgroupProperties: VkPhysicalDeviceSubgroupPropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDevice16BitStorageFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    storageBuffer16BitAccess: boolean

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess: boolean

    /**
     *
     */
    storagePushConstant16: boolean

    /**
     *
     */
    storageInputOutput16: boolean
  }

  declare interface VkPhysicalDevice16BitStorageFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    storageBuffer16BitAccess?: boolean

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess?: boolean

    /**
     *
     */
    storagePushConstant16?: boolean

    /**
     *
     */
    storageInputOutput16?: boolean
  }

  declare interface VkPhysicalDevice16BitStorageFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDevice16BitStorageFeaturesKHR
    new (
      param?: VkPhysicalDevice16BitStorageFeaturesKHRInitializer | null
    ): VkPhysicalDevice16BitStorageFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevice16BitStorageFeaturesKHR: VkPhysicalDevice16BitStorageFeaturesKHRConstructor

  /**
   * Structure describing features supported by VK_KHR_16bit_storage
   */
  interface VkPhysicalDevice16BitStorageFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    storageBuffer16BitAccess: boolean

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess: boolean

    /**
     *
     */
    storagePushConstant16: boolean

    /**
     *
     */
    storageInputOutput16: boolean
  }

  declare interface VkPhysicalDevice16BitStorageFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    storageBuffer16BitAccess?: boolean

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess?: boolean

    /**
     *
     */
    storagePushConstant16?: boolean

    /**
     *
     */
    storageInputOutput16?: boolean
  }

  declare interface VkPhysicalDevice16BitStorageFeaturesConstructor {
    readonly prototype: VkPhysicalDevice16BitStorageFeatures
    new (
      param?: VkPhysicalDevice16BitStorageFeaturesInitializer | null
    ): VkPhysicalDevice16BitStorageFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevice16BitStorageFeatures: VkPhysicalDevice16BitStorageFeaturesConstructor

  /**
   * structure describing capabilities of a surface for shared presentation
   */
  interface VkSharedPresentSurfaceCapabilitiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the shared presentable image from a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR' or 'VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR' for the surface on the specified device. 'VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT' 'must' be included in the set but implementations 'may' support additional usages.
     */
    readonly sharedPresentSupportedUsageFlags: VkImageUsageFlagBits
  }

  declare interface VkSharedPresentSurfaceCapabilitiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the shared presentable image from a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR' or 'VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR' for the surface on the specified device. 'VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT' 'must' be included in the set but implementations 'may' support additional usages.
     */
    readonly sharedPresentSupportedUsageFlags?: VkImageUsageFlagBits
  }

  declare interface VkSharedPresentSurfaceCapabilitiesKHRConstructor {
    readonly prototype: VkSharedPresentSurfaceCapabilitiesKHR
    new (
      param?: VkSharedPresentSurfaceCapabilitiesKHRInitializer | null
    ): VkSharedPresentSurfaceCapabilitiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSharedPresentSurfaceCapabilitiesKHR: VkSharedPresentSurfaceCapabilitiesKHRConstructor

  /**
   * Structure describing the capabilities of a mode and plane combination
   */
  interface VkDisplayPlaneCapabilities2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is an instance of the 'VkDisplayPlaneCapabilitiesKHR' structure.
     */
    readonly capabilities: VkDisplayPlaneCapabilitiesKHR | null
  }

  declare interface VkDisplayPlaneCapabilities2KHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is an instance of the 'VkDisplayPlaneCapabilitiesKHR' structure.
     */
    readonly capabilities?: VkDisplayPlaneCapabilitiesKHR | null
  }

  declare interface VkDisplayPlaneCapabilities2KHRConstructor {
    readonly prototype: VkDisplayPlaneCapabilities2KHR
    new (
      param?: VkDisplayPlaneCapabilities2KHRInitializer | null
    ): VkDisplayPlaneCapabilities2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPlaneCapabilities2KHR: VkDisplayPlaneCapabilities2KHRConstructor

  /**
   * Structure defining the intended configuration of a display plane
   */
  interface VkDisplayPlaneInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the display mode the application intends to program when using the specified plane.
     */
    mode: VkDisplayModeKHR | null

    /**
     *
     */
    planeIndex: number
  }

  declare interface VkDisplayPlaneInfo2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the display mode the application intends to program when using the specified plane.
     */
    mode?: VkDisplayModeKHR | null

    /**
     *
     */
    planeIndex?: number
  }

  declare interface VkDisplayPlaneInfo2KHRConstructor {
    readonly prototype: VkDisplayPlaneInfo2KHR
    new (
      param?: VkDisplayPlaneInfo2KHRInitializer | null
    ): VkDisplayPlaneInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPlaneInfo2KHR: VkDisplayPlaneInfo2KHRConstructor

  /**
   * Structure describing an available display mode
   */
  interface VkDisplayModeProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is an instance of the 'VkDisplayModePropertiesKHR' structure.
     */
    readonly displayModeProperties: VkDisplayModePropertiesKHR | null
  }

  declare interface VkDisplayModeProperties2KHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is an instance of the 'VkDisplayModePropertiesKHR' structure.
     */
    readonly displayModeProperties?: VkDisplayModePropertiesKHR | null
  }

  declare interface VkDisplayModeProperties2KHRConstructor {
    readonly prototype: VkDisplayModeProperties2KHR
    new (
      param?: VkDisplayModeProperties2KHRInitializer | null
    ): VkDisplayModeProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayModeProperties2KHR: VkDisplayModeProperties2KHRConstructor

  /**
   * Structure describing an available display plane
   */
  interface VkDisplayPlaneProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is an instance of the 'VkDisplayPlanePropertiesKHR' structure.
     */
    readonly displayPlaneProperties: VkDisplayPlanePropertiesKHR | null
  }

  declare interface VkDisplayPlaneProperties2KHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is an instance of the 'VkDisplayPlanePropertiesKHR' structure.
     */
    readonly displayPlaneProperties?: VkDisplayPlanePropertiesKHR | null
  }

  declare interface VkDisplayPlaneProperties2KHRConstructor {
    readonly prototype: VkDisplayPlaneProperties2KHR
    new (
      param?: VkDisplayPlaneProperties2KHRInitializer | null
    ): VkDisplayPlaneProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPlaneProperties2KHR: VkDisplayPlaneProperties2KHRConstructor

  /**
   * Structure describing an available display device
   */
  interface VkDisplayProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is an instance of the 'VkDisplayPropertiesKHR' structure.
     */
    readonly displayProperties: VkDisplayPropertiesKHR | null
  }

  declare interface VkDisplayProperties2KHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is an instance of the 'VkDisplayPropertiesKHR' structure.
     */
    readonly displayProperties?: VkDisplayPropertiesKHR | null
  }

  declare interface VkDisplayProperties2KHRConstructor {
    readonly prototype: VkDisplayProperties2KHR
    new (
      param?: VkDisplayProperties2KHRInitializer | null
    ): VkDisplayProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayProperties2KHR: VkDisplayProperties2KHRConstructor

  /**
   * Structure describing a supported swapchain format tuple
   */
  interface VkSurfaceFormat2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is an instance of 'VkSurfaceFormatKHR' describing a format-color space pair that is compatible with the specified surface.
     */
    readonly surfaceFormat: VkSurfaceFormatKHR | null
  }

  declare interface VkSurfaceFormat2KHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is an instance of 'VkSurfaceFormatKHR' describing a format-color space pair that is compatible with the specified surface.
     */
    readonly surfaceFormat?: VkSurfaceFormatKHR | null
  }

  declare interface VkSurfaceFormat2KHRConstructor {
    readonly prototype: VkSurfaceFormat2KHR
    new (param?: VkSurfaceFormat2KHRInitializer | null): VkSurfaceFormat2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceFormat2KHR: VkSurfaceFormat2KHRConstructor

  /**
   * Structure describing capabilities of a surface
   */
  interface VkSurfaceCapabilities2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a 'VkSurfaceCapabilitiesKHR' structure describing the capabilities of the specified surface.
     */
    readonly surfaceCapabilities: VkSurfaceCapabilitiesKHR | null
  }

  declare interface VkSurfaceCapabilities2KHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a 'VkSurfaceCapabilitiesKHR' structure describing the capabilities of the specified surface.
     */
    readonly surfaceCapabilities?: VkSurfaceCapabilitiesKHR | null
  }

  declare interface VkSurfaceCapabilities2KHRConstructor {
    readonly prototype: VkSurfaceCapabilities2KHR
    new (
      param?: VkSurfaceCapabilities2KHRInitializer | null
    ): VkSurfaceCapabilities2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceCapabilities2KHR: VkSurfaceCapabilities2KHRConstructor

  /**
   * Structure specifying a surface and related swapchain creation parameters
   */
  interface VkPhysicalDeviceSurfaceInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the surface that will be associated with the swapchain.
     */
    surface: VkSurfaceKHR | null
  }

  declare interface VkPhysicalDeviceSurfaceInfo2KHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the surface that will be associated with the swapchain.
     */
    surface?: VkSurfaceKHR | null
  }

  declare interface VkPhysicalDeviceSurfaceInfo2KHRConstructor {
    readonly prototype: VkPhysicalDeviceSurfaceInfo2KHR
    new (
      param?: VkPhysicalDeviceSurfaceInfo2KHRInitializer | null
    ): VkPhysicalDeviceSurfaceInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSurfaceInfo2KHR: VkPhysicalDeviceSurfaceInfo2KHRConstructor

  /**
   *
   */
  interface VkRenderPassInputAttachmentAspectCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    aspectReferenceCount: number

    /**
     *
     */
    pAspectReferences: VkInputAttachmentAspectReference[] | null
  }

  declare interface VkRenderPassInputAttachmentAspectCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    aspectReferenceCount?: number

    /**
     *
     */
    pAspectReferences?: VkInputAttachmentAspectReference[] | null
  }

  declare interface VkRenderPassInputAttachmentAspectCreateInfoKHRConstructor {
    readonly prototype: VkRenderPassInputAttachmentAspectCreateInfoKHR
    new (
      param?: VkRenderPassInputAttachmentAspectCreateInfoKHRInitializer | null
    ): VkRenderPassInputAttachmentAspectCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassInputAttachmentAspectCreateInfoKHR: VkRenderPassInputAttachmentAspectCreateInfoKHRConstructor

  /**
   * Structure specifying, for a given subpass/input attachment pair, which aspect {#0#} be read.
   */
  interface VkRenderPassInputAttachmentAspectCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    aspectReferenceCount: number

    /**
     *
     */
    pAspectReferences: VkInputAttachmentAspectReference[] | null
  }

  declare interface VkRenderPassInputAttachmentAspectCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    aspectReferenceCount?: number

    /**
     *
     */
    pAspectReferences?: VkInputAttachmentAspectReference[] | null
  }

  declare interface VkRenderPassInputAttachmentAspectCreateInfoConstructor {
    readonly prototype: VkRenderPassInputAttachmentAspectCreateInfo
    new (
      param?: VkRenderPassInputAttachmentAspectCreateInfoInitializer | null
    ): VkRenderPassInputAttachmentAspectCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassInputAttachmentAspectCreateInfo: VkRenderPassInputAttachmentAspectCreateInfoConstructor

  /**
   *
   */
  interface VkInputAttachmentAspectReferenceKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    subpass: number

    /**
     *
     */
    inputAttachmentIndex: number

    /**
     *
     */
    aspectMask: VkImageAspectFlagBits
  }

  declare interface VkInputAttachmentAspectReferenceKHRInitializer {
    /**
     *
     */
    subpass?: number

    /**
     *
     */
    inputAttachmentIndex?: number

    /**
     *
     */
    aspectMask?: VkImageAspectFlagBits
  }

  declare interface VkInputAttachmentAspectReferenceKHRConstructor {
    readonly prototype: VkInputAttachmentAspectReferenceKHR
    new (
      param?: VkInputAttachmentAspectReferenceKHRInitializer | null
    ): VkInputAttachmentAspectReferenceKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkInputAttachmentAspectReferenceKHR: VkInputAttachmentAspectReferenceKHRConstructor

  /**
   * Structure specifying a subpass/input attachment pair and an aspect mask that {#0#} be read.
   */
  interface VkInputAttachmentAspectReference {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    subpass: number

    /**
     *
     */
    inputAttachmentIndex: number

    /**
     *
     */
    aspectMask: VkImageAspectFlagBits
  }

  declare interface VkInputAttachmentAspectReferenceInitializer {
    /**
     *
     */
    subpass?: number

    /**
     *
     */
    inputAttachmentIndex?: number

    /**
     *
     */
    aspectMask?: VkImageAspectFlagBits
  }

  declare interface VkInputAttachmentAspectReferenceConstructor {
    readonly prototype: VkInputAttachmentAspectReference
    new (
      param?: VkInputAttachmentAspectReferenceInitializer | null
    ): VkInputAttachmentAspectReference

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkInputAttachmentAspectReference: VkInputAttachmentAspectReferenceConstructor

  /**
   * Structure describing multiview limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     *
     */
    readonly perViewPositionAllComponents: boolean
  }

  declare interface VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     *
     */
    readonly perViewPositionAllComponents?: boolean
  }

  declare interface VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXConstructor {
    readonly prototype: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
    new (
      param?: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXInitializer | null
    ): VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXConstructor

  /**
   * Structure specifying discard rectangle
   */
  interface VkPipelineDiscardRectangleStateCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the mode used to determine whether fragments that lie within the discard rectangle are discarded or not.
     */
    discardRectangleMode: VkDiscardRectangleModeEXT

    /**
     * is the number of discard rectangles used by the pipeline.
     */
    discardRectangleCount: number

    /**
     * is an array of 'VkRect2D' structures, defining the discard rectangles. If the discard rectangle state is dynamic, this member is ignored.
     */
    pDiscardRectangles: VkRect2D[] | null
  }

  declare interface VkPipelineDiscardRectangleStateCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the mode used to determine whether fragments that lie within the discard rectangle are discarded or not.
     */
    discardRectangleMode?: VkDiscardRectangleModeEXT

    /**
     * is the number of discard rectangles used by the pipeline.
     */
    discardRectangleCount?: number

    /**
     * is an array of 'VkRect2D' structures, defining the discard rectangles. If the discard rectangle state is dynamic, this member is ignored.
     */
    pDiscardRectangles?: VkRect2D[] | null
  }

  declare interface VkPipelineDiscardRectangleStateCreateInfoEXTConstructor {
    readonly prototype: VkPipelineDiscardRectangleStateCreateInfoEXT
    new (
      param?: VkPipelineDiscardRectangleStateCreateInfoEXTInitializer | null
    ): VkPipelineDiscardRectangleStateCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineDiscardRectangleStateCreateInfoEXT: VkPipelineDiscardRectangleStateCreateInfoEXTConstructor

  /**
   * Structure describing discard rectangle limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum number of active discard rectangles that 'can' be specified.
     */
    readonly maxDiscardRectangles: number
  }

  declare interface VkPhysicalDeviceDiscardRectanglePropertiesEXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum number of active discard rectangles that 'can' be specified.
     */
    readonly maxDiscardRectangles?: number
  }

  declare interface VkPhysicalDeviceDiscardRectanglePropertiesEXTConstructor {
    readonly prototype: VkPhysicalDeviceDiscardRectanglePropertiesEXT
    new (
      param?: VkPhysicalDeviceDiscardRectanglePropertiesEXTInitializer | null
    ): VkPhysicalDeviceDiscardRectanglePropertiesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDiscardRectanglePropertiesEXT: VkPhysicalDeviceDiscardRectanglePropertiesEXTConstructor

  /**
   * Structure specifying swizzle applied to primitive clip coordinates
   */
  interface VkPipelineViewportSwizzleStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the number of viewport swizzles used by the pipeline.
     */
    viewportCount: number

    /**
     * is an array of 'VkViewportSwizzleNV' structures, defining the viewport swizzles.
     */
    pViewportSwizzles: VkViewportSwizzleNV[] | null
  }

  declare interface VkPipelineViewportSwizzleStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the number of viewport swizzles used by the pipeline.
     */
    viewportCount?: number

    /**
     * is an array of 'VkViewportSwizzleNV' structures, defining the viewport swizzles.
     */
    pViewportSwizzles?: VkViewportSwizzleNV[] | null
  }

  declare interface VkPipelineViewportSwizzleStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineViewportSwizzleStateCreateInfoNV
    new (
      param?: VkPipelineViewportSwizzleStateCreateInfoNVInitializer | null
    ): VkPipelineViewportSwizzleStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineViewportSwizzleStateCreateInfoNV: VkPipelineViewportSwizzleStateCreateInfoNVConstructor

  /**
   * Structure specifying a viewport swizzle
   */
  interface VkViewportSwizzleNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the x component of the primitive
     */
    x: VkViewportCoordinateSwizzleNV

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the y component of the primitive
     */
    y: VkViewportCoordinateSwizzleNV

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the z component of the primitive
     */
    z: VkViewportCoordinateSwizzleNV

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the w component of the primitive
     */
    w: VkViewportCoordinateSwizzleNV
  }

  declare interface VkViewportSwizzleNVInitializer {
    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the x component of the primitive
     */
    x?: VkViewportCoordinateSwizzleNV

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the y component of the primitive
     */
    y?: VkViewportCoordinateSwizzleNV

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the z component of the primitive
     */
    z?: VkViewportCoordinateSwizzleNV

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the w component of the primitive
     */
    w?: VkViewportCoordinateSwizzleNV
  }

  declare interface VkViewportSwizzleNVConstructor {
    readonly prototype: VkViewportSwizzleNV
    new (param?: VkViewportSwizzleNVInitializer | null): VkViewportSwizzleNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkViewportSwizzleNV: VkViewportSwizzleNVConstructor

  /**
   * Structure specifying parameters of a newly created pipeline viewport W scaling state
   */
  interface VkPipelineViewportWScalingStateCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * controls whether viewport
     */
    viewportWScalingEnable: boolean

    /**
     * is the number of viewports used by
     */
    viewportCount: number

    /**
     * is an array of 'VkViewportWScalingNV' structures defining the
     */
    pViewportWScalings: VkViewportWScalingNV[] | null
  }

  declare interface VkPipelineViewportWScalingStateCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * controls whether viewport
     */
    viewportWScalingEnable?: boolean

    /**
     * is the number of viewports used by
     */
    viewportCount?: number

    /**
     * is an array of 'VkViewportWScalingNV' structures defining the
     */
    pViewportWScalings?: VkViewportWScalingNV[] | null
  }

  declare interface VkPipelineViewportWScalingStateCreateInfoNVConstructor {
    readonly prototype: VkPipelineViewportWScalingStateCreateInfoNV
    new (
      param?: VkPipelineViewportWScalingStateCreateInfoNVInitializer | null
    ): VkPipelineViewportWScalingStateCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineViewportWScalingStateCreateInfoNV: VkPipelineViewportWScalingStateCreateInfoNVConstructor

  /**
   * Structure specifying a viewport
   */
  interface VkViewportWScalingNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    xcoeff: number

    /**
     * are the viewport's W scaling factor for x and y respectively.
     */
    ycoeff: number
  }

  declare interface VkViewportWScalingNVInitializer {
    /**
     *
     */
    xcoeff?: number

    /**
     * are the viewport's W scaling factor for x and y respectively.
     */
    ycoeff?: number
  }

  declare interface VkViewportWScalingNVConstructor {
    readonly prototype: VkViewportWScalingNV
    new (param?: VkViewportWScalingNVInitializer | null): VkViewportWScalingNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkViewportWScalingNV: VkViewportWScalingNVConstructor

  /**
   * The earliest time image should be presented
   */
  interface VkPresentTimeGOOGLE {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is an application-provided identification value, that 'can' be used with the results of 'vkGetPastPresentationTimingGOOGLE', in order to uniquely identify this present. In order to be useful to the application, it 'should' be unique within some period of time that is meaningful to the application.
     */
    presentID: number

    /**
     * specifies that the image given 'should' not be displayed to the user any earlier than this time. 'desiredPresentTime' is a time in nanoseconds, relative to a monotonically-increasing clock (e.g. `CLOCK_MONOTONIC` (see clock_gettime(2)) on Android and Linux). A value of zero specifies that the presentation engine 'may' display the image at any time. This is useful when the application desires to provide 'presentID', but does not need a specific 'desiredPresentTime'.
     */
    desiredPresentTime: bigint | number
  }

  declare interface VkPresentTimeGOOGLEInitializer {
    /**
     * is an application-provided identification value, that 'can' be used with the results of 'vkGetPastPresentationTimingGOOGLE', in order to uniquely identify this present. In order to be useful to the application, it 'should' be unique within some period of time that is meaningful to the application.
     */
    presentID?: number

    /**
     * specifies that the image given 'should' not be displayed to the user any earlier than this time. 'desiredPresentTime' is a time in nanoseconds, relative to a monotonically-increasing clock (e.g. `CLOCK_MONOTONIC` (see clock_gettime(2)) on Android and Linux). A value of zero specifies that the presentation engine 'may' display the image at any time. This is useful when the application desires to provide 'presentID', but does not need a specific 'desiredPresentTime'.
     */
    desiredPresentTime?: bigint | number
  }

  declare interface VkPresentTimeGOOGLEConstructor {
    readonly prototype: VkPresentTimeGOOGLE
    new (param?: VkPresentTimeGOOGLEInitializer | null): VkPresentTimeGOOGLE

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPresentTimeGOOGLE: VkPresentTimeGOOGLEConstructor

  /**
   * The earliest time each image should be presented
   */
  interface VkPresentTimesInfoGOOGLE {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount: number

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentTimeGOOGLE' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pTimes' contains the earliest time to present the image corresponding to the entry in the 'VkPresentInfoKHR'::'pImageIndices' array.
     */
    pTimes: VkPresentTimeGOOGLE[] | null
  }

  declare interface VkPresentTimesInfoGOOGLEInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount?: number

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentTimeGOOGLE' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pTimes' contains the earliest time to present the image corresponding to the entry in the 'VkPresentInfoKHR'::'pImageIndices' array.
     */
    pTimes?: VkPresentTimeGOOGLE[] | null
  }

  declare interface VkPresentTimesInfoGOOGLEConstructor {
    readonly prototype: VkPresentTimesInfoGOOGLE
    new (
      param?: VkPresentTimesInfoGOOGLEInitializer | null
    ): VkPresentTimesInfoGOOGLE

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPresentTimesInfoGOOGLE: VkPresentTimesInfoGOOGLEConstructor

  /**
   * Structure containing timing information about a previously-presented image
   */
  interface VkPastPresentationTimingGOOGLE {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'presentID' (see below). It 'can' be used to uniquely identify a previous present with the 'vkQueuePresentKHR' command.
     */
    readonly presentID: number

    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'desiredPresentTime'. If non-zero, it was used by the application to indicate that an image not be presented any sooner than 'desiredPresentTime'.
     */
    readonly desiredPresentTime: bigint | number

    /**
     * is the time when the image of the 'swapchain' was actually displayed.
     */
    readonly actualPresentTime: bigint | number

    /**
     * is the time when the image of the 'swapchain' could have been displayed. This 'may' differ from 'actualPresentTime' if the application requested that the image be presented no sooner than 'VkPresentTimeGOOGLE'::'desiredPresentTime'.
     */
    readonly earliestPresentTime: bigint | number

    /**
     * is an indication of how early the 'vkQueuePresentKHR' command was processed compared to how soon it needed to be processed, and still be presented at 'earliestPresentTime'.
     */
    readonly presentMargin: bigint | number
  }

  declare interface VkPastPresentationTimingGOOGLEInitializer {
    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'presentID' (see below). It 'can' be used to uniquely identify a previous present with the 'vkQueuePresentKHR' command.
     */
    readonly presentID?: number

    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'desiredPresentTime'. If non-zero, it was used by the application to indicate that an image not be presented any sooner than 'desiredPresentTime'.
     */
    readonly desiredPresentTime?: bigint | number

    /**
     * is the time when the image of the 'swapchain' was actually displayed.
     */
    readonly actualPresentTime?: bigint | number

    /**
     * is the time when the image of the 'swapchain' could have been displayed. This 'may' differ from 'actualPresentTime' if the application requested that the image be presented no sooner than 'VkPresentTimeGOOGLE'::'desiredPresentTime'.
     */
    readonly earliestPresentTime?: bigint | number

    /**
     * is an indication of how early the 'vkQueuePresentKHR' command was processed compared to how soon it needed to be processed, and still be presented at 'earliestPresentTime'.
     */
    readonly presentMargin?: bigint | number
  }

  declare interface VkPastPresentationTimingGOOGLEConstructor {
    readonly prototype: VkPastPresentationTimingGOOGLE
    new (
      param?: VkPastPresentationTimingGOOGLEInitializer | null
    ): VkPastPresentationTimingGOOGLE

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPastPresentationTimingGOOGLE: VkPastPresentationTimingGOOGLEConstructor

  /**
   * Structure containing the RC duration of a display
   */
  interface VkRefreshCycleDurationGOOGLE {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of nanoseconds from the start of one refresh cycle to the next.
     */
    readonly refreshDuration: bigint | number
  }

  declare interface VkRefreshCycleDurationGOOGLEInitializer {
    /**
     * is the number of nanoseconds from the start of one refresh cycle to the next.
     */
    readonly refreshDuration?: bigint | number
  }

  declare interface VkRefreshCycleDurationGOOGLEConstructor {
    readonly prototype: VkRefreshCycleDurationGOOGLE
    new (
      param?: VkRefreshCycleDurationGOOGLEInitializer | null
    ): VkRefreshCycleDurationGOOGLE

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRefreshCycleDurationGOOGLE: VkRefreshCycleDurationGOOGLEConstructor

  /**
   * Structure specifying display native HDR parameters of a newly created swapchain object
   */
  interface VkSwapchainDisplayNativeHdrCreateInfoAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether local dimming is enabled for the swapchain.
     */
    localDimmingEnable: boolean
  }

  declare interface VkSwapchainDisplayNativeHdrCreateInfoAMDInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether local dimming is enabled for the swapchain.
     */
    localDimmingEnable?: boolean
  }

  declare interface VkSwapchainDisplayNativeHdrCreateInfoAMDConstructor {
    readonly prototype: VkSwapchainDisplayNativeHdrCreateInfoAMD
    new (
      param?: VkSwapchainDisplayNativeHdrCreateInfoAMDInitializer | null
    ): VkSwapchainDisplayNativeHdrCreateInfoAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSwapchainDisplayNativeHdrCreateInfoAMD: VkSwapchainDisplayNativeHdrCreateInfoAMDConstructor

  /**
   * Structure describing display native HDR specific capabilities of a surface
   */
  interface VkDisplayNativeHdrSurfaceCapabilitiesAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * specifies whether the surface supports local dimming. If this is 'VK_TRUE', 'VkSwapchainDisplayNativeHdrCreateInfoAMD' 'can' be used to explicitly enable or disable local dimming for the surface. Local dimming may also be overriden by 'vkSetLocalDimmingAMD' during the lifetime of the swapchain.
     */
    readonly localDimmingSupport: boolean
  }

  declare interface VkDisplayNativeHdrSurfaceCapabilitiesAMDInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * specifies whether the surface supports local dimming. If this is 'VK_TRUE', 'VkSwapchainDisplayNativeHdrCreateInfoAMD' 'can' be used to explicitly enable or disable local dimming for the surface. Local dimming may also be overriden by 'vkSetLocalDimmingAMD' during the lifetime of the swapchain.
     */
    readonly localDimmingSupport?: boolean
  }

  declare interface VkDisplayNativeHdrSurfaceCapabilitiesAMDConstructor {
    readonly prototype: VkDisplayNativeHdrSurfaceCapabilitiesAMD
    new (
      param?: VkDisplayNativeHdrSurfaceCapabilitiesAMDInitializer | null
    ): VkDisplayNativeHdrSurfaceCapabilitiesAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayNativeHdrSurfaceCapabilitiesAMD: VkDisplayNativeHdrSurfaceCapabilitiesAMDConstructor

  /**
   * structure to specify Hdr metadata
   */
  interface VkHdrMetadataEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the mastering display's red primary in chromaticity coordinates
     */
    displayPrimaryRed: VkXYColorEXT | null

    /**
     * is the mastering display's green primary in chromaticity coordinates
     */
    displayPrimaryGreen: VkXYColorEXT | null

    /**
     * is the mastering display's blue primary in chromaticity coordinates
     */
    displayPrimaryBlue: VkXYColorEXT | null

    /**
     * is the mastering display's white-point in chromaticity coordinates
     */
    whitePoint: VkXYColorEXT | null

    /**
     * is the maximum luminance of the mastering display in nits
     */
    maxLuminance: number

    /**
     * is the minimum luminance of the mastering display in nits
     */
    minLuminance: number

    /**
     * is content's maximum luminance in nits
     */
    maxContentLightLevel: number

    /**
     * is the maximum frame average light level in nits
     */
    maxFrameAverageLightLevel: number
  }

  declare interface VkHdrMetadataEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the mastering display's red primary in chromaticity coordinates
     */
    displayPrimaryRed?: VkXYColorEXT | null

    /**
     * is the mastering display's green primary in chromaticity coordinates
     */
    displayPrimaryGreen?: VkXYColorEXT | null

    /**
     * is the mastering display's blue primary in chromaticity coordinates
     */
    displayPrimaryBlue?: VkXYColorEXT | null

    /**
     * is the mastering display's white-point in chromaticity coordinates
     */
    whitePoint?: VkXYColorEXT | null

    /**
     * is the maximum luminance of the mastering display in nits
     */
    maxLuminance?: number

    /**
     * is the minimum luminance of the mastering display in nits
     */
    minLuminance?: number

    /**
     * is content's maximum luminance in nits
     */
    maxContentLightLevel?: number

    /**
     * is the maximum frame average light level in nits
     */
    maxFrameAverageLightLevel?: number
  }

  declare interface VkHdrMetadataEXTConstructor {
    readonly prototype: VkHdrMetadataEXT
    new (param?: VkHdrMetadataEXTInitializer | null): VkHdrMetadataEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkHdrMetadataEXT: VkHdrMetadataEXTConstructor

  /**
   * structure to specify X,Y chromaticity coordinates
   */
  interface VkXYColorEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    x: number

    /**
     *
     */
    y: number
  }

  declare interface VkXYColorEXTInitializer {
    /**
     *
     */
    x?: number

    /**
     *
     */
    y?: number
  }

  declare interface VkXYColorEXTConstructor {
    readonly prototype: VkXYColorEXT
    new (param?: VkXYColorEXTInitializer | null): VkXYColorEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkXYColorEXT: VkXYColorEXTConstructor

  /**
   *
   */
  interface VkDescriptorUpdateTemplateCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    flags: number

    /**
     *
     */
    descriptorUpdateEntryCount: number

    /**
     *
     */
    pDescriptorUpdateEntries: VkDescriptorUpdateTemplateEntry[] | null

    /**
     *
     */
    templateType: VkDescriptorUpdateTemplateType

    /**
     *
     */
    descriptorSetLayout: VkDescriptorSetLayout | null

    /**
     *
     */
    pipelineBindPoint: VkPipelineBindPoint

    /**
     *
     */
    pipelineLayout: VkPipelineLayout | null

    /**
     *
     */
    set: number
  }

  declare interface VkDescriptorUpdateTemplateCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    flags?: number

    /**
     *
     */
    descriptorUpdateEntryCount?: number

    /**
     *
     */
    pDescriptorUpdateEntries?: VkDescriptorUpdateTemplateEntry[] | null

    /**
     *
     */
    templateType?: VkDescriptorUpdateTemplateType

    /**
     *
     */
    descriptorSetLayout?: VkDescriptorSetLayout | null

    /**
     *
     */
    pipelineBindPoint?: VkPipelineBindPoint

    /**
     *
     */
    pipelineLayout?: VkPipelineLayout | null

    /**
     *
     */
    set?: number
  }

  declare interface VkDescriptorUpdateTemplateCreateInfoKHRConstructor {
    readonly prototype: VkDescriptorUpdateTemplateCreateInfoKHR
    new (
      param?: VkDescriptorUpdateTemplateCreateInfoKHRInitializer | null
    ): VkDescriptorUpdateTemplateCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorUpdateTemplateCreateInfoKHR: VkDescriptorUpdateTemplateCreateInfoKHRConstructor

  /**
   * Structure specifying parameters of a newly created descriptor update template
   */
  interface VkDescriptorUpdateTemplateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    flags: number

    /**
     *
     */
    descriptorUpdateEntryCount: number

    /**
     *
     */
    pDescriptorUpdateEntries: VkDescriptorUpdateTemplateEntry[] | null

    /**
     *
     */
    templateType: VkDescriptorUpdateTemplateType

    /**
     *
     */
    descriptorSetLayout: VkDescriptorSetLayout | null

    /**
     *
     */
    pipelineBindPoint: VkPipelineBindPoint

    /**
     *
     */
    pipelineLayout: VkPipelineLayout | null

    /**
     *
     */
    set: number
  }

  declare interface VkDescriptorUpdateTemplateCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    flags?: number

    /**
     *
     */
    descriptorUpdateEntryCount?: number

    /**
     *
     */
    pDescriptorUpdateEntries?: VkDescriptorUpdateTemplateEntry[] | null

    /**
     *
     */
    templateType?: VkDescriptorUpdateTemplateType

    /**
     *
     */
    descriptorSetLayout?: VkDescriptorSetLayout | null

    /**
     *
     */
    pipelineBindPoint?: VkPipelineBindPoint

    /**
     *
     */
    pipelineLayout?: VkPipelineLayout | null

    /**
     *
     */
    set?: number
  }

  declare interface VkDescriptorUpdateTemplateCreateInfoConstructor {
    readonly prototype: VkDescriptorUpdateTemplateCreateInfo
    new (
      param?: VkDescriptorUpdateTemplateCreateInfoInitializer | null
    ): VkDescriptorUpdateTemplateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorUpdateTemplateCreateInfo: VkDescriptorUpdateTemplateCreateInfoConstructor

  /**
   *
   */
  interface VkDescriptorUpdateTemplateEntryKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    dstBinding: number

    /**
     *
     */
    dstArrayElement: number

    /**
     *
     */
    descriptorCount: number

    /**
     *
     */
    descriptorType: VkDescriptorType

    /**
     *
     */
    offset: bigint | number

    /**
     *
     */
    stride: bigint | number
  }

  declare interface VkDescriptorUpdateTemplateEntryKHRInitializer {
    /**
     *
     */
    dstBinding?: number

    /**
     *
     */
    dstArrayElement?: number

    /**
     *
     */
    descriptorCount?: number

    /**
     *
     */
    descriptorType?: VkDescriptorType

    /**
     *
     */
    offset?: bigint | number

    /**
     *
     */
    stride?: bigint | number
  }

  declare interface VkDescriptorUpdateTemplateEntryKHRConstructor {
    readonly prototype: VkDescriptorUpdateTemplateEntryKHR
    new (
      param?: VkDescriptorUpdateTemplateEntryKHRInitializer | null
    ): VkDescriptorUpdateTemplateEntryKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorUpdateTemplateEntryKHR: VkDescriptorUpdateTemplateEntryKHRConstructor

  /**
   * Describes a single descriptor update of the descriptor update template
   */
  interface VkDescriptorUpdateTemplateEntry {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    dstBinding: number

    /**
     *
     */
    dstArrayElement: number

    /**
     *
     */
    descriptorCount: number

    /**
     *
     */
    descriptorType: VkDescriptorType

    /**
     *
     */
    offset: bigint | number

    /**
     *
     */
    stride: bigint | number
  }

  declare interface VkDescriptorUpdateTemplateEntryInitializer {
    /**
     *
     */
    dstBinding?: number

    /**
     *
     */
    dstArrayElement?: number

    /**
     *
     */
    descriptorCount?: number

    /**
     *
     */
    descriptorType?: VkDescriptorType

    /**
     *
     */
    offset?: bigint | number

    /**
     *
     */
    stride?: bigint | number
  }

  declare interface VkDescriptorUpdateTemplateEntryConstructor {
    readonly prototype: VkDescriptorUpdateTemplateEntry
    new (
      param?: VkDescriptorUpdateTemplateEntryInitializer | null
    ): VkDescriptorUpdateTemplateEntry

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorUpdateTemplateEntry: VkDescriptorUpdateTemplateEntryConstructor

  /**
   * Structure specifying parameters of a newly created swapchain object
   */
  interface VkDeviceGroupSwapchainCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitfield of modes that the swapchain 'can' be used with.
     */
    modes: VkDeviceGroupPresentModeFlagBitsKHR
  }

  declare interface VkDeviceGroupSwapchainCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitfield of modes that the swapchain 'can' be used with.
     */
    modes?: VkDeviceGroupPresentModeFlagBitsKHR
  }

  declare interface VkDeviceGroupSwapchainCreateInfoKHRConstructor {
    readonly prototype: VkDeviceGroupSwapchainCreateInfoKHR
    new (
      param?: VkDeviceGroupSwapchainCreateInfoKHRInitializer | null
    ): VkDeviceGroupSwapchainCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupSwapchainCreateInfoKHR: VkDeviceGroupSwapchainCreateInfoKHRConstructor

  /**
   *
   */
  interface VkDeviceGroupDeviceCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    physicalDeviceCount: number

    /**
     *
     */
    pPhysicalDevices: VkPhysicalDevice[] | null
  }

  declare interface VkDeviceGroupDeviceCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    physicalDeviceCount?: number

    /**
     *
     */
    pPhysicalDevices?: VkPhysicalDevice[] | null
  }

  declare interface VkDeviceGroupDeviceCreateInfoKHRConstructor {
    readonly prototype: VkDeviceGroupDeviceCreateInfoKHR
    new (
      param?: VkDeviceGroupDeviceCreateInfoKHRInitializer | null
    ): VkDeviceGroupDeviceCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupDeviceCreateInfoKHR: VkDeviceGroupDeviceCreateInfoKHRConstructor

  /**
   * Create a logical device from multiple physical devices
   */
  interface VkDeviceGroupDeviceCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    physicalDeviceCount: number

    /**
     *
     */
    pPhysicalDevices: VkPhysicalDevice[] | null
  }

  declare interface VkDeviceGroupDeviceCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    physicalDeviceCount?: number

    /**
     *
     */
    pPhysicalDevices?: VkPhysicalDevice[] | null
  }

  declare interface VkDeviceGroupDeviceCreateInfoConstructor {
    readonly prototype: VkDeviceGroupDeviceCreateInfo
    new (
      param?: VkDeviceGroupDeviceCreateInfoInitializer | null
    ): VkDeviceGroupDeviceCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupDeviceCreateInfo: VkDeviceGroupDeviceCreateInfoConstructor

  /**
   * Mode and mask controlling which physical devices\
   */
  interface VkDeviceGroupPresentInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is zero or the number of elements in 'pDeviceMasks'.
     */
    swapchainCount: number

    /**
     * is an array of device masks, one for each element of 'VkPresentInfoKHR'::pSwapchains.
     */
    pDeviceMasks: Uint32Array | null

    /**
     * is the device group present mode that will be used for this present.
     */
    mode: VkDeviceGroupPresentModeFlagBitsKHR
  }

  declare interface VkDeviceGroupPresentInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is zero or the number of elements in 'pDeviceMasks'.
     */
    swapchainCount?: number

    /**
     * is an array of device masks, one for each element of 'VkPresentInfoKHR'::pSwapchains.
     */
    pDeviceMasks?: Uint32Array | null

    /**
     * is the device group present mode that will be used for this present.
     */
    mode?: VkDeviceGroupPresentModeFlagBitsKHR
  }

  declare interface VkDeviceGroupPresentInfoKHRConstructor {
    readonly prototype: VkDeviceGroupPresentInfoKHR
    new (
      param?: VkDeviceGroupPresentInfoKHRInitializer | null
    ): VkDeviceGroupPresentInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupPresentInfoKHR: VkDeviceGroupPresentInfoKHRConstructor

  /**
   * Structure specifying parameters of the acquire
   */
  interface VkAcquireNextImageInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a non-retired swapchain from which an image is acquired.
     */
    swapchain: VkSwapchainKHR | null

    /**
     * specifies how long the function waits, in nanoseconds, if no image is available.
     */
    timeout: bigint | number

    /**
     * is 'VK_NULL_HANDLE' or a semaphore to signal.
     */
    semaphore: VkSemaphore | null

    /**
     * is 'VK_NULL_HANDLE' or a fence to signal.
     */
    fence: VkFence | null

    /**
     * is a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.
     */
    deviceMask: number
  }

  declare interface VkAcquireNextImageInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a non-retired swapchain from which an image is acquired.
     */
    swapchain?: VkSwapchainKHR | null

    /**
     * specifies how long the function waits, in nanoseconds, if no image is available.
     */
    timeout?: bigint | number

    /**
     * is 'VK_NULL_HANDLE' or a semaphore to signal.
     */
    semaphore?: VkSemaphore | null

    /**
     * is 'VK_NULL_HANDLE' or a fence to signal.
     */
    fence?: VkFence | null

    /**
     * is a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.
     */
    deviceMask?: number
  }

  declare interface VkAcquireNextImageInfoKHRConstructor {
    readonly prototype: VkAcquireNextImageInfoKHR
    new (
      param?: VkAcquireNextImageInfoKHRInitializer | null
    ): VkAcquireNextImageInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAcquireNextImageInfoKHR: VkAcquireNextImageInfoKHRConstructor

  /**
   * Structure specifying swapchain image memory to bind to
   */
  interface VkBindImageMemorySwapchainInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is 'VK_NULL_HANDLE' or a swapchain handle.
     */
    swapchain: VkSwapchainKHR | null

    /**
     *
     */
    imageIndex: number
  }

  declare interface VkBindImageMemorySwapchainInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is 'VK_NULL_HANDLE' or a swapchain handle.
     */
    swapchain?: VkSwapchainKHR | null

    /**
     *
     */
    imageIndex?: number
  }

  declare interface VkBindImageMemorySwapchainInfoKHRConstructor {
    readonly prototype: VkBindImageMemorySwapchainInfoKHR
    new (
      param?: VkBindImageMemorySwapchainInfoKHRInitializer | null
    ): VkBindImageMemorySwapchainInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImageMemorySwapchainInfoKHR: VkBindImageMemorySwapchainInfoKHRConstructor

  /**
   * Specify that an image will be bound to swapchain memory
   */
  interface VkImageSwapchainCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is 'VK_NULL_HANDLE' or a handle of a swapchain that the image will be bound to.
     */
    swapchain: VkSwapchainKHR | null
  }

  declare interface VkImageSwapchainCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is 'VK_NULL_HANDLE' or a handle of a swapchain that the image will be bound to.
     */
    swapchain?: VkSwapchainKHR | null
  }

  declare interface VkImageSwapchainCreateInfoKHRConstructor {
    readonly prototype: VkImageSwapchainCreateInfoKHR
    new (
      param?: VkImageSwapchainCreateInfoKHRInitializer | null
    ): VkImageSwapchainCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageSwapchainCreateInfoKHR: VkImageSwapchainCreateInfoKHRConstructor

  /**
   * Present capabilities from other physical devices
   */
  interface VkDeviceGroupPresentCapabilitiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     *
     */
    readonly presentMask: number[] | null

    /**
     * is a bitmask of 'VkDeviceGroupPresentModeFlagBitsKHR' indicating which device group presentation modes are supported.
     */
    readonly modes: VkDeviceGroupPresentModeFlagBitsKHR
  }

  declare interface VkDeviceGroupPresentCapabilitiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     *
     */
    readonly presentMask?: number[] | null

    /**
     * is a bitmask of 'VkDeviceGroupPresentModeFlagBitsKHR' indicating which device group presentation modes are supported.
     */
    readonly modes?: VkDeviceGroupPresentModeFlagBitsKHR
  }

  declare interface VkDeviceGroupPresentCapabilitiesKHRConstructor {
    readonly prototype: VkDeviceGroupPresentCapabilitiesKHR
    new (
      param?: VkDeviceGroupPresentCapabilitiesKHRInitializer | null
    ): VkDeviceGroupPresentCapabilitiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupPresentCapabilitiesKHR: VkDeviceGroupPresentCapabilitiesKHRConstructor

  /**
   *
   */
  interface VkDeviceGroupBindSparseInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    resourceDeviceIndex: number

    /**
     *
     */
    memoryDeviceIndex: number
  }

  declare interface VkDeviceGroupBindSparseInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    resourceDeviceIndex?: number

    /**
     *
     */
    memoryDeviceIndex?: number
  }

  declare interface VkDeviceGroupBindSparseInfoKHRConstructor {
    readonly prototype: VkDeviceGroupBindSparseInfoKHR
    new (
      param?: VkDeviceGroupBindSparseInfoKHRInitializer | null
    ): VkDeviceGroupBindSparseInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupBindSparseInfoKHR: VkDeviceGroupBindSparseInfoKHRConstructor

  /**
   * Structure indicating which instances are bound
   */
  interface VkDeviceGroupBindSparseInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    resourceDeviceIndex: number

    /**
     *
     */
    memoryDeviceIndex: number
  }

  declare interface VkDeviceGroupBindSparseInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    resourceDeviceIndex?: number

    /**
     *
     */
    memoryDeviceIndex?: number
  }

  declare interface VkDeviceGroupBindSparseInfoConstructor {
    readonly prototype: VkDeviceGroupBindSparseInfo
    new (
      param?: VkDeviceGroupBindSparseInfoInitializer | null
    ): VkDeviceGroupBindSparseInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupBindSparseInfo: VkDeviceGroupBindSparseInfoConstructor

  /**
   *
   */
  interface VkDeviceGroupSubmitInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    waitSemaphoreCount: number

    /**
     *
     */
    pWaitSemaphoreDeviceIndices: Uint32Array | null

    /**
     *
     */
    commandBufferCount: number

    /**
     *
     */
    pCommandBufferDeviceMasks: Uint32Array | null

    /**
     *
     */
    signalSemaphoreCount: number

    /**
     *
     */
    pSignalSemaphoreDeviceIndices: Uint32Array | null
  }

  declare interface VkDeviceGroupSubmitInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    waitSemaphoreCount?: number

    /**
     *
     */
    pWaitSemaphoreDeviceIndices?: Uint32Array | null

    /**
     *
     */
    commandBufferCount?: number

    /**
     *
     */
    pCommandBufferDeviceMasks?: Uint32Array | null

    /**
     *
     */
    signalSemaphoreCount?: number

    /**
     *
     */
    pSignalSemaphoreDeviceIndices?: Uint32Array | null
  }

  declare interface VkDeviceGroupSubmitInfoKHRConstructor {
    readonly prototype: VkDeviceGroupSubmitInfoKHR
    new (
      param?: VkDeviceGroupSubmitInfoKHRInitializer | null
    ): VkDeviceGroupSubmitInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupSubmitInfoKHR: VkDeviceGroupSubmitInfoKHRConstructor

  /**
   * Structure indicating which physical devices execute semaphore operations and command buffers
   */
  interface VkDeviceGroupSubmitInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    waitSemaphoreCount: number

    /**
     *
     */
    pWaitSemaphoreDeviceIndices: Uint32Array | null

    /**
     *
     */
    commandBufferCount: number

    /**
     *
     */
    pCommandBufferDeviceMasks: Uint32Array | null

    /**
     *
     */
    signalSemaphoreCount: number

    /**
     *
     */
    pSignalSemaphoreDeviceIndices: Uint32Array | null
  }

  declare interface VkDeviceGroupSubmitInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    waitSemaphoreCount?: number

    /**
     *
     */
    pWaitSemaphoreDeviceIndices?: Uint32Array | null

    /**
     *
     */
    commandBufferCount?: number

    /**
     *
     */
    pCommandBufferDeviceMasks?: Uint32Array | null

    /**
     *
     */
    signalSemaphoreCount?: number

    /**
     *
     */
    pSignalSemaphoreDeviceIndices?: Uint32Array | null
  }

  declare interface VkDeviceGroupSubmitInfoConstructor {
    readonly prototype: VkDeviceGroupSubmitInfo
    new (
      param?: VkDeviceGroupSubmitInfoInitializer | null
    ): VkDeviceGroupSubmitInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupSubmitInfo: VkDeviceGroupSubmitInfoConstructor

  /**
   *
   */
  interface VkDeviceGroupCommandBufferBeginInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceMask: number
  }

  declare interface VkDeviceGroupCommandBufferBeginInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceMask?: number
  }

  declare interface VkDeviceGroupCommandBufferBeginInfoKHRConstructor {
    readonly prototype: VkDeviceGroupCommandBufferBeginInfoKHR
    new (
      param?: VkDeviceGroupCommandBufferBeginInfoKHRInitializer | null
    ): VkDeviceGroupCommandBufferBeginInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupCommandBufferBeginInfoKHR: VkDeviceGroupCommandBufferBeginInfoKHRConstructor

  /**
   * Set the initial device mask for a command buffer
   */
  interface VkDeviceGroupCommandBufferBeginInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceMask: number
  }

  declare interface VkDeviceGroupCommandBufferBeginInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceMask?: number
  }

  declare interface VkDeviceGroupCommandBufferBeginInfoConstructor {
    readonly prototype: VkDeviceGroupCommandBufferBeginInfo
    new (
      param?: VkDeviceGroupCommandBufferBeginInfoInitializer | null
    ): VkDeviceGroupCommandBufferBeginInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupCommandBufferBeginInfo: VkDeviceGroupCommandBufferBeginInfoConstructor

  /**
   *
   */
  interface VkDeviceGroupRenderPassBeginInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceMask: number

    /**
     *
     */
    deviceRenderAreaCount: number

    /**
     *
     */
    pDeviceRenderAreas: VkRect2D[] | null
  }

  declare interface VkDeviceGroupRenderPassBeginInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceMask?: number

    /**
     *
     */
    deviceRenderAreaCount?: number

    /**
     *
     */
    pDeviceRenderAreas?: VkRect2D[] | null
  }

  declare interface VkDeviceGroupRenderPassBeginInfoKHRConstructor {
    readonly prototype: VkDeviceGroupRenderPassBeginInfoKHR
    new (
      param?: VkDeviceGroupRenderPassBeginInfoKHRInitializer | null
    ): VkDeviceGroupRenderPassBeginInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupRenderPassBeginInfoKHR: VkDeviceGroupRenderPassBeginInfoKHRConstructor

  /**
   * Set the initial device mask and render areas for a render pass instance
   */
  interface VkDeviceGroupRenderPassBeginInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceMask: number

    /**
     *
     */
    deviceRenderAreaCount: number

    /**
     *
     */
    pDeviceRenderAreas: VkRect2D[] | null
  }

  declare interface VkDeviceGroupRenderPassBeginInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceMask?: number

    /**
     *
     */
    deviceRenderAreaCount?: number

    /**
     *
     */
    pDeviceRenderAreas?: VkRect2D[] | null
  }

  declare interface VkDeviceGroupRenderPassBeginInfoConstructor {
    readonly prototype: VkDeviceGroupRenderPassBeginInfo
    new (
      param?: VkDeviceGroupRenderPassBeginInfoInitializer | null
    ): VkDeviceGroupRenderPassBeginInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGroupRenderPassBeginInfo: VkDeviceGroupRenderPassBeginInfoConstructor

  /**
   *
   */
  interface VkBindImageMemoryDeviceGroupInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceIndexCount: number

    /**
     *
     */
    pDeviceIndices: Uint32Array | null

    /**
     *
     */
    splitInstanceBindRegionCount: number

    /**
     *
     */
    pSplitInstanceBindRegions: VkRect2D[] | null
  }

  declare interface VkBindImageMemoryDeviceGroupInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceIndexCount?: number

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null

    /**
     *
     */
    splitInstanceBindRegionCount?: number

    /**
     *
     */
    pSplitInstanceBindRegions?: VkRect2D[] | null
  }

  declare interface VkBindImageMemoryDeviceGroupInfoKHRConstructor {
    readonly prototype: VkBindImageMemoryDeviceGroupInfoKHR
    new (
      param?: VkBindImageMemoryDeviceGroupInfoKHRInitializer | null
    ): VkBindImageMemoryDeviceGroupInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImageMemoryDeviceGroupInfoKHR: VkBindImageMemoryDeviceGroupInfoKHRConstructor

  /**
   * Structure specifying device within a group to bind to
   */
  interface VkBindImageMemoryDeviceGroupInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceIndexCount: number

    /**
     *
     */
    pDeviceIndices: Uint32Array | null

    /**
     *
     */
    splitInstanceBindRegionCount: number

    /**
     *
     */
    pSplitInstanceBindRegions: VkRect2D[] | null
  }

  declare interface VkBindImageMemoryDeviceGroupInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceIndexCount?: number

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null

    /**
     *
     */
    splitInstanceBindRegionCount?: number

    /**
     *
     */
    pSplitInstanceBindRegions?: VkRect2D[] | null
  }

  declare interface VkBindImageMemoryDeviceGroupInfoConstructor {
    readonly prototype: VkBindImageMemoryDeviceGroupInfo
    new (
      param?: VkBindImageMemoryDeviceGroupInfoInitializer | null
    ): VkBindImageMemoryDeviceGroupInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImageMemoryDeviceGroupInfo: VkBindImageMemoryDeviceGroupInfoConstructor

  /**
   *
   */
  interface VkBindImageMemoryInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null

    /**
     *
     */
    memory: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset: bigint | number
  }

  declare interface VkBindImageMemoryInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null

    /**
     *
     */
    memory?: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset?: bigint | number
  }

  declare interface VkBindImageMemoryInfoKHRConstructor {
    readonly prototype: VkBindImageMemoryInfoKHR
    new (
      param?: VkBindImageMemoryInfoKHRInitializer | null
    ): VkBindImageMemoryInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImageMemoryInfoKHR: VkBindImageMemoryInfoKHRConstructor

  /**
   * Structure specifying how to bind an image to memory
   */
  interface VkBindImageMemoryInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    image: VkImage | null

    /**
     *
     */
    memory: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset: bigint | number
  }

  declare interface VkBindImageMemoryInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    image?: VkImage | null

    /**
     *
     */
    memory?: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset?: bigint | number
  }

  declare interface VkBindImageMemoryInfoConstructor {
    readonly prototype: VkBindImageMemoryInfo
    new (param?: VkBindImageMemoryInfoInitializer | null): VkBindImageMemoryInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindImageMemoryInfo: VkBindImageMemoryInfoConstructor

  /**
   *
   */
  interface VkBindBufferMemoryDeviceGroupInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceIndexCount: number

    /**
     *
     */
    pDeviceIndices: Uint32Array | null
  }

  declare interface VkBindBufferMemoryDeviceGroupInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceIndexCount?: number

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null
  }

  declare interface VkBindBufferMemoryDeviceGroupInfoKHRConstructor {
    readonly prototype: VkBindBufferMemoryDeviceGroupInfoKHR
    new (
      param?: VkBindBufferMemoryDeviceGroupInfoKHRInitializer | null
    ): VkBindBufferMemoryDeviceGroupInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindBufferMemoryDeviceGroupInfoKHR: VkBindBufferMemoryDeviceGroupInfoKHRConstructor

  /**
   * Structure specifying device within a group to bind to
   */
  interface VkBindBufferMemoryDeviceGroupInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    deviceIndexCount: number

    /**
     *
     */
    pDeviceIndices: Uint32Array | null
  }

  declare interface VkBindBufferMemoryDeviceGroupInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    deviceIndexCount?: number

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null
  }

  declare interface VkBindBufferMemoryDeviceGroupInfoConstructor {
    readonly prototype: VkBindBufferMemoryDeviceGroupInfo
    new (
      param?: VkBindBufferMemoryDeviceGroupInfoInitializer | null
    ): VkBindBufferMemoryDeviceGroupInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindBufferMemoryDeviceGroupInfo: VkBindBufferMemoryDeviceGroupInfoConstructor

  /**
   *
   */
  interface VkBindBufferMemoryInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    buffer: VkBuffer | null

    /**
     *
     */
    memory: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset: bigint | number
  }

  declare interface VkBindBufferMemoryInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    buffer?: VkBuffer | null

    /**
     *
     */
    memory?: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset?: bigint | number
  }

  declare interface VkBindBufferMemoryInfoKHRConstructor {
    readonly prototype: VkBindBufferMemoryInfoKHR
    new (
      param?: VkBindBufferMemoryInfoKHRInitializer | null
    ): VkBindBufferMemoryInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindBufferMemoryInfoKHR: VkBindBufferMemoryInfoKHRConstructor

  /**
   * Structure specifying how to bind a buffer to memory
   */
  interface VkBindBufferMemoryInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    buffer: VkBuffer | null

    /**
     *
     */
    memory: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset: bigint | number
  }

  declare interface VkBindBufferMemoryInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    buffer?: VkBuffer | null

    /**
     *
     */
    memory?: VkDeviceMemory | null

    /**
     *
     */
    memoryOffset?: bigint | number
  }

  declare interface VkBindBufferMemoryInfoConstructor {
    readonly prototype: VkBindBufferMemoryInfo
    new (
      param?: VkBindBufferMemoryInfoInitializer | null
    ): VkBindBufferMemoryInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindBufferMemoryInfo: VkBindBufferMemoryInfoConstructor

  /**
   *
   */
  interface VkMemoryAllocateFlagsInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    flags: VkMemoryAllocateFlagBits

    /**
     *
     */
    deviceMask: number
  }

  declare interface VkMemoryAllocateFlagsInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    flags?: VkMemoryAllocateFlagBits

    /**
     *
     */
    deviceMask?: number
  }

  declare interface VkMemoryAllocateFlagsInfoKHRConstructor {
    readonly prototype: VkMemoryAllocateFlagsInfoKHR
    new (
      param?: VkMemoryAllocateFlagsInfoKHRInitializer | null
    ): VkMemoryAllocateFlagsInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryAllocateFlagsInfoKHR: VkMemoryAllocateFlagsInfoKHRConstructor

  /**
   * Structure controlling how many instances of memory will be allocated
   */
  interface VkMemoryAllocateFlagsInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    flags: VkMemoryAllocateFlagBits

    /**
     *
     */
    deviceMask: number
  }

  declare interface VkMemoryAllocateFlagsInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    flags?: VkMemoryAllocateFlagBits

    /**
     *
     */
    deviceMask?: number
  }

  declare interface VkMemoryAllocateFlagsInfoConstructor {
    readonly prototype: VkMemoryAllocateFlagsInfo
    new (
      param?: VkMemoryAllocateFlagsInfoInitializer | null
    ): VkMemoryAllocateFlagsInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryAllocateFlagsInfo: VkMemoryAllocateFlagsInfoConstructor

  /**
   *
   */
  interface VkPhysicalDeviceGroupPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly physicalDeviceCount: number

    /**
     *
     */
    readonly physicalDevices: VkPhysicalDevice[] | null

    /**
     *
     */
    readonly subsetAllocation: boolean
  }

  declare interface VkPhysicalDeviceGroupPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly physicalDeviceCount?: number

    /**
     *
     */
    readonly physicalDevices?: VkPhysicalDevice[] | null

    /**
     *
     */
    readonly subsetAllocation?: boolean
  }

  declare interface VkPhysicalDeviceGroupPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceGroupPropertiesKHR
    new (
      param?: VkPhysicalDeviceGroupPropertiesKHRInitializer | null
    ): VkPhysicalDeviceGroupPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceGroupPropertiesKHR: VkPhysicalDeviceGroupPropertiesKHRConstructor

  /**
   * Structure specifying physical device group properties
   */
  interface VkPhysicalDeviceGroupProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly physicalDeviceCount: number

    /**
     *
     */
    readonly physicalDevices: VkPhysicalDevice[] | null

    /**
     *
     */
    readonly subsetAllocation: boolean
  }

  declare interface VkPhysicalDeviceGroupPropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly physicalDeviceCount?: number

    /**
     *
     */
    readonly physicalDevices?: VkPhysicalDevice[] | null

    /**
     *
     */
    readonly subsetAllocation?: boolean
  }

  declare interface VkPhysicalDeviceGroupPropertiesConstructor {
    readonly prototype: VkPhysicalDeviceGroupProperties
    new (
      param?: VkPhysicalDeviceGroupPropertiesInitializer | null
    ): VkPhysicalDeviceGroupProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceGroupProperties: VkPhysicalDeviceGroupPropertiesConstructor

  /**
   * Specify the surface counters desired
   */
  interface VkSwapchainCounterCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' specifying surface counters to enable for the swapchain.
     */
    surfaceCounters: VkSurfaceCounterFlagBitsEXT
  }

  declare interface VkSwapchainCounterCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' specifying surface counters to enable for the swapchain.
     */
    surfaceCounters?: VkSurfaceCounterFlagBitsEXT
  }

  declare interface VkSwapchainCounterCreateInfoEXTConstructor {
    readonly prototype: VkSwapchainCounterCreateInfoEXT
    new (
      param?: VkSwapchainCounterCreateInfoEXTInitializer | null
    ): VkSwapchainCounterCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSwapchainCounterCreateInfoEXT: VkSwapchainCounterCreateInfoEXTConstructor

  /**
   * Describe a display event to create
   */
  interface VkDisplayEventInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkDisplayEventTypeEXT' specifying when the fence will be signaled.
     */
    displayEvent: VkDisplayEventTypeEXT
  }

  declare interface VkDisplayEventInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkDisplayEventTypeEXT' specifying when the fence will be signaled.
     */
    displayEvent?: VkDisplayEventTypeEXT
  }

  declare interface VkDisplayEventInfoEXTConstructor {
    readonly prototype: VkDisplayEventInfoEXT
    new (param?: VkDisplayEventInfoEXTInitializer | null): VkDisplayEventInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayEventInfoEXT: VkDisplayEventInfoEXTConstructor

  /**
   * Describe a device event to create
   */
  interface VkDeviceEventInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    deviceEvent: VkDeviceEventTypeEXT
  }

  declare interface VkDeviceEventInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    deviceEvent?: VkDeviceEventTypeEXT
  }

  declare interface VkDeviceEventInfoEXTConstructor {
    readonly prototype: VkDeviceEventInfoEXT
    new (param?: VkDeviceEventInfoEXTInitializer | null): VkDeviceEventInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceEventInfoEXT: VkDeviceEventInfoEXTConstructor

  /**
   * Describe the power state of a display
   */
  interface VkDisplayPowerInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkDisplayPowerStateEXT' value specifying the new power state of the display.
     */
    powerState: VkDisplayPowerStateEXT
  }

  declare interface VkDisplayPowerInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkDisplayPowerStateEXT' value specifying the new power state of the display.
     */
    powerState?: VkDisplayPowerStateEXT
  }

  declare interface VkDisplayPowerInfoEXTConstructor {
    readonly prototype: VkDisplayPowerInfoEXT
    new (param?: VkDisplayPowerInfoEXTInitializer | null): VkDisplayPowerInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPowerInfoEXT: VkDisplayPowerInfoEXTConstructor

  /**
   * Structure describing capabilities of a surface
   */
  interface VkSurfaceCapabilities2EXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     *
     */
    readonly minImageCount: number

    /**
     *
     */
    readonly maxImageCount: number

    /**
     *
     */
    readonly currentExtent: VkExtent2D | null

    /**
     *
     */
    readonly minImageExtent: VkExtent2D | null

    /**
     *
     */
    readonly maxImageExtent: VkExtent2D | null

    /**
     *
     */
    readonly maxImageArrayLayers: number

    /**
     *
     */
    readonly supportedTransforms: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    readonly currentTransform: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    readonly supportedCompositeAlpha: VkCompositeAlphaFlagBitsKHR

    /**
     *
     */
    readonly supportedUsageFlags: VkImageUsageFlagBits

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' indicating the supported surface counter types.
     */
    readonly supportedSurfaceCounters: VkSurfaceCounterFlagBitsEXT
  }

  declare interface VkSurfaceCapabilities2EXTInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     *
     */
    readonly minImageCount?: number

    /**
     *
     */
    readonly maxImageCount?: number

    /**
     *
     */
    readonly currentExtent?: VkExtent2D | null

    /**
     *
     */
    readonly minImageExtent?: VkExtent2D | null

    /**
     *
     */
    readonly maxImageExtent?: VkExtent2D | null

    /**
     *
     */
    readonly maxImageArrayLayers?: number

    /**
     *
     */
    readonly supportedTransforms?: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    readonly currentTransform?: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    readonly supportedCompositeAlpha?: VkCompositeAlphaFlagBitsKHR

    /**
     *
     */
    readonly supportedUsageFlags?: VkImageUsageFlagBits

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' indicating the supported surface counter types.
     */
    readonly supportedSurfaceCounters?: VkSurfaceCounterFlagBitsEXT
  }

  declare interface VkSurfaceCapabilities2EXTConstructor {
    readonly prototype: VkSurfaceCapabilities2EXT
    new (
      param?: VkSurfaceCapabilities2EXTInitializer | null
    ): VkSurfaceCapabilities2EXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceCapabilities2EXT: VkSurfaceCapabilities2EXTConstructor

  /**
   *
   */
  interface VkRenderPassMultiviewCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    subpassCount: number

    /**
     *
     */
    pViewMasks: Uint32Array | null

    /**
     *
     */
    dependencyCount: number

    /**
     *
     */
    pViewOffsets: Int32Array | null

    /**
     *
     */
    correlationMaskCount: number

    /**
     *
     */
    pCorrelationMasks: Uint32Array | null
  }

  declare interface VkRenderPassMultiviewCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    subpassCount?: number

    /**
     *
     */
    pViewMasks?: Uint32Array | null

    /**
     *
     */
    dependencyCount?: number

    /**
     *
     */
    pViewOffsets?: Int32Array | null

    /**
     *
     */
    correlationMaskCount?: number

    /**
     *
     */
    pCorrelationMasks?: Uint32Array | null
  }

  declare interface VkRenderPassMultiviewCreateInfoKHRConstructor {
    readonly prototype: VkRenderPassMultiviewCreateInfoKHR
    new (
      param?: VkRenderPassMultiviewCreateInfoKHRInitializer | null
    ): VkRenderPassMultiviewCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassMultiviewCreateInfoKHR: VkRenderPassMultiviewCreateInfoKHRConstructor

  /**
   * Structure containing multiview info for all subpasses
   */
  interface VkRenderPassMultiviewCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    subpassCount: number

    /**
     *
     */
    pViewMasks: Uint32Array | null

    /**
     *
     */
    dependencyCount: number

    /**
     *
     */
    pViewOffsets: Int32Array | null

    /**
     *
     */
    correlationMaskCount: number

    /**
     *
     */
    pCorrelationMasks: Uint32Array | null
  }

  declare interface VkRenderPassMultiviewCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    subpassCount?: number

    /**
     *
     */
    pViewMasks?: Uint32Array | null

    /**
     *
     */
    dependencyCount?: number

    /**
     *
     */
    pViewOffsets?: Int32Array | null

    /**
     *
     */
    correlationMaskCount?: number

    /**
     *
     */
    pCorrelationMasks?: Uint32Array | null
  }

  declare interface VkRenderPassMultiviewCreateInfoConstructor {
    readonly prototype: VkRenderPassMultiviewCreateInfo
    new (
      param?: VkRenderPassMultiviewCreateInfoInitializer | null
    ): VkRenderPassMultiviewCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassMultiviewCreateInfo: VkRenderPassMultiviewCreateInfoConstructor

  /**
   *
   */
  interface VkPhysicalDeviceMultiviewPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly maxMultiviewViewCount: number

    /**
     *
     */
    readonly maxMultiviewInstanceIndex: number
  }

  declare interface VkPhysicalDeviceMultiviewPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly maxMultiviewViewCount?: number

    /**
     *
     */
    readonly maxMultiviewInstanceIndex?: number
  }

  declare interface VkPhysicalDeviceMultiviewPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceMultiviewPropertiesKHR
    new (
      param?: VkPhysicalDeviceMultiviewPropertiesKHRInitializer | null
    ): VkPhysicalDeviceMultiviewPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMultiviewPropertiesKHR: VkPhysicalDeviceMultiviewPropertiesKHRConstructor

  /**
   * Structure describing multiview limits that can be supported by an implementation
   */
  interface VkPhysicalDeviceMultiviewProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly maxMultiviewViewCount: number

    /**
     *
     */
    readonly maxMultiviewInstanceIndex: number
  }

  declare interface VkPhysicalDeviceMultiviewPropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly maxMultiviewViewCount?: number

    /**
     *
     */
    readonly maxMultiviewInstanceIndex?: number
  }

  declare interface VkPhysicalDeviceMultiviewPropertiesConstructor {
    readonly prototype: VkPhysicalDeviceMultiviewProperties
    new (
      param?: VkPhysicalDeviceMultiviewPropertiesInitializer | null
    ): VkPhysicalDeviceMultiviewProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMultiviewProperties: VkPhysicalDeviceMultiviewPropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceMultiviewFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    multiview: boolean

    /**
     *
     */
    multiviewGeometryShader: boolean

    /**
     *
     */
    multiviewTessellationShader: boolean
  }

  declare interface VkPhysicalDeviceMultiviewFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    multiview?: boolean

    /**
     *
     */
    multiviewGeometryShader?: boolean

    /**
     *
     */
    multiviewTessellationShader?: boolean
  }

  declare interface VkPhysicalDeviceMultiviewFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceMultiviewFeaturesKHR
    new (
      param?: VkPhysicalDeviceMultiviewFeaturesKHRInitializer | null
    ): VkPhysicalDeviceMultiviewFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMultiviewFeaturesKHR: VkPhysicalDeviceMultiviewFeaturesKHRConstructor

  /**
   * Structure describing multiview features that can be supported by an implementation
   */
  interface VkPhysicalDeviceMultiviewFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    multiview: boolean

    /**
     *
     */
    multiviewGeometryShader: boolean

    /**
     *
     */
    multiviewTessellationShader: boolean
  }

  declare interface VkPhysicalDeviceMultiviewFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    multiview?: boolean

    /**
     *
     */
    multiviewGeometryShader?: boolean

    /**
     *
     */
    multiviewTessellationShader?: boolean
  }

  declare interface VkPhysicalDeviceMultiviewFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceMultiviewFeatures
    new (
      param?: VkPhysicalDeviceMultiviewFeaturesInitializer | null
    ): VkPhysicalDeviceMultiviewFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMultiviewFeatures: VkPhysicalDeviceMultiviewFeaturesConstructor

  /**
   * Structure describing a POSIX FD fence export operation
   */
  interface VkFenceGetFdInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the fence from which state will be exported.
     */
    fence: VkFence | null

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkFenceGetFdInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the fence from which state will be exported.
     */
    fence?: VkFence | null

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkFenceGetFdInfoKHRConstructor {
    readonly prototype: VkFenceGetFdInfoKHR
    new (param?: VkFenceGetFdInfoKHRInitializer | null): VkFenceGetFdInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFenceGetFdInfoKHR: VkFenceGetFdInfoKHRConstructor

  /**
   * (None)
   */
  interface VkImportFenceFdInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the fence into which the payload will be imported.
     */
    fence: VkFence | null

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags: VkFenceImportFlagBits

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits

    /**
     * is the external handle to import.
     */
    fd: number
  }

  declare interface VkImportFenceFdInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the fence into which the payload will be imported.
     */
    fence?: VkFence | null

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags?: VkFenceImportFlagBits

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits

    /**
     * is the external handle to import.
     */
    fd?: number
  }

  declare interface VkImportFenceFdInfoKHRConstructor {
    readonly prototype: VkImportFenceFdInfoKHR
    new (
      param?: VkImportFenceFdInfoKHRInitializer | null
    ): VkImportFenceFdInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportFenceFdInfoKHR: VkImportFenceFdInfoKHRConstructor

  /**
   * Structure describing a Win32 handle fence export operation
   */
  interface VkFenceGetWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the fence from which state will be exported.
     */
    fence: VkFence | null

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkFenceGetWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the fence from which state will be exported.
     */
    fence?: VkFence | null

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkFenceGetWin32HandleInfoKHRConstructor {
    readonly prototype: VkFenceGetWin32HandleInfoKHR
    new (
      param?: VkFenceGetWin32HandleInfoKHRInitializer | null
    ): VkFenceGetWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFenceGetWin32HandleInfoKHR: VkFenceGetWin32HandleInfoKHRConstructor

  /**
   * Structure specifying additional attributes of Windows handles exported from a fence
   */
  interface VkExportFenceWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.
     */
    name: string | null
  }

  declare interface VkExportFenceWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.
     */
    name?: string | null
  }

  declare interface VkExportFenceWin32HandleInfoKHRConstructor {
    readonly prototype: VkExportFenceWin32HandleInfoKHR
    new (
      param?: VkExportFenceWin32HandleInfoKHRInitializer | null
    ): VkExportFenceWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportFenceWin32HandleInfoKHR: VkExportFenceWin32HandleInfoKHRConstructor

  /**
   * (None)
   */
  interface VkImportFenceWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the fence into which the state will be imported.
     */
    fence: VkFence | null

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags: VkFenceImportFlagBits

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle: bigint | number

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name: string | null
  }

  declare interface VkImportFenceWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the fence into which the state will be imported.
     */
    fence?: VkFence | null

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags?: VkFenceImportFlagBits

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle?: bigint | number

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name?: string | null
  }

  declare interface VkImportFenceWin32HandleInfoKHRConstructor {
    readonly prototype: VkImportFenceWin32HandleInfoKHR
    new (
      param?: VkImportFenceWin32HandleInfoKHRInitializer | null
    ): VkImportFenceWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportFenceWin32HandleInfoKHR: VkImportFenceWin32HandleInfoKHRConstructor

  /**
   *
   */
  interface VkExportFenceCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkExportFenceCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkExportFenceCreateInfoKHRConstructor {
    readonly prototype: VkExportFenceCreateInfoKHR
    new (
      param?: VkExportFenceCreateInfoKHRInitializer | null
    ): VkExportFenceCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportFenceCreateInfoKHR: VkExportFenceCreateInfoKHRConstructor

  /**
   * Structure specifying handle types that can be exported from a fence
   */
  interface VkExportFenceCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkExportFenceCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkExportFenceCreateInfoConstructor {
    readonly prototype: VkExportFenceCreateInfo
    new (
      param?: VkExportFenceCreateInfoInitializer | null
    ): VkExportFenceCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportFenceCreateInfo: VkExportFenceCreateInfoConstructor

  /**
   *
   */
  interface VkExternalFencePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly externalFenceFeatures: VkExternalFenceFeatureFlagBits
  }

  declare interface VkExternalFencePropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly externalFenceFeatures?: VkExternalFenceFeatureFlagBits
  }

  declare interface VkExternalFencePropertiesKHRConstructor {
    readonly prototype: VkExternalFencePropertiesKHR
    new (
      param?: VkExternalFencePropertiesKHRInitializer | null
    ): VkExternalFencePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalFencePropertiesKHR: VkExternalFencePropertiesKHRConstructor

  /**
   * Structure describing supported external fence handle features
   */
  interface VkExternalFenceProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly externalFenceFeatures: VkExternalFenceFeatureFlagBits
  }

  declare interface VkExternalFencePropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalFenceHandleTypeFlagBits

    /**
     *
     */
    readonly externalFenceFeatures?: VkExternalFenceFeatureFlagBits
  }

  declare interface VkExternalFencePropertiesConstructor {
    readonly prototype: VkExternalFenceProperties
    new (
      param?: VkExternalFencePropertiesInitializer | null
    ): VkExternalFenceProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalFenceProperties: VkExternalFencePropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceExternalFenceInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalFenceInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalFenceInfoKHRConstructor {
    readonly prototype: VkPhysicalDeviceExternalFenceInfoKHR
    new (
      param?: VkPhysicalDeviceExternalFenceInfoKHRInitializer | null
    ): VkPhysicalDeviceExternalFenceInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalFenceInfoKHR: VkPhysicalDeviceExternalFenceInfoKHRConstructor

  /**
   * Structure specifying fence creation parameters.
   */
  interface VkPhysicalDeviceExternalFenceInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalFenceInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalFenceInfoConstructor {
    readonly prototype: VkPhysicalDeviceExternalFenceInfo
    new (
      param?: VkPhysicalDeviceExternalFenceInfoInitializer | null
    ): VkPhysicalDeviceExternalFenceInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalFenceInfo: VkPhysicalDeviceExternalFenceInfoConstructor

  /**
   * Structure describing a POSIX FD semaphore export operation
   */
  interface VkSemaphoreGetFdInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore: VkSemaphore | null

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkSemaphoreGetFdInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore?: VkSemaphore | null

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkSemaphoreGetFdInfoKHRConstructor {
    readonly prototype: VkSemaphoreGetFdInfoKHR
    new (
      param?: VkSemaphoreGetFdInfoKHRInitializer | null
    ): VkSemaphoreGetFdInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSemaphoreGetFdInfoKHR: VkSemaphoreGetFdInfoKHRConstructor

  /**
   * Structure specifying POSIX file descriptor to import to a semaphore
   */
  interface VkImportSemaphoreFdInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore: VkSemaphore | null

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags: VkSemaphoreImportFlagBits

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits

    /**
     * is the external handle to import.
     */
    fd: number
  }

  declare interface VkImportSemaphoreFdInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore?: VkSemaphore | null

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags?: VkSemaphoreImportFlagBits

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits

    /**
     * is the external handle to import.
     */
    fd?: number
  }

  declare interface VkImportSemaphoreFdInfoKHRConstructor {
    readonly prototype: VkImportSemaphoreFdInfoKHR
    new (
      param?: VkImportSemaphoreFdInfoKHRInitializer | null
    ): VkImportSemaphoreFdInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportSemaphoreFdInfoKHR: VkImportSemaphoreFdInfoKHRConstructor

  /**
   * Structure describing a Win32 handle semaphore export operation
   */
  interface VkSemaphoreGetWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore: VkSemaphore | null

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkSemaphoreGetWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore?: VkSemaphore | null

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkSemaphoreGetWin32HandleInfoKHRConstructor {
    readonly prototype: VkSemaphoreGetWin32HandleInfoKHR
    new (
      param?: VkSemaphoreGetWin32HandleInfoKHRInitializer | null
    ): VkSemaphoreGetWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSemaphoreGetWin32HandleInfoKHR: VkSemaphoreGetWin32HandleInfoKHRConstructor

  /**
   * Structure specifying values for Direct3D 12 fence-backed semaphores
   */
  interface VkD3D12FenceSubmitInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of semaphore wait values specified in 'pWaitSemaphoreValues'.
     */
    waitSemaphoreValuesCount: number

    /**
     * is an array of 'waitSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pWaitSemaphores' to wait for.
     */
    pWaitSemaphoreValues: BigUint64Array | null

    /**
     * is the number of semaphore signal values specified in 'pSignalSemaphoreValues'.
     */
    signalSemaphoreValuesCount: number

    /**
     * is an array of 'signalSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pSignalSemaphores' to set when signaled.
     */
    pSignalSemaphoreValues: BigUint64Array | null
  }

  declare interface VkD3D12FenceSubmitInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of semaphore wait values specified in 'pWaitSemaphoreValues'.
     */
    waitSemaphoreValuesCount?: number

    /**
     * is an array of 'waitSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pWaitSemaphores' to wait for.
     */
    pWaitSemaphoreValues?: BigUint64Array | null

    /**
     * is the number of semaphore signal values specified in 'pSignalSemaphoreValues'.
     */
    signalSemaphoreValuesCount?: number

    /**
     * is an array of 'signalSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pSignalSemaphores' to set when signaled.
     */
    pSignalSemaphoreValues?: BigUint64Array | null
  }

  declare interface VkD3D12FenceSubmitInfoKHRConstructor {
    readonly prototype: VkD3D12FenceSubmitInfoKHR
    new (
      param?: VkD3D12FenceSubmitInfoKHRInitializer | null
    ): VkD3D12FenceSubmitInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkD3D12FenceSubmitInfoKHR: VkD3D12FenceSubmitInfoKHRConstructor

  /**
   * Structure specifying additional attributes of Windows handles exported from a semaphore
   */
  interface VkExportSemaphoreWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.
     */
    name: string | null
  }

  declare interface VkExportSemaphoreWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.
     */
    name?: string | null
  }

  declare interface VkExportSemaphoreWin32HandleInfoKHRConstructor {
    readonly prototype: VkExportSemaphoreWin32HandleInfoKHR
    new (
      param?: VkExportSemaphoreWin32HandleInfoKHRInitializer | null
    ): VkExportSemaphoreWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportSemaphoreWin32HandleInfoKHR: VkExportSemaphoreWin32HandleInfoKHRConstructor

  /**
   * Structure specifying Windows handle to import to a semaphore
   */
  interface VkImportSemaphoreWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore: VkSemaphore | null

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags: VkSemaphoreImportFlagBits

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle: bigint | number

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name: string | null
  }

  declare interface VkImportSemaphoreWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore?: VkSemaphore | null

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags?: VkSemaphoreImportFlagBits

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle?: bigint | number

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name?: string | null
  }

  declare interface VkImportSemaphoreWin32HandleInfoKHRConstructor {
    readonly prototype: VkImportSemaphoreWin32HandleInfoKHR
    new (
      param?: VkImportSemaphoreWin32HandleInfoKHRInitializer | null
    ): VkImportSemaphoreWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportSemaphoreWin32HandleInfoKHR: VkImportSemaphoreWin32HandleInfoKHRConstructor

  /**
   *
   */
  interface VkExportSemaphoreCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkExportSemaphoreCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkExportSemaphoreCreateInfoKHRConstructor {
    readonly prototype: VkExportSemaphoreCreateInfoKHR
    new (
      param?: VkExportSemaphoreCreateInfoKHRInitializer | null
    ): VkExportSemaphoreCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportSemaphoreCreateInfoKHR: VkExportSemaphoreCreateInfoKHRConstructor

  /**
   * Structure specifying handle types that can be exported from a semaphore
   */
  interface VkExportSemaphoreCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkExportSemaphoreCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkExportSemaphoreCreateInfoConstructor {
    readonly prototype: VkExportSemaphoreCreateInfo
    new (
      param?: VkExportSemaphoreCreateInfoInitializer | null
    ): VkExportSemaphoreCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportSemaphoreCreateInfo: VkExportSemaphoreCreateInfoConstructor

  /**
   *
   */
  interface VkExternalSemaphorePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlagBits
  }

  declare interface VkExternalSemaphorePropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly externalSemaphoreFeatures?: VkExternalSemaphoreFeatureFlagBits
  }

  declare interface VkExternalSemaphorePropertiesKHRConstructor {
    readonly prototype: VkExternalSemaphorePropertiesKHR
    new (
      param?: VkExternalSemaphorePropertiesKHRInitializer | null
    ): VkExternalSemaphorePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalSemaphorePropertiesKHR: VkExternalSemaphorePropertiesKHRConstructor

  /**
   * Structure describing supported external semaphore handle features
   */
  interface VkExternalSemaphoreProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlagBits
  }

  declare interface VkExternalSemaphorePropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits

    /**
     *
     */
    readonly externalSemaphoreFeatures?: VkExternalSemaphoreFeatureFlagBits
  }

  declare interface VkExternalSemaphorePropertiesConstructor {
    readonly prototype: VkExternalSemaphoreProperties
    new (
      param?: VkExternalSemaphorePropertiesInitializer | null
    ): VkExternalSemaphoreProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalSemaphoreProperties: VkExternalSemaphorePropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceExternalSemaphoreInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalSemaphoreInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalSemaphoreInfoKHRConstructor {
    readonly prototype: VkPhysicalDeviceExternalSemaphoreInfoKHR
    new (
      param?: VkPhysicalDeviceExternalSemaphoreInfoKHRInitializer | null
    ): VkPhysicalDeviceExternalSemaphoreInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalSemaphoreInfoKHR: VkPhysicalDeviceExternalSemaphoreInfoKHRConstructor

  /**
   * Structure specifying semaphore creation parameters.
   */
  interface VkPhysicalDeviceExternalSemaphoreInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalSemaphoreInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalSemaphoreInfoConstructor {
    readonly prototype: VkPhysicalDeviceExternalSemaphoreInfo
    new (
      param?: VkPhysicalDeviceExternalSemaphoreInfoInitializer | null
    ): VkPhysicalDeviceExternalSemaphoreInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalSemaphoreInfo: VkPhysicalDeviceExternalSemaphoreInfoConstructor

  /**
   * Use the Windows keyed mutex mechanism to synchronize work
   */
  interface VkWin32KeyedMutexAcquireReleaseInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    acquireCount: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys: BigUint64Array | null

    /**
     *
     */
    pAcquireTimeouts: Uint32Array | null

    /**
     *
     */
    releaseCount: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys: BigUint64Array | null
  }

  declare interface VkWin32KeyedMutexAcquireReleaseInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    acquireCount?: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs?: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys?: BigUint64Array | null

    /**
     *
     */
    pAcquireTimeouts?: Uint32Array | null

    /**
     *
     */
    releaseCount?: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs?: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys?: BigUint64Array | null
  }

  declare interface VkWin32KeyedMutexAcquireReleaseInfoKHRConstructor {
    readonly prototype: VkWin32KeyedMutexAcquireReleaseInfoKHR
    new (
      param?: VkWin32KeyedMutexAcquireReleaseInfoKHRInitializer | null
    ): VkWin32KeyedMutexAcquireReleaseInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkWin32KeyedMutexAcquireReleaseInfoKHR: VkWin32KeyedMutexAcquireReleaseInfoKHRConstructor

  /**
   * Structure describing a POSIX FD semaphore export operation
   */
  interface VkMemoryGetFdInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the memory object from which the handle will be exported.
     */
    memory: VkDeviceMemory | null

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkMemoryGetFdInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the memory object from which the handle will be exported.
     */
    memory?: VkDeviceMemory | null

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkMemoryGetFdInfoKHRConstructor {
    readonly prototype: VkMemoryGetFdInfoKHR
    new (param?: VkMemoryGetFdInfoKHRInitializer | null): VkMemoryGetFdInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryGetFdInfoKHR: VkMemoryGetFdInfoKHRConstructor

  /**
   * Properties of External Memory File Descriptors
   */
  interface VkMemoryFdPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask containing one bit set for every memory type which the specified file descriptor 'can' be imported as.
     */
    readonly memoryTypeBits: number
  }

  declare interface VkMemoryFdPropertiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask containing one bit set for every memory type which the specified file descriptor 'can' be imported as.
     */
    readonly memoryTypeBits?: number
  }

  declare interface VkMemoryFdPropertiesKHRConstructor {
    readonly prototype: VkMemoryFdPropertiesKHR
    new (
      param?: VkMemoryFdPropertiesKHRInitializer | null
    ): VkMemoryFdPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryFdPropertiesKHR: VkMemoryFdPropertiesKHRConstructor

  /**
   * import memory created on the same physical device from a file descriptor
   */
  interface VkImportMemoryFdInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits

    /**
     * is the external handle to import.
     */
    fd: number
  }

  declare interface VkImportMemoryFdInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits

    /**
     * is the external handle to import.
     */
    fd?: number
  }

  declare interface VkImportMemoryFdInfoKHRConstructor {
    readonly prototype: VkImportMemoryFdInfoKHR
    new (
      param?: VkImportMemoryFdInfoKHRInitializer | null
    ): VkImportMemoryFdInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportMemoryFdInfoKHR: VkImportMemoryFdInfoKHRConstructor

  /**
   * Structure describing a Win32 handle semaphore export operation
   */
  interface VkMemoryGetWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the memory object from which the handle will be exported.
     */
    memory: VkDeviceMemory | null

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkMemoryGetWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the memory object from which the handle will be exported.
     */
    memory?: VkDeviceMemory | null

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkMemoryGetWin32HandleInfoKHRConstructor {
    readonly prototype: VkMemoryGetWin32HandleInfoKHR
    new (
      param?: VkMemoryGetWin32HandleInfoKHRInitializer | null
    ): VkMemoryGetWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryGetWin32HandleInfoKHR: VkMemoryGetWin32HandleInfoKHRConstructor

  /**
   * Properties of External Memory Windows Handles
   */
  interface VkMemoryWin32HandlePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is a bitmask containing one bit set for every memory type which the specified windows handle 'can' be imported as.
     */
    readonly memoryTypeBits: number
  }

  declare interface VkMemoryWin32HandlePropertiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is a bitmask containing one bit set for every memory type which the specified windows handle 'can' be imported as.
     */
    readonly memoryTypeBits?: number
  }

  declare interface VkMemoryWin32HandlePropertiesKHRConstructor {
    readonly prototype: VkMemoryWin32HandlePropertiesKHR
    new (
      param?: VkMemoryWin32HandlePropertiesKHRInitializer | null
    ): VkMemoryWin32HandlePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryWin32HandlePropertiesKHR: VkMemoryWin32HandlePropertiesKHRConstructor

  /**
   * Structure specifying additional attributes of Windows handles exported from a memory
   */
  interface VkExportMemoryWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number

    /**
     * is a UTF-16 string to associate with the underlying resource referenced by NT handles exported from the created memory.
     */
    name: string | null
  }

  declare interface VkExportMemoryWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number

    /**
     * is a UTF-16 string to associate with the underlying resource referenced by NT handles exported from the created memory.
     */
    name?: string | null
  }

  declare interface VkExportMemoryWin32HandleInfoKHRConstructor {
    readonly prototype: VkExportMemoryWin32HandleInfoKHR
    new (
      param?: VkExportMemoryWin32HandleInfoKHRInitializer | null
    ): VkExportMemoryWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportMemoryWin32HandleInfoKHR: VkExportMemoryWin32HandleInfoKHRConstructor

  /**
   * import Win32 memory created on the same physical device
   */
  interface VkImportMemoryWin32HandleInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle: bigint | number

    /**
     * is a UTF-16 string naming the underlying memory resource to import, or <i>null</i>.
     */
    name: string | null
  }

  declare interface VkImportMemoryWin32HandleInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle?: bigint | number

    /**
     * is a UTF-16 string naming the underlying memory resource to import, or <i>null</i>.
     */
    name?: string | null
  }

  declare interface VkImportMemoryWin32HandleInfoKHRConstructor {
    readonly prototype: VkImportMemoryWin32HandleInfoKHR
    new (
      param?: VkImportMemoryWin32HandleInfoKHRInitializer | null
    ): VkImportMemoryWin32HandleInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportMemoryWin32HandleInfoKHR: VkImportMemoryWin32HandleInfoKHRConstructor

  /**
   *
   */
  interface VkExportMemoryAllocateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExportMemoryAllocateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExportMemoryAllocateInfoKHRConstructor {
    readonly prototype: VkExportMemoryAllocateInfoKHR
    new (
      param?: VkExportMemoryAllocateInfoKHRInitializer | null
    ): VkExportMemoryAllocateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportMemoryAllocateInfoKHR: VkExportMemoryAllocateInfoKHRConstructor

  /**
   * Specify exportable handle types for a device memory object
   */
  interface VkExportMemoryAllocateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExportMemoryAllocateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExportMemoryAllocateInfoConstructor {
    readonly prototype: VkExportMemoryAllocateInfo
    new (
      param?: VkExportMemoryAllocateInfoInitializer | null
    ): VkExportMemoryAllocateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportMemoryAllocateInfo: VkExportMemoryAllocateInfoConstructor

  /**
   *
   */
  interface VkExternalMemoryBufferCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryBufferCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryBufferCreateInfoKHRConstructor {
    readonly prototype: VkExternalMemoryBufferCreateInfoKHR
    new (
      param?: VkExternalMemoryBufferCreateInfoKHRInitializer | null
    ): VkExternalMemoryBufferCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryBufferCreateInfoKHR: VkExternalMemoryBufferCreateInfoKHRConstructor

  /**
   * Specify that a buffer may be backed by external memory
   */
  interface VkExternalMemoryBufferCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryBufferCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryBufferCreateInfoConstructor {
    readonly prototype: VkExternalMemoryBufferCreateInfo
    new (
      param?: VkExternalMemoryBufferCreateInfoInitializer | null
    ): VkExternalMemoryBufferCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryBufferCreateInfo: VkExternalMemoryBufferCreateInfoConstructor

  /**
   *
   */
  interface VkExternalMemoryImageCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryImageCreateInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryImageCreateInfoKHRConstructor {
    readonly prototype: VkExternalMemoryImageCreateInfoKHR
    new (
      param?: VkExternalMemoryImageCreateInfoKHRInitializer | null
    ): VkExternalMemoryImageCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryImageCreateInfoKHR: VkExternalMemoryImageCreateInfoKHRConstructor

  /**
   * Specify that an image may be backed by external memory
   */
  interface VkExternalMemoryImageCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryImageCreateInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryImageCreateInfoConstructor {
    readonly prototype: VkExternalMemoryImageCreateInfo
    new (
      param?: VkExternalMemoryImageCreateInfoInitializer | null
    ): VkExternalMemoryImageCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryImageCreateInfo: VkExternalMemoryImageCreateInfoConstructor

  /**
   *
   */
  interface VkPhysicalDeviceIDPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly deviceUUID: number[] | null

    /**
     *
     */
    readonly driverUUID: number[] | null

    /**
     *
     */
    readonly deviceLUID: number[] | null

    /**
     *
     */
    readonly deviceNodeMask: number

    /**
     *
     */
    readonly deviceLUIDValid: boolean
  }

  declare interface VkPhysicalDeviceIDPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly deviceUUID?: number[] | null

    /**
     *
     */
    readonly driverUUID?: number[] | null

    /**
     *
     */
    readonly deviceLUID?: number[] | null

    /**
     *
     */
    readonly deviceNodeMask?: number

    /**
     *
     */
    readonly deviceLUIDValid?: boolean
  }

  declare interface VkPhysicalDeviceIDPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceIDPropertiesKHR
    new (
      param?: VkPhysicalDeviceIDPropertiesKHRInitializer | null
    ): VkPhysicalDeviceIDPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceIDPropertiesKHR: VkPhysicalDeviceIDPropertiesKHRConstructor

  /**
   * Structure specifying IDs related to the physical device
   */
  interface VkPhysicalDeviceIDProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly deviceUUID: number[] | null

    /**
     *
     */
    readonly driverUUID: number[] | null

    /**
     *
     */
    readonly deviceLUID: number[] | null

    /**
     *
     */
    readonly deviceNodeMask: number

    /**
     *
     */
    readonly deviceLUIDValid: boolean
  }

  declare interface VkPhysicalDeviceIDPropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly deviceUUID?: number[] | null

    /**
     *
     */
    readonly driverUUID?: number[] | null

    /**
     *
     */
    readonly deviceLUID?: number[] | null

    /**
     *
     */
    readonly deviceNodeMask?: number

    /**
     *
     */
    readonly deviceLUIDValid?: boolean
  }

  declare interface VkPhysicalDeviceIDPropertiesConstructor {
    readonly prototype: VkPhysicalDeviceIDProperties
    new (
      param?: VkPhysicalDeviceIDPropertiesInitializer | null
    ): VkPhysicalDeviceIDProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceIDProperties: VkPhysicalDeviceIDPropertiesConstructor

  /**
   *
   */
  interface VkExternalBufferPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    externalMemoryProperties: VkExternalMemoryProperties | null
  }

  declare interface VkExternalBufferPropertiesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    externalMemoryProperties?: VkExternalMemoryProperties | null
  }

  declare interface VkExternalBufferPropertiesKHRConstructor {
    readonly prototype: VkExternalBufferPropertiesKHR
    new (
      param?: VkExternalBufferPropertiesKHRInitializer | null
    ): VkExternalBufferPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalBufferPropertiesKHR: VkExternalBufferPropertiesKHRConstructor

  /**
   * Structure specifying supported external handle capabilities
   */
  interface VkExternalBufferProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    externalMemoryProperties: VkExternalMemoryProperties | null
  }

  declare interface VkExternalBufferPropertiesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    externalMemoryProperties?: VkExternalMemoryProperties | null
  }

  declare interface VkExternalBufferPropertiesConstructor {
    readonly prototype: VkExternalBufferProperties
    new (
      param?: VkExternalBufferPropertiesInitializer | null
    ): VkExternalBufferProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalBufferProperties: VkExternalBufferPropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceExternalBufferInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    flags: VkBufferCreateFlagBits

    /**
     *
     */
    usage: VkBufferUsageFlagBits

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalBufferInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    flags?: VkBufferCreateFlagBits

    /**
     *
     */
    usage?: VkBufferUsageFlagBits

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalBufferInfoKHRConstructor {
    readonly prototype: VkPhysicalDeviceExternalBufferInfoKHR
    new (
      param?: VkPhysicalDeviceExternalBufferInfoKHRInitializer | null
    ): VkPhysicalDeviceExternalBufferInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalBufferInfoKHR: VkPhysicalDeviceExternalBufferInfoKHRConstructor

  /**
   * Structure specifying buffer creation parameters
   */
  interface VkPhysicalDeviceExternalBufferInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    flags: VkBufferCreateFlagBits

    /**
     *
     */
    usage: VkBufferUsageFlagBits

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalBufferInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    flags?: VkBufferCreateFlagBits

    /**
     *
     */
    usage?: VkBufferUsageFlagBits

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalBufferInfoConstructor {
    readonly prototype: VkPhysicalDeviceExternalBufferInfo
    new (
      param?: VkPhysicalDeviceExternalBufferInfoInitializer | null
    ): VkPhysicalDeviceExternalBufferInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalBufferInfo: VkPhysicalDeviceExternalBufferInfoConstructor

  /**
   *
   */
  interface VkExternalImageFormatPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly externalMemoryProperties: VkExternalMemoryProperties | null
  }

  declare interface VkExternalImageFormatPropertiesKHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly externalMemoryProperties?: VkExternalMemoryProperties | null
  }

  declare interface VkExternalImageFormatPropertiesKHRConstructor {
    readonly prototype: VkExternalImageFormatPropertiesKHR
    new (
      param?: VkExternalImageFormatPropertiesKHRInitializer | null
    ): VkExternalImageFormatPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalImageFormatPropertiesKHR: VkExternalImageFormatPropertiesKHRConstructor

  /**
   * Structure specifying supported external handle properties
   */
  interface VkExternalImageFormatProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly externalMemoryProperties: VkExternalMemoryProperties | null
  }

  declare interface VkExternalImageFormatPropertiesInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly externalMemoryProperties?: VkExternalMemoryProperties | null
  }

  declare interface VkExternalImageFormatPropertiesConstructor {
    readonly prototype: VkExternalImageFormatProperties
    new (
      param?: VkExternalImageFormatPropertiesInitializer | null
    ): VkExternalImageFormatProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalImageFormatProperties: VkExternalImageFormatPropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceExternalImageFormatInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalImageFormatInfoKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalImageFormatInfoKHRConstructor {
    readonly prototype: VkPhysicalDeviceExternalImageFormatInfoKHR
    new (
      param?: VkPhysicalDeviceExternalImageFormatInfoKHRInitializer | null
    ): VkPhysicalDeviceExternalImageFormatInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalImageFormatInfoKHR: VkPhysicalDeviceExternalImageFormatInfoKHRConstructor

  /**
   * Structure specifying external image creation parameters
   */
  interface VkPhysicalDeviceExternalImageFormatInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalImageFormatInfoInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkPhysicalDeviceExternalImageFormatInfoConstructor {
    readonly prototype: VkPhysicalDeviceExternalImageFormatInfo
    new (
      param?: VkPhysicalDeviceExternalImageFormatInfoInitializer | null
    ): VkPhysicalDeviceExternalImageFormatInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceExternalImageFormatInfo: VkPhysicalDeviceExternalImageFormatInfoConstructor

  /**
   *
   */
  interface VkExternalMemoryPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    externalMemoryFeatures: VkExternalMemoryFeatureFlagBits

    /**
     *
     */
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBits

    /**
     *
     */
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryPropertiesKHRInitializer {
    /**
     *
     */
    externalMemoryFeatures?: VkExternalMemoryFeatureFlagBits

    /**
     *
     */
    exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagBits

    /**
     *
     */
    compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryPropertiesKHRConstructor {
    readonly prototype: VkExternalMemoryPropertiesKHR
    new (
      param?: VkExternalMemoryPropertiesKHRInitializer | null
    ): VkExternalMemoryPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryPropertiesKHR: VkExternalMemoryPropertiesKHRConstructor

  /**
   * Structure specifying external memory handle type capabilities
   */
  interface VkExternalMemoryProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    externalMemoryFeatures: VkExternalMemoryFeatureFlagBits

    /**
     *
     */
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBits

    /**
     *
     */
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryPropertiesInitializer {
    /**
     *
     */
    externalMemoryFeatures?: VkExternalMemoryFeatureFlagBits

    /**
     *
     */
    exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagBits

    /**
     *
     */
    compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagBits
  }

  declare interface VkExternalMemoryPropertiesConstructor {
    readonly prototype: VkExternalMemoryProperties
    new (
      param?: VkExternalMemoryPropertiesInitializer | null
    ): VkExternalMemoryProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryProperties: VkExternalMemoryPropertiesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceVariablePointerFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    variablePointersStorageBuffer: boolean

    /**
     *
     */
    variablePointers: boolean
  }

  declare interface VkPhysicalDeviceVariablePointerFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    variablePointersStorageBuffer?: boolean

    /**
     *
     */
    variablePointers?: boolean
  }

  declare interface VkPhysicalDeviceVariablePointerFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceVariablePointerFeatures
    new (
      param?: VkPhysicalDeviceVariablePointerFeaturesInitializer | null
    ): VkPhysicalDeviceVariablePointerFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVariablePointerFeatures: VkPhysicalDeviceVariablePointerFeaturesConstructor

  /**
   *
   */
  interface VkPhysicalDeviceVariablePointerFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    variablePointersStorageBuffer: boolean

    /**
     *
     */
    variablePointers: boolean
  }

  declare interface VkPhysicalDeviceVariablePointerFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    variablePointersStorageBuffer?: boolean

    /**
     *
     */
    variablePointers?: boolean
  }

  declare interface VkPhysicalDeviceVariablePointerFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceVariablePointerFeaturesKHR
    new (
      param?: VkPhysicalDeviceVariablePointerFeaturesKHRInitializer | null
    ): VkPhysicalDeviceVariablePointerFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVariablePointerFeaturesKHR: VkPhysicalDeviceVariablePointerFeaturesKHRConstructor

  /**
   *
   */
  interface VkPhysicalDeviceVariablePointersFeaturesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    variablePointersStorageBuffer: boolean

    /**
     *
     */
    variablePointers: boolean
  }

  declare interface VkPhysicalDeviceVariablePointersFeaturesKHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    variablePointersStorageBuffer?: boolean

    /**
     *
     */
    variablePointers?: boolean
  }

  declare interface VkPhysicalDeviceVariablePointersFeaturesKHRConstructor {
    readonly prototype: VkPhysicalDeviceVariablePointersFeaturesKHR
    new (
      param?: VkPhysicalDeviceVariablePointersFeaturesKHRInitializer | null
    ): VkPhysicalDeviceVariablePointersFeaturesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVariablePointersFeaturesKHR: VkPhysicalDeviceVariablePointersFeaturesKHRConstructor

  /**
   * Structure describing variable references features that can be supported by an implementation
   */
  interface VkPhysicalDeviceVariablePointersFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    variablePointersStorageBuffer: boolean

    /**
     *
     */
    variablePointers: boolean
  }

  declare interface VkPhysicalDeviceVariablePointersFeaturesInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    variablePointersStorageBuffer?: boolean

    /**
     *
     */
    variablePointers?: boolean
  }

  declare interface VkPhysicalDeviceVariablePointersFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceVariablePointersFeatures
    new (
      param?: VkPhysicalDeviceVariablePointersFeaturesInitializer | null
    ): VkPhysicalDeviceVariablePointersFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceVariablePointersFeatures: VkPhysicalDeviceVariablePointersFeaturesConstructor

  /**
   * Structure containing a rectangle, including layer, changed by vkQueuePresentKHR for a given VkImage
   */
  interface VkRectLayerKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the origin of the rectangle, in pixels.
     */
    offset: VkOffset2D | null

    /**
     * is the size of the rectangle, in pixels.
     */
    extent: VkExtent2D | null

    /**
     * is the layer of the image. For images with only one layer, the value of 'layer' 'must' be 0.
     */
    layer: number
  }

  declare interface VkRectLayerKHRInitializer {
    /**
     * is the origin of the rectangle, in pixels.
     */
    offset?: VkOffset2D | null

    /**
     * is the size of the rectangle, in pixels.
     */
    extent?: VkExtent2D | null

    /**
     * is the layer of the image. For images with only one layer, the value of 'layer' 'must' be 0.
     */
    layer?: number
  }

  declare interface VkRectLayerKHRConstructor {
    readonly prototype: VkRectLayerKHR
    new (param?: VkRectLayerKHRInitializer | null): VkRectLayerKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRectLayerKHR: VkRectLayerKHRConstructor

  /**
   * Structure containing rectangular region changed by vkQueuePresentKHR for a given VkImage
   */
  interface VkPresentRegionKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    rectangleCount: number

    /**
     * is either <i>null</i> or a reference to an array of 'VkRectLayerKHR' structures. The 'VkRectLayerKHR' structure is the framebuffer coordinates, plus layer, of a portion of a presentable image that has changed and 'must' be presented. If non-<i>null</i>, each entry in 'pRectangles' is a rectangle of the given image that has changed since the last image was presented to the given swapchain.
     */
    pRectangles: VkRectLayerKHR[] | null
  }

  declare interface VkPresentRegionKHRInitializer {
    /**
     *
     */
    rectangleCount?: number

    /**
     * is either <i>null</i> or a reference to an array of 'VkRectLayerKHR' structures. The 'VkRectLayerKHR' structure is the framebuffer coordinates, plus layer, of a portion of a presentable image that has changed and 'must' be presented. If non-<i>null</i>, each entry in 'pRectangles' is a rectangle of the given image that has changed since the last image was presented to the given swapchain.
     */
    pRectangles?: VkRectLayerKHR[] | null
  }

  declare interface VkPresentRegionKHRConstructor {
    readonly prototype: VkPresentRegionKHR
    new (param?: VkPresentRegionKHRInitializer | null): VkPresentRegionKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPresentRegionKHR: VkPresentRegionKHRConstructor

  /**
   * Structure hint of rectangular regions changed by vkQueuePresentKHR
   */
  interface VkPresentRegionsKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount: number

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentRegionKHR' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pRegions' contains the region that has changed since the last present to the swapchain in the corresponding entry in the 'VkPresentInfoKHR'::'pSwapchains' array.
     */
    pRegions: VkPresentRegionKHR[] | null
  }

  declare interface VkPresentRegionsKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount?: number

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentRegionKHR' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pRegions' contains the region that has changed since the last present to the swapchain in the corresponding entry in the 'VkPresentInfoKHR'::'pSwapchains' array.
     */
    pRegions?: VkPresentRegionKHR[] | null
  }

  declare interface VkPresentRegionsKHRConstructor {
    readonly prototype: VkPresentRegionsKHR
    new (param?: VkPresentRegionsKHRInitializer | null): VkPresentRegionsKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPresentRegionsKHR: VkPresentRegionsKHRConstructor

  /**
   * Structure containing driver identification information
   */
  interface VkPhysicalDeviceDriverPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension specific structure.
     */
    readonly pNext: null

    /**
     * is a unique identifier for the driver of the physical device.
     */
    readonly driverID: VkDriverIdKHR

    /**
     *
     */
    readonly driverName: string | null

    /**
     *
     */
    readonly driverInfo: string | null

    /**
     * is the version of the Vulkan conformance test this driver is conformant against (see 'VkConformanceVersionKHR').
     */
    readonly conformanceVersion: VkConformanceVersionKHR | null
  }

  declare interface VkPhysicalDeviceDriverPropertiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension specific structure.
     */
    readonly pNext?: null

    /**
     * is a unique identifier for the driver of the physical device.
     */
    readonly driverID?: VkDriverIdKHR

    /**
     *
     */
    readonly driverName?: string | null

    /**
     *
     */
    readonly driverInfo?: string | null

    /**
     * is the version of the Vulkan conformance test this driver is conformant against (see 'VkConformanceVersionKHR').
     */
    readonly conformanceVersion?: VkConformanceVersionKHR | null
  }

  declare interface VkPhysicalDeviceDriverPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDeviceDriverPropertiesKHR
    new (
      param?: VkPhysicalDeviceDriverPropertiesKHRInitializer | null
    ): VkPhysicalDeviceDriverPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceDriverPropertiesKHR: VkPhysicalDeviceDriverPropertiesKHRConstructor

  /**
   * Structure containing the conformance test suite version the implementation is compliant with
   */
  interface VkConformanceVersionKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the major version number of the conformance test suite.
     */
    major: number

    /**
     * is the minor version number of the conformance test suite.
     */
    minor: number

    /**
     * is the subminor version number of the conformance test suite.
     */
    subminor: number

    /**
     * is the patch version number of the conformance test suite.
     */
    patch: number
  }

  declare interface VkConformanceVersionKHRInitializer {
    /**
     * is the major version number of the conformance test suite.
     */
    major?: number

    /**
     * is the minor version number of the conformance test suite.
     */
    minor?: number

    /**
     * is the subminor version number of the conformance test suite.
     */
    subminor?: number

    /**
     * is the patch version number of the conformance test suite.
     */
    patch?: number
  }

  declare interface VkConformanceVersionKHRConstructor {
    readonly prototype: VkConformanceVersionKHR
    new (
      param?: VkConformanceVersionKHRInitializer | null
    ): VkConformanceVersionKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkConformanceVersionKHR: VkConformanceVersionKHRConstructor

  /**
   * Structure describing push descriptor limits that can be supported by an implementation
   */
  interface VkPhysicalDevicePushDescriptorPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext: null

    /**
     * is the maximum number of descriptors that 'can' be used in a descriptor set created with 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR' set.
     */
    readonly maxPushDescriptors: number
  }

  declare interface VkPhysicalDevicePushDescriptorPropertiesKHRInitializer {
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    readonly pNext?: null

    /**
     * is the maximum number of descriptors that 'can' be used in a descriptor set created with 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR' set.
     */
    readonly maxPushDescriptors?: number
  }

  declare interface VkPhysicalDevicePushDescriptorPropertiesKHRConstructor {
    readonly prototype: VkPhysicalDevicePushDescriptorPropertiesKHR
    new (
      param?: VkPhysicalDevicePushDescriptorPropertiesKHRInitializer | null
    ): VkPhysicalDevicePushDescriptorPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDevicePushDescriptorPropertiesKHR: VkPhysicalDevicePushDescriptorPropertiesKHRConstructor

  /**
   *
   */
  interface VkPhysicalDeviceSparseImageFormatInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    format: VkFormat

    /**
     *
     */
    type: VkImageType

    /**
     *
     */
    samples: VkSampleCountFlagBits

    /**
     *
     */
    usage: VkImageUsageFlagBits

    /**
     *
     */
    tiling: VkImageTiling
  }

  declare interface VkPhysicalDeviceSparseImageFormatInfo2KHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    format?: VkFormat

    /**
     *
     */
    type?: VkImageType

    /**
     *
     */
    samples?: VkSampleCountFlagBits

    /**
     *
     */
    usage?: VkImageUsageFlagBits

    /**
     *
     */
    tiling?: VkImageTiling
  }

  declare interface VkPhysicalDeviceSparseImageFormatInfo2KHRConstructor {
    readonly prototype: VkPhysicalDeviceSparseImageFormatInfo2KHR
    new (
      param?: VkPhysicalDeviceSparseImageFormatInfo2KHRInitializer | null
    ): VkPhysicalDeviceSparseImageFormatInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSparseImageFormatInfo2KHR: VkPhysicalDeviceSparseImageFormatInfo2KHRConstructor

  /**
   * Structure specifying sparse image format inputs
   */
  interface VkPhysicalDeviceSparseImageFormatInfo2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    format: VkFormat

    /**
     *
     */
    type: VkImageType

    /**
     *
     */
    samples: VkSampleCountFlagBits

    /**
     *
     */
    usage: VkImageUsageFlagBits

    /**
     *
     */
    tiling: VkImageTiling
  }

  declare interface VkPhysicalDeviceSparseImageFormatInfo2Initializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    format?: VkFormat

    /**
     *
     */
    type?: VkImageType

    /**
     *
     */
    samples?: VkSampleCountFlagBits

    /**
     *
     */
    usage?: VkImageUsageFlagBits

    /**
     *
     */
    tiling?: VkImageTiling
  }

  declare interface VkPhysicalDeviceSparseImageFormatInfo2Constructor {
    readonly prototype: VkPhysicalDeviceSparseImageFormatInfo2
    new (
      param?: VkPhysicalDeviceSparseImageFormatInfo2Initializer | null
    ): VkPhysicalDeviceSparseImageFormatInfo2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSparseImageFormatInfo2: VkPhysicalDeviceSparseImageFormatInfo2Constructor

  /**
   *
   */
  interface VkSparseImageFormatProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly properties: VkSparseImageFormatProperties | null
  }

  declare interface VkSparseImageFormatProperties2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly properties?: VkSparseImageFormatProperties | null
  }

  declare interface VkSparseImageFormatProperties2KHRConstructor {
    readonly prototype: VkSparseImageFormatProperties2KHR
    new (
      param?: VkSparseImageFormatProperties2KHRInitializer | null
    ): VkSparseImageFormatProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageFormatProperties2KHR: VkSparseImageFormatProperties2KHRConstructor

  /**
   * Structure specifying sparse image format properties
   */
  interface VkSparseImageFormatProperties2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly properties: VkSparseImageFormatProperties | null
  }

  declare interface VkSparseImageFormatProperties2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly properties?: VkSparseImageFormatProperties | null
  }

  declare interface VkSparseImageFormatProperties2Constructor {
    readonly prototype: VkSparseImageFormatProperties2
    new (
      param?: VkSparseImageFormatProperties2Initializer | null
    ): VkSparseImageFormatProperties2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageFormatProperties2: VkSparseImageFormatProperties2Constructor

  /**
   *
   */
  interface VkPhysicalDeviceMemoryProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly memoryProperties: VkPhysicalDeviceMemoryProperties | null
  }

  declare interface VkPhysicalDeviceMemoryProperties2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly memoryProperties?: VkPhysicalDeviceMemoryProperties | null
  }

  declare interface VkPhysicalDeviceMemoryProperties2KHRConstructor {
    readonly prototype: VkPhysicalDeviceMemoryProperties2KHR
    new (
      param?: VkPhysicalDeviceMemoryProperties2KHRInitializer | null
    ): VkPhysicalDeviceMemoryProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMemoryProperties2KHR: VkPhysicalDeviceMemoryProperties2KHRConstructor

  /**
   * Structure specifying physical device memory properties
   */
  interface VkPhysicalDeviceMemoryProperties2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly memoryProperties: VkPhysicalDeviceMemoryProperties | null
  }

  declare interface VkPhysicalDeviceMemoryProperties2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly memoryProperties?: VkPhysicalDeviceMemoryProperties | null
  }

  declare interface VkPhysicalDeviceMemoryProperties2Constructor {
    readonly prototype: VkPhysicalDeviceMemoryProperties2
    new (
      param?: VkPhysicalDeviceMemoryProperties2Initializer | null
    ): VkPhysicalDeviceMemoryProperties2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMemoryProperties2: VkPhysicalDeviceMemoryProperties2Constructor

  /**
   *
   */
  interface VkQueueFamilyProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly queueFamilyProperties: VkQueueFamilyProperties | null
  }

  declare interface VkQueueFamilyProperties2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly queueFamilyProperties?: VkQueueFamilyProperties | null
  }

  declare interface VkQueueFamilyProperties2KHRConstructor {
    readonly prototype: VkQueueFamilyProperties2KHR
    new (
      param?: VkQueueFamilyProperties2KHRInitializer | null
    ): VkQueueFamilyProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkQueueFamilyProperties2KHR: VkQueueFamilyProperties2KHRConstructor

  /**
   * Structure providing information about a queue family
   */
  interface VkQueueFamilyProperties2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly queueFamilyProperties: VkQueueFamilyProperties | null
  }

  declare interface VkQueueFamilyProperties2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly queueFamilyProperties?: VkQueueFamilyProperties | null
  }

  declare interface VkQueueFamilyProperties2Constructor {
    readonly prototype: VkQueueFamilyProperties2
    new (
      param?: VkQueueFamilyProperties2Initializer | null
    ): VkQueueFamilyProperties2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkQueueFamilyProperties2: VkQueueFamilyProperties2Constructor

  /**
   *
   */
  interface VkPhysicalDeviceImageFormatInfo2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    format: VkFormat

    /**
     *
     */
    type: VkImageType

    /**
     *
     */
    tiling: VkImageTiling

    /**
     *
     */
    usage: VkImageUsageFlagBits

    /**
     *
     */
    flags: VkImageCreateFlagBits
  }

  declare interface VkPhysicalDeviceImageFormatInfo2KHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    format?: VkFormat

    /**
     *
     */
    type?: VkImageType

    /**
     *
     */
    tiling?: VkImageTiling

    /**
     *
     */
    usage?: VkImageUsageFlagBits

    /**
     *
     */
    flags?: VkImageCreateFlagBits
  }

  declare interface VkPhysicalDeviceImageFormatInfo2KHRConstructor {
    readonly prototype: VkPhysicalDeviceImageFormatInfo2KHR
    new (
      param?: VkPhysicalDeviceImageFormatInfo2KHRInitializer | null
    ): VkPhysicalDeviceImageFormatInfo2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceImageFormatInfo2KHR: VkPhysicalDeviceImageFormatInfo2KHRConstructor

  /**
   * Structure specifying image creation parameters
   */
  interface VkPhysicalDeviceImageFormatInfo2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    format: VkFormat

    /**
     *
     */
    type: VkImageType

    /**
     *
     */
    tiling: VkImageTiling

    /**
     *
     */
    usage: VkImageUsageFlagBits

    /**
     *
     */
    flags: VkImageCreateFlagBits
  }

  declare interface VkPhysicalDeviceImageFormatInfo2Initializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    format?: VkFormat

    /**
     *
     */
    type?: VkImageType

    /**
     *
     */
    tiling?: VkImageTiling

    /**
     *
     */
    usage?: VkImageUsageFlagBits

    /**
     *
     */
    flags?: VkImageCreateFlagBits
  }

  declare interface VkPhysicalDeviceImageFormatInfo2Constructor {
    readonly prototype: VkPhysicalDeviceImageFormatInfo2
    new (
      param?: VkPhysicalDeviceImageFormatInfo2Initializer | null
    ): VkPhysicalDeviceImageFormatInfo2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceImageFormatInfo2: VkPhysicalDeviceImageFormatInfo2Constructor

  /**
   *
   */
  interface VkImageFormatProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly imageFormatProperties: VkImageFormatProperties | null
  }

  declare interface VkImageFormatProperties2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly imageFormatProperties?: VkImageFormatProperties | null
  }

  declare interface VkImageFormatProperties2KHRConstructor {
    readonly prototype: VkImageFormatProperties2KHR
    new (
      param?: VkImageFormatProperties2KHRInitializer | null
    ): VkImageFormatProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageFormatProperties2KHR: VkImageFormatProperties2KHRConstructor

  /**
   * Structure specifying an image format properties
   */
  interface VkImageFormatProperties2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly imageFormatProperties: VkImageFormatProperties | null
  }

  declare interface VkImageFormatProperties2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly imageFormatProperties?: VkImageFormatProperties | null
  }

  declare interface VkImageFormatProperties2Constructor {
    readonly prototype: VkImageFormatProperties2
    new (
      param?: VkImageFormatProperties2Initializer | null
    ): VkImageFormatProperties2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageFormatProperties2: VkImageFormatProperties2Constructor

  /**
   *
   */
  interface VkFormatProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly formatProperties: VkFormatProperties | null
  }

  declare interface VkFormatProperties2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly formatProperties?: VkFormatProperties | null
  }

  declare interface VkFormatProperties2KHRConstructor {
    readonly prototype: VkFormatProperties2KHR
    new (
      param?: VkFormatProperties2KHRInitializer | null
    ): VkFormatProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFormatProperties2KHR: VkFormatProperties2KHRConstructor

  /**
   * Structure specifying image format properties
   */
  interface VkFormatProperties2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly formatProperties: VkFormatProperties | null
  }

  declare interface VkFormatProperties2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly formatProperties?: VkFormatProperties | null
  }

  declare interface VkFormatProperties2Constructor {
    readonly prototype: VkFormatProperties2
    new (param?: VkFormatProperties2Initializer | null): VkFormatProperties2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFormatProperties2: VkFormatProperties2Constructor

  /**
   *
   */
  interface VkPhysicalDeviceProperties2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly properties: VkPhysicalDeviceProperties | null
  }

  declare interface VkPhysicalDeviceProperties2KHRInitializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly properties?: VkPhysicalDeviceProperties | null
  }

  declare interface VkPhysicalDeviceProperties2KHRConstructor {
    readonly prototype: VkPhysicalDeviceProperties2KHR
    new (
      param?: VkPhysicalDeviceProperties2KHRInitializer | null
    ): VkPhysicalDeviceProperties2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceProperties2KHR: VkPhysicalDeviceProperties2KHRConstructor

  /**
   * Structure specifying physical device properties
   */
  interface VkPhysicalDeviceProperties2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly sType: VkStructureType

    /**
     *
     */
    readonly pNext: null

    /**
     *
     */
    readonly properties: VkPhysicalDeviceProperties | null
  }

  declare interface VkPhysicalDeviceProperties2Initializer {
    /**
     *
     */
    readonly sType?: VkStructureType

    /**
     *
     */
    readonly pNext?: null

    /**
     *
     */
    readonly properties?: VkPhysicalDeviceProperties | null
  }

  declare interface VkPhysicalDeviceProperties2Constructor {
    readonly prototype: VkPhysicalDeviceProperties2
    new (
      param?: VkPhysicalDeviceProperties2Initializer | null
    ): VkPhysicalDeviceProperties2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceProperties2: VkPhysicalDeviceProperties2Constructor

  /**
   *
   */
  interface VkPhysicalDeviceFeatures2KHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    features: VkPhysicalDeviceFeatures | null
  }

  declare interface VkPhysicalDeviceFeatures2KHRInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    features?: VkPhysicalDeviceFeatures | null
  }

  declare interface VkPhysicalDeviceFeatures2KHRConstructor {
    readonly prototype: VkPhysicalDeviceFeatures2KHR
    new (
      param?: VkPhysicalDeviceFeatures2KHRInitializer | null
    ): VkPhysicalDeviceFeatures2KHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFeatures2KHR: VkPhysicalDeviceFeatures2KHRConstructor

  /**
   * Structure describing the fine-grained features that can be supported by an implementation
   */
  interface VkPhysicalDeviceFeatures2 {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    features: VkPhysicalDeviceFeatures | null
  }

  declare interface VkPhysicalDeviceFeatures2Initializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    features?: VkPhysicalDeviceFeatures | null
  }

  declare interface VkPhysicalDeviceFeatures2Constructor {
    readonly prototype: VkPhysicalDeviceFeatures2
    new (
      param?: VkPhysicalDeviceFeatures2Initializer | null
    ): VkPhysicalDeviceFeatures2

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFeatures2: VkPhysicalDeviceFeatures2Constructor

  /**
   * Parameters of an object table push constant entry
   */
  interface VkObjectTablePushConstantEntryNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    type: VkObjectEntryTypeNVX

    /**
     *
     */
    flags: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkPipelineLayout' that the pushconstants are used with
     */
    pipelineLayout: VkPipelineLayout | null

    /**
     * specifies the 'VkShaderStageFlags' that the pushconstants are used with
     */
    stageFlags: VkShaderStageFlagBits
  }

  declare interface VkObjectTablePushConstantEntryNVXInitializer {
    /**
     *
     */
    type?: VkObjectEntryTypeNVX

    /**
     *
     */
    flags?: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkPipelineLayout' that the pushconstants are used with
     */
    pipelineLayout?: VkPipelineLayout | null

    /**
     * specifies the 'VkShaderStageFlags' that the pushconstants are used with
     */
    stageFlags?: VkShaderStageFlagBits
  }

  declare interface VkObjectTablePushConstantEntryNVXConstructor {
    readonly prototype: VkObjectTablePushConstantEntryNVX
    new (
      param?: VkObjectTablePushConstantEntryNVXInitializer | null
    ): VkObjectTablePushConstantEntryNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTablePushConstantEntryNVX: VkObjectTablePushConstantEntryNVXConstructor

  /**
   * Parameters of an object table index buffer entry
   */
  interface VkObjectTableIndexBufferEntryNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    type: VkObjectEntryTypeNVX

    /**
     *
     */
    flags: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkBuffer' that can be bound as index buffer
     */
    buffer: VkBuffer | null

    /**
     * specifies the 'VkIndexType' used with this index buffer
     */
    indexType: VkIndexType
  }

  declare interface VkObjectTableIndexBufferEntryNVXInitializer {
    /**
     *
     */
    type?: VkObjectEntryTypeNVX

    /**
     *
     */
    flags?: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkBuffer' that can be bound as index buffer
     */
    buffer?: VkBuffer | null

    /**
     * specifies the 'VkIndexType' used with this index buffer
     */
    indexType?: VkIndexType
  }

  declare interface VkObjectTableIndexBufferEntryNVXConstructor {
    readonly prototype: VkObjectTableIndexBufferEntryNVX
    new (
      param?: VkObjectTableIndexBufferEntryNVXInitializer | null
    ): VkObjectTableIndexBufferEntryNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTableIndexBufferEntryNVX: VkObjectTableIndexBufferEntryNVXConstructor

  /**
   * Parameters of an object table vertex buffer entry
   */
  interface VkObjectTableVertexBufferEntryNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    type: VkObjectEntryTypeNVX

    /**
     *
     */
    flags: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkBuffer' that can be bound as vertex bufer
     */
    buffer: VkBuffer | null
  }

  declare interface VkObjectTableVertexBufferEntryNVXInitializer {
    /**
     *
     */
    type?: VkObjectEntryTypeNVX

    /**
     *
     */
    flags?: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkBuffer' that can be bound as vertex bufer
     */
    buffer?: VkBuffer | null
  }

  declare interface VkObjectTableVertexBufferEntryNVXConstructor {
    readonly prototype: VkObjectTableVertexBufferEntryNVX
    new (
      param?: VkObjectTableVertexBufferEntryNVXInitializer | null
    ): VkObjectTableVertexBufferEntryNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTableVertexBufferEntryNVX: VkObjectTableVertexBufferEntryNVXConstructor

  /**
   * Parameters of an object table descriptor set entry
   */
  interface VkObjectTableDescriptorSetEntryNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    type: VkObjectEntryTypeNVX

    /**
     *
     */
    flags: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkPipelineLayout' that the 'descriptorSet' is used with.
     */
    pipelineLayout: VkPipelineLayout | null

    /**
     * specifies the 'VkDescriptorSet' that can be bound with this entry.
     */
    descriptorSet: VkDescriptorSet | null
  }

  declare interface VkObjectTableDescriptorSetEntryNVXInitializer {
    /**
     *
     */
    type?: VkObjectEntryTypeNVX

    /**
     *
     */
    flags?: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkPipelineLayout' that the 'descriptorSet' is used with.
     */
    pipelineLayout?: VkPipelineLayout | null

    /**
     * specifies the 'VkDescriptorSet' that can be bound with this entry.
     */
    descriptorSet?: VkDescriptorSet | null
  }

  declare interface VkObjectTableDescriptorSetEntryNVXConstructor {
    readonly prototype: VkObjectTableDescriptorSetEntryNVX
    new (
      param?: VkObjectTableDescriptorSetEntryNVXInitializer | null
    ): VkObjectTableDescriptorSetEntryNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTableDescriptorSetEntryNVX: VkObjectTableDescriptorSetEntryNVXConstructor

  /**
   * Parameters of an object table pipeline entry
   */
  interface VkObjectTablePipelineEntryNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    type: VkObjectEntryTypeNVX

    /**
     *
     */
    flags: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkPipeline' that this resource entry references.
     */
    pipeline: VkPipeline | null
  }

  declare interface VkObjectTablePipelineEntryNVXInitializer {
    /**
     *
     */
    type?: VkObjectEntryTypeNVX

    /**
     *
     */
    flags?: VkObjectEntryUsageFlagBitsNVX

    /**
     * specifies the 'VkPipeline' that this resource entry references.
     */
    pipeline?: VkPipeline | null
  }

  declare interface VkObjectTablePipelineEntryNVXConstructor {
    readonly prototype: VkObjectTablePipelineEntryNVX
    new (
      param?: VkObjectTablePipelineEntryNVXInitializer | null
    ): VkObjectTablePipelineEntryNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTablePipelineEntryNVX: VkObjectTablePipelineEntryNVXConstructor

  /**
   * Common parameters of an object table resource entry
   */
  interface VkObjectTableEntryNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * defines the entry type
     */
    type: VkObjectEntryTypeNVX

    /**
     * defines which 'VkPipelineBindPoint' the resource can be used with. Some entry types allow only a single flag to be set.
     */
    flags: VkObjectEntryUsageFlagBitsNVX
  }

  declare interface VkObjectTableEntryNVXInitializer {
    /**
     * defines the entry type
     */
    type?: VkObjectEntryTypeNVX

    /**
     * defines which 'VkPipelineBindPoint' the resource can be used with. Some entry types allow only a single flag to be set.
     */
    flags?: VkObjectEntryUsageFlagBitsNVX
  }

  declare interface VkObjectTableEntryNVXConstructor {
    readonly prototype: VkObjectTableEntryNVX
    new (param?: VkObjectTableEntryNVXInitializer | null): VkObjectTableEntryNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTableEntryNVX: VkObjectTableEntryNVXConstructor

  /**
   * Structure specifying the parameters of a newly created object table
   */
  interface VkObjectTableCreateInfoNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of entry configurations that the object table supports.
     */
    objectCount: number

    /**
     * is an array of 'VkObjectEntryTypeNVX' values providing the entry type of a given configuration.
     */
    pObjectEntryTypes: Int32Array | null

    /**
     * is an array of counts of how many objects can be registered in the table.
     */
    pObjectEntryCounts: Uint32Array | null

    /**
     * is an array of bitmasks of 'VkObjectEntryUsageFlagBitsNVX' specifying the binding usage of the entry.
     */
    pObjectEntryUsageFlags: Int32Array | null

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER' or 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxUniformBuffersPerDescriptor: number

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER' or 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxStorageBuffersPerDescriptor: number

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE' or 'VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxStorageImagesPerDescriptor: number

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_SAMPLER', 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', 'VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER' or 'VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxSampledImagesPerDescriptor: number

    /**
     * is the maximum number of unique 'VkPipelineLayout' used by any registered 'VkDescriptorSet' or 'VkPipeline' in this table.
     */
    maxPipelineLayouts: number
  }

  declare interface VkObjectTableCreateInfoNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of entry configurations that the object table supports.
     */
    objectCount?: number

    /**
     * is an array of 'VkObjectEntryTypeNVX' values providing the entry type of a given configuration.
     */
    pObjectEntryTypes?: Int32Array | null

    /**
     * is an array of counts of how many objects can be registered in the table.
     */
    pObjectEntryCounts?: Uint32Array | null

    /**
     * is an array of bitmasks of 'VkObjectEntryUsageFlagBitsNVX' specifying the binding usage of the entry.
     */
    pObjectEntryUsageFlags?: Int32Array | null

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER' or 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxUniformBuffersPerDescriptor?: number

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER' or 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxStorageBuffersPerDescriptor?: number

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE' or 'VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxStorageImagesPerDescriptor?: number

    /**
     * is the maximum number of 'VK_DESCRIPTOR_TYPE_SAMPLER', 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', 'VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER' or 'VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT' used by any single registered 'VkDescriptorSet' in this table.
     */
    maxSampledImagesPerDescriptor?: number

    /**
     * is the maximum number of unique 'VkPipelineLayout' used by any registered 'VkDescriptorSet' or 'VkPipeline' in this table.
     */
    maxPipelineLayouts?: number
  }

  declare interface VkObjectTableCreateInfoNVXConstructor {
    readonly prototype: VkObjectTableCreateInfoNVX
    new (
      param?: VkObjectTableCreateInfoNVXInitializer | null
    ): VkObjectTableCreateInfoNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkObjectTableCreateInfoNVX: VkObjectTableCreateInfoNVXConstructor

  /**
   * Structure specifying parameters for the reservation of command buffer space
   */
  interface VkCmdReserveSpaceForCommandsInfoNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the 'VkObjectTableNVX' to be used for the generation process. Only registered objects at the time 'vkCmdReserveSpaceForCommandsNVX' is called, will be taken into account for the reservation.
     */
    objectTable: VkObjectTableNVX | null

    /**
     * is the 'VkIndirectCommandsLayoutNVX' that 'must' also be used at generation time.
     */
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX | null

    /**
     * is the maximum number of sequences for which command buffer space will be reserved.
     */
    maxSequencesCount: number
  }

  declare interface VkCmdReserveSpaceForCommandsInfoNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the 'VkObjectTableNVX' to be used for the generation process. Only registered objects at the time 'vkCmdReserveSpaceForCommandsNVX' is called, will be taken into account for the reservation.
     */
    objectTable?: VkObjectTableNVX | null

    /**
     * is the 'VkIndirectCommandsLayoutNVX' that 'must' also be used at generation time.
     */
    indirectCommandsLayout?: VkIndirectCommandsLayoutNVX | null

    /**
     * is the maximum number of sequences for which command buffer space will be reserved.
     */
    maxSequencesCount?: number
  }

  declare interface VkCmdReserveSpaceForCommandsInfoNVXConstructor {
    readonly prototype: VkCmdReserveSpaceForCommandsInfoNVX
    new (
      param?: VkCmdReserveSpaceForCommandsInfoNVXInitializer | null
    ): VkCmdReserveSpaceForCommandsInfoNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCmdReserveSpaceForCommandsInfoNVX: VkCmdReserveSpaceForCommandsInfoNVXConstructor

  /**
   * Structure specifying parameters for the generation of commands
   */
  interface VkCmdProcessCommandsInfoNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the 'VkObjectTableNVX' to be used for the generation process. Only registered objects at the time 'vkCmdReserveSpaceForCommandsNVX' is called, will be taken into account for the reservation.
     */
    objectTable: VkObjectTableNVX | null

    /**
     * is the 'VkIndirectCommandsLayoutNVX' that provides the command sequence to generate.
     */
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX | null

    /**
     * defines the number of input tokens used.
     */
    indirectCommandsTokenCount: number

    /**
     * provides an array of 'VkIndirectCommandsTokenNVX' that reference the input data for each token command.
     */
    pIndirectCommandsTokens: VkIndirectCommandsTokenNVX[] | null

    /**
     * is the maximum number of sequences for which command buffer space will be reserved. If 'sequencesCountBuffer' is 'VK_NULL_HANDLE', this is also the actual number of sequences generated.
     */
    maxSequencesCount: number

    /**
     * 'can' be the secondary 'VkCommandBuffer' in which the commands should be recorded. If 'targetCommandBuffer' is <i>null</i> an implicit reservation as well as execution takes place on the processing 'VkCommandBuffer'.
     */
    targetCommandBuffer: VkCommandBuffer | null

    /**
     * 'can' be 'VkBuffer' from which the actual amount of sequences is sourced from as 'uint32_t' value.
     */
    sequencesCountBuffer: VkBuffer | null

    /**
     * is the byte offset into 'sequencesCountBuffer' where the count value is stored.
     */
    sequencesCountOffset: bigint | number

    /**
     * 'must' be set if 'indirectCommandsLayout''s 'VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX' is set and provides the used sequence indices as 'uint32_t' array. Otherwise it 'must' be 'VK_NULL_HANDLE'.
     */
    sequencesIndexBuffer: VkBuffer | null

    /**
     * is the byte offset into 'sequencesIndexBuffer' where the index values start.
     */
    sequencesIndexOffset: bigint | number
  }

  declare interface VkCmdProcessCommandsInfoNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the 'VkObjectTableNVX' to be used for the generation process. Only registered objects at the time 'vkCmdReserveSpaceForCommandsNVX' is called, will be taken into account for the reservation.
     */
    objectTable?: VkObjectTableNVX | null

    /**
     * is the 'VkIndirectCommandsLayoutNVX' that provides the command sequence to generate.
     */
    indirectCommandsLayout?: VkIndirectCommandsLayoutNVX | null

    /**
     * defines the number of input tokens used.
     */
    indirectCommandsTokenCount?: number

    /**
     * provides an array of 'VkIndirectCommandsTokenNVX' that reference the input data for each token command.
     */
    pIndirectCommandsTokens?: VkIndirectCommandsTokenNVX[] | null

    /**
     * is the maximum number of sequences for which command buffer space will be reserved. If 'sequencesCountBuffer' is 'VK_NULL_HANDLE', this is also the actual number of sequences generated.
     */
    maxSequencesCount?: number

    /**
     * 'can' be the secondary 'VkCommandBuffer' in which the commands should be recorded. If 'targetCommandBuffer' is <i>null</i> an implicit reservation as well as execution takes place on the processing 'VkCommandBuffer'.
     */
    targetCommandBuffer?: VkCommandBuffer | null

    /**
     * 'can' be 'VkBuffer' from which the actual amount of sequences is sourced from as 'uint32_t' value.
     */
    sequencesCountBuffer?: VkBuffer | null

    /**
     * is the byte offset into 'sequencesCountBuffer' where the count value is stored.
     */
    sequencesCountOffset?: bigint | number

    /**
     * 'must' be set if 'indirectCommandsLayout''s 'VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX' is set and provides the used sequence indices as 'uint32_t' array. Otherwise it 'must' be 'VK_NULL_HANDLE'.
     */
    sequencesIndexBuffer?: VkBuffer | null

    /**
     * is the byte offset into 'sequencesIndexBuffer' where the index values start.
     */
    sequencesIndexOffset?: bigint | number
  }

  declare interface VkCmdProcessCommandsInfoNVXConstructor {
    readonly prototype: VkCmdProcessCommandsInfoNVX
    new (
      param?: VkCmdProcessCommandsInfoNVXInitializer | null
    ): VkCmdProcessCommandsInfoNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCmdProcessCommandsInfoNVX: VkCmdProcessCommandsInfoNVXConstructor

  /**
   * Structure specifying the parameters of a newly created indirect commands layout object
   */
  interface VkIndirectCommandsLayoutCreateInfoNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the 'VkPipelineBindPoint' that this layout targets.
     */
    pipelineBindPoint: VkPipelineBindPoint

    /**
     * is a bitmask of 'VkIndirectCommandsLayoutUsageFlagBitsNVX' specifying usage hints of this layout.
     */
    flags: VkIndirectCommandsLayoutUsageFlagBitsNVX

    /**
     * is the length of the individual command sequnce.
     */
    tokenCount: number

    /**
     * is an array describing each command token in detail. See 'VkIndirectCommandsTokenTypeNVX' and 'VkIndirectCommandsLayoutTokenNVX' below for details.
     */
    pTokens: VkIndirectCommandsLayoutTokenNVX[] | null
  }

  declare interface VkIndirectCommandsLayoutCreateInfoNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the 'VkPipelineBindPoint' that this layout targets.
     */
    pipelineBindPoint?: VkPipelineBindPoint

    /**
     * is a bitmask of 'VkIndirectCommandsLayoutUsageFlagBitsNVX' specifying usage hints of this layout.
     */
    flags?: VkIndirectCommandsLayoutUsageFlagBitsNVX

    /**
     * is the length of the individual command sequnce.
     */
    tokenCount?: number

    /**
     * is an array describing each command token in detail. See 'VkIndirectCommandsTokenTypeNVX' and 'VkIndirectCommandsLayoutTokenNVX' below for details.
     */
    pTokens?: VkIndirectCommandsLayoutTokenNVX[] | null
  }

  declare interface VkIndirectCommandsLayoutCreateInfoNVXConstructor {
    readonly prototype: VkIndirectCommandsLayoutCreateInfoNVX
    new (
      param?: VkIndirectCommandsLayoutCreateInfoNVXInitializer | null
    ): VkIndirectCommandsLayoutCreateInfoNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkIndirectCommandsLayoutCreateInfoNVX: VkIndirectCommandsLayoutCreateInfoNVXConstructor

  /**
   * Struct specifying the details of an indirect command layout token
   */
  interface VkIndirectCommandsLayoutTokenNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    tokenType: VkIndirectCommandsTokenTypeNVX

    /**
     * has a different meaning depending on the type, please refer pseudo code further down for details.
     */
    bindingUnit: number

    /**
     * has a different meaning depending on the type, please refer pseudo code further down for details.
     */
    dynamicCount: number

    /**
     * defines the rate at which the input data buffers are accessed.
     */
    divisor: number
  }

  declare interface VkIndirectCommandsLayoutTokenNVXInitializer {
    /**
     *
     */
    tokenType?: VkIndirectCommandsTokenTypeNVX

    /**
     * has a different meaning depending on the type, please refer pseudo code further down for details.
     */
    bindingUnit?: number

    /**
     * has a different meaning depending on the type, please refer pseudo code further down for details.
     */
    dynamicCount?: number

    /**
     * defines the rate at which the input data buffers are accessed.
     */
    divisor?: number
  }

  declare interface VkIndirectCommandsLayoutTokenNVXConstructor {
    readonly prototype: VkIndirectCommandsLayoutTokenNVX
    new (
      param?: VkIndirectCommandsLayoutTokenNVXInitializer | null
    ): VkIndirectCommandsLayoutTokenNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkIndirectCommandsLayoutTokenNVX: VkIndirectCommandsLayoutTokenNVXConstructor

  /**
   * Structure specifying parameters for the reservation of command buffer space
   */
  interface VkIndirectCommandsTokenNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * specifies the token command type.
     */
    tokenType: VkIndirectCommandsTokenTypeNVX

    /**
     * where the arguments start.
     */
    buffer: VkBuffer | null

    /**
     *
     */
    offset: bigint | number
  }

  declare interface VkIndirectCommandsTokenNVXInitializer {
    /**
     * specifies the token command type.
     */
    tokenType?: VkIndirectCommandsTokenTypeNVX

    /**
     * where the arguments start.
     */
    buffer?: VkBuffer | null

    /**
     *
     */
    offset?: bigint | number
  }

  declare interface VkIndirectCommandsTokenNVXConstructor {
    readonly prototype: VkIndirectCommandsTokenNVX
    new (
      param?: VkIndirectCommandsTokenNVXInitializer | null
    ): VkIndirectCommandsTokenNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkIndirectCommandsTokenNVX: VkIndirectCommandsTokenNVXConstructor

  /**
   * Structure specifying physical device limits
   */
  interface VkDeviceGeneratedCommandsLimitsNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * the maximum number of tokens in 'VkIndirectCommandsLayoutNVX'.
     */
    maxIndirectCommandsLayoutTokenCount: number

    /**
     * the maximum number of entries per resource type in 'VkObjectTableNVX'.
     */
    maxObjectEntryCounts: number

    /**
     * the minimum alignment for memory addresses optionally used in 'vkCmdProcessCommandsNVX'.
     */
    minSequenceCountBufferOffsetAlignment: number

    /**
     * the minimum alignment for memory addresses optionally used in 'vkCmdProcessCommandsNVX'.
     */
    minSequenceIndexBufferOffsetAlignment: number

    /**
     * the minimum alignment for memory addresses optionally used in 'vkCmdProcessCommandsNVX'.
     */
    minCommandsTokenBufferOffsetAlignment: number
  }

  declare interface VkDeviceGeneratedCommandsLimitsNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * the maximum number of tokens in 'VkIndirectCommandsLayoutNVX'.
     */
    maxIndirectCommandsLayoutTokenCount?: number

    /**
     * the maximum number of entries per resource type in 'VkObjectTableNVX'.
     */
    maxObjectEntryCounts?: number

    /**
     * the minimum alignment for memory addresses optionally used in 'vkCmdProcessCommandsNVX'.
     */
    minSequenceCountBufferOffsetAlignment?: number

    /**
     * the minimum alignment for memory addresses optionally used in 'vkCmdProcessCommandsNVX'.
     */
    minSequenceIndexBufferOffsetAlignment?: number

    /**
     * the minimum alignment for memory addresses optionally used in 'vkCmdProcessCommandsNVX'.
     */
    minCommandsTokenBufferOffsetAlignment?: number
  }

  declare interface VkDeviceGeneratedCommandsLimitsNVXConstructor {
    readonly prototype: VkDeviceGeneratedCommandsLimitsNVX
    new (
      param?: VkDeviceGeneratedCommandsLimitsNVXInitializer | null
    ): VkDeviceGeneratedCommandsLimitsNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGeneratedCommandsLimitsNVX: VkDeviceGeneratedCommandsLimitsNVXConstructor

  /**
   * Structure specifying physical device support
   */
  interface VkDeviceGeneratedCommandsFeaturesNVX {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether the 'VkObjectTableNVX' supports entries with 'VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX' bit set and 'VkIndirectCommandsLayoutNVX' supports 'VK_PIPELINE_BIND_POINT_COMPUTE'.
     */
    computeBindingPointSupport: boolean
  }

  declare interface VkDeviceGeneratedCommandsFeaturesNVXInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether the 'VkObjectTableNVX' supports entries with 'VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX' bit set and 'VkIndirectCommandsLayoutNVX' supports 'VK_PIPELINE_BIND_POINT_COMPUTE'.
     */
    computeBindingPointSupport?: boolean
  }

  declare interface VkDeviceGeneratedCommandsFeaturesNVXConstructor {
    readonly prototype: VkDeviceGeneratedCommandsFeaturesNVX
    new (
      param?: VkDeviceGeneratedCommandsFeaturesNVXInitializer | null
    ): VkDeviceGeneratedCommandsFeaturesNVX

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceGeneratedCommandsFeaturesNVX: VkDeviceGeneratedCommandsFeaturesNVXConstructor

  /**
   * use Windows keyex mutex mechanism to synchronize work
   */
  interface VkWin32KeyedMutexAcquireReleaseInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    sType: VkStructureType

    /**
     *
     */
    pNext: null

    /**
     *
     */
    acquireCount: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys: BigUint64Array | null

    /**
     * is an array of timeout values, in millisecond units, for each acquire specified in 'pAcquireKeys'.
     */
    pAcquireTimeoutMilliseconds: Uint32Array | null

    /**
     *
     */
    releaseCount: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys: BigUint64Array | null
  }

  declare interface VkWin32KeyedMutexAcquireReleaseInfoNVInitializer {
    /**
     *
     */
    sType?: VkStructureType

    /**
     *
     */
    pNext?: null

    /**
     *
     */
    acquireCount?: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs?: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys?: BigUint64Array | null

    /**
     * is an array of timeout values, in millisecond units, for each acquire specified in 'pAcquireKeys'.
     */
    pAcquireTimeoutMilliseconds?: Uint32Array | null

    /**
     *
     */
    releaseCount?: number

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs?: VkDeviceMemory[] | null

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys?: BigUint64Array | null
  }

  declare interface VkWin32KeyedMutexAcquireReleaseInfoNVConstructor {
    readonly prototype: VkWin32KeyedMutexAcquireReleaseInfoNV
    new (
      param?: VkWin32KeyedMutexAcquireReleaseInfoNVInitializer | null
    ): VkWin32KeyedMutexAcquireReleaseInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkWin32KeyedMutexAcquireReleaseInfoNV: VkWin32KeyedMutexAcquireReleaseInfoNVConstructor

  /**
   * specify security attributes and access rights for Win32 memory handles
   */
  interface VkExportMemoryWin32HandleInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number
  }

  declare interface VkExportMemoryWin32HandleInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number
  }

  declare interface VkExportMemoryWin32HandleInfoNVConstructor {
    readonly prototype: VkExportMemoryWin32HandleInfoNV
    new (
      param?: VkExportMemoryWin32HandleInfoNVInitializer | null
    ): VkExportMemoryWin32HandleInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportMemoryWin32HandleInfoNV: VkExportMemoryWin32HandleInfoNVConstructor

  /**
   * import Win32 memory created on the same physical device
   */
  interface VkImportMemoryWin32HandleInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is `0` or a 'VkExternalMemoryHandleTypeFlagBitsNV' value specifying the type of memory handle in 'handle'.
     */
    handleType: VkExternalMemoryHandleTypeFlagBitsNV

    /**
     * is a Windows 'HANDLE' referring to the memory.
     */
    handle: bigint | number
  }

  declare interface VkImportMemoryWin32HandleInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is `0` or a 'VkExternalMemoryHandleTypeFlagBitsNV' value specifying the type of memory handle in 'handle'.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBitsNV

    /**
     * is a Windows 'HANDLE' referring to the memory.
     */
    handle?: bigint | number
  }

  declare interface VkImportMemoryWin32HandleInfoNVConstructor {
    readonly prototype: VkImportMemoryWin32HandleInfoNV
    new (
      param?: VkImportMemoryWin32HandleInfoNVInitializer | null
    ): VkImportMemoryWin32HandleInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImportMemoryWin32HandleInfoNV: VkImportMemoryWin32HandleInfoNVConstructor

  /**
   * Specify memory handle types that may be exported
   */
  interface VkExportMemoryAllocateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more memory handle types that 'may' be exported. Multiple handle types 'may' be requested for the same allocation as long as they are compatible, as reported by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'.
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBitsNV
  }

  declare interface VkExportMemoryAllocateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more memory handle types that 'may' be exported. Multiple handle types 'may' be requested for the same allocation as long as they are compatible, as reported by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'.
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBitsNV
  }

  declare interface VkExportMemoryAllocateInfoNVConstructor {
    readonly prototype: VkExportMemoryAllocateInfoNV
    new (
      param?: VkExportMemoryAllocateInfoNVInitializer | null
    ): VkExportMemoryAllocateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExportMemoryAllocateInfoNV: VkExportMemoryAllocateInfoNVConstructor

  /**
   * Specify that an image may be backed by external memory
   */
  interface VkExternalMemoryImageCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more external memory handle types.
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBitsNV
  }

  declare interface VkExternalMemoryImageCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more external memory handle types.
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBitsNV
  }

  declare interface VkExternalMemoryImageCreateInfoNVConstructor {
    readonly prototype: VkExternalMemoryImageCreateInfoNV
    new (
      param?: VkExternalMemoryImageCreateInfoNVInitializer | null
    ): VkExternalMemoryImageCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalMemoryImageCreateInfoNV: VkExternalMemoryImageCreateInfoNVConstructor

  /**
   * Structure specifying external image format properties
   */
  interface VkExternalImageFormatPropertiesNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * will be filled in as when calling 'vkGetPhysicalDeviceImageFormatProperties', but the values returned 'may' vary depending on the external handle type requested.
     */
    readonly imageFormatProperties: VkImageFormatProperties | null

    /**
     * is a bitmask of 'VkExternalMemoryFeatureFlagBitsNV', indicating properties of the external memory handle type ('vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType') being queried, or 0 if the external memory handle type is 0.
     */
    readonly externalMemoryFeatures: VkExternalMemoryFeatureFlagBitsNV

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be used to create memory from which the handles of the type specified in 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' 'can' be exported, or 0 if the external memory handle type is 0.
     */
    readonly exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBitsNV

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be specified simultaneously with the handle type specified by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' when calling 'vkAllocateMemory', or 0 if the external memory handle type is 0. 'compatibleHandleTypes' will always contain 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType'
     */
    readonly compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBitsNV
  }

  declare interface VkExternalImageFormatPropertiesNVInitializer {
    /**
     * will be filled in as when calling 'vkGetPhysicalDeviceImageFormatProperties', but the values returned 'may' vary depending on the external handle type requested.
     */
    readonly imageFormatProperties?: VkImageFormatProperties | null

    /**
     * is a bitmask of 'VkExternalMemoryFeatureFlagBitsNV', indicating properties of the external memory handle type ('vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType') being queried, or 0 if the external memory handle type is 0.
     */
    readonly externalMemoryFeatures?: VkExternalMemoryFeatureFlagBitsNV

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be used to create memory from which the handles of the type specified in 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' 'can' be exported, or 0 if the external memory handle type is 0.
     */
    readonly exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagBitsNV

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be specified simultaneously with the handle type specified by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' when calling 'vkAllocateMemory', or 0 if the external memory handle type is 0. 'compatibleHandleTypes' will always contain 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType'
     */
    readonly compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagBitsNV
  }

  declare interface VkExternalImageFormatPropertiesNVConstructor {
    readonly prototype: VkExternalImageFormatPropertiesNV
    new (
      param?: VkExternalImageFormatPropertiesNVInitializer | null
    ): VkExternalImageFormatPropertiesNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExternalImageFormatPropertiesNV: VkExternalImageFormatPropertiesNVConstructor

  /**
   * Specify a dedicated memory allocation resource
   */
  interface VkDedicatedAllocationMemoryAllocateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is 'VK_NULL_HANDLE' or a handle of an image which this memory will be bound to.
     */
    image: VkImage | null

    /**
     * is 'VK_NULL_HANDLE' or a handle of a buffer which this memory will be bound to.
     */
    buffer: VkBuffer | null
  }

  declare interface VkDedicatedAllocationMemoryAllocateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is 'VK_NULL_HANDLE' or a handle of an image which this memory will be bound to.
     */
    image?: VkImage | null

    /**
     * is 'VK_NULL_HANDLE' or a handle of a buffer which this memory will be bound to.
     */
    buffer?: VkBuffer | null
  }

  declare interface VkDedicatedAllocationMemoryAllocateInfoNVConstructor {
    readonly prototype: VkDedicatedAllocationMemoryAllocateInfoNV
    new (
      param?: VkDedicatedAllocationMemoryAllocateInfoNVInitializer | null
    ): VkDedicatedAllocationMemoryAllocateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDedicatedAllocationMemoryAllocateInfoNV: VkDedicatedAllocationMemoryAllocateInfoNVConstructor

  /**
   * Specify that a buffer is bound to a dedicated memory resource
   */
  interface VkDedicatedAllocationBufferCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether the buffer will have a dedicated allocation bound to it.
     */
    dedicatedAllocation: boolean
  }

  declare interface VkDedicatedAllocationBufferCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether the buffer will have a dedicated allocation bound to it.
     */
    dedicatedAllocation?: boolean
  }

  declare interface VkDedicatedAllocationBufferCreateInfoNVConstructor {
    readonly prototype: VkDedicatedAllocationBufferCreateInfoNV
    new (
      param?: VkDedicatedAllocationBufferCreateInfoNVInitializer | null
    ): VkDedicatedAllocationBufferCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDedicatedAllocationBufferCreateInfoNV: VkDedicatedAllocationBufferCreateInfoNVConstructor

  /**
   * Specify that an image is bound to a dedicated memory resource
   */
  interface VkDedicatedAllocationImageCreateInfoNV {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * specifies whether the image will have a dedicated allocation bound to it.
     */
    dedicatedAllocation: boolean
  }

  declare interface VkDedicatedAllocationImageCreateInfoNVInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * specifies whether the image will have a dedicated allocation bound to it.
     */
    dedicatedAllocation?: boolean
  }

  declare interface VkDedicatedAllocationImageCreateInfoNVConstructor {
    readonly prototype: VkDedicatedAllocationImageCreateInfoNV
    new (
      param?: VkDedicatedAllocationImageCreateInfoNVInitializer | null
    ): VkDedicatedAllocationImageCreateInfoNV

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDedicatedAllocationImageCreateInfoNV: VkDedicatedAllocationImageCreateInfoNVConstructor

  /**
   * Specify parameters of a command buffer marker region
   */
  interface VkDebugMarkerMarkerInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a reference to a string containing the name of the marker.
     */
    pMarkerName: string | null

    /**
     * is an 'optional' RGBA color value that can be associated with the marker. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color: number[] | null
  }

  declare interface VkDebugMarkerMarkerInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a reference to a string containing the name of the marker.
     */
    pMarkerName?: string | null

    /**
     * is an 'optional' RGBA color value that can be associated with the marker. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color?: number[] | null
  }

  declare interface VkDebugMarkerMarkerInfoEXTConstructor {
    readonly prototype: VkDebugMarkerMarkerInfoEXT
    new (
      param?: VkDebugMarkerMarkerInfoEXTInitializer | null
    ): VkDebugMarkerMarkerInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugMarkerMarkerInfoEXT: VkDebugMarkerMarkerInfoEXTConstructor

  /**
   * Specify parameters of a tag to attach to an object
   */
  interface VkDebugMarkerObjectTagInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType: VkDebugReportObjectTypeEXT

    /**
     * is the object to be tagged.
     */
    object: bigint | number

    /**
     * is a numerical identifier of the tag.
     */
    tagName: bigint | number

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize: bigint | number

    /**
     *
     */
    pTag: ArrayBuffer | null
  }

  declare interface VkDebugMarkerObjectTagInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType?: VkDebugReportObjectTypeEXT

    /**
     * is the object to be tagged.
     */
    object?: bigint | number

    /**
     * is a numerical identifier of the tag.
     */
    tagName?: bigint | number

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize?: bigint | number

    /**
     *
     */
    pTag?: ArrayBuffer | null
  }

  declare interface VkDebugMarkerObjectTagInfoEXTConstructor {
    readonly prototype: VkDebugMarkerObjectTagInfoEXT
    new (
      param?: VkDebugMarkerObjectTagInfoEXTInitializer | null
    ): VkDebugMarkerObjectTagInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugMarkerObjectTagInfoEXT: VkDebugMarkerObjectTagInfoEXTConstructor

  /**
   * Specify parameters of a name to give to an object
   */
  interface VkDebugMarkerObjectNameInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType: VkDebugReportObjectTypeEXT

    /**
     * is the object to be named.
     */
    object: bigint | number

    /**
     * is a string specifying the name to apply to 'object'.
     */
    pObjectName: string | null
  }

  declare interface VkDebugMarkerObjectNameInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType?: VkDebugReportObjectTypeEXT

    /**
     * is the object to be named.
     */
    object?: bigint | number

    /**
     * is a string specifying the name to apply to 'object'.
     */
    pObjectName?: string | null
  }

  declare interface VkDebugMarkerObjectNameInfoEXTConstructor {
    readonly prototype: VkDebugMarkerObjectNameInfoEXT
    new (
      param?: VkDebugMarkerObjectNameInfoEXTInitializer | null
    ): VkDebugMarkerObjectNameInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugMarkerObjectNameInfoEXT: VkDebugMarkerObjectNameInfoEXTConstructor

  /**
   * Structure defining rasterization order for a graphics pipeline
   */
  interface VkPipelineRasterizationStateRasterizationOrderAMD {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkRasterizationOrderAMD' value specifying the primitive rasterization order to use.
     */
    rasterizationOrder: VkRasterizationOrderAMD
  }

  declare interface VkPipelineRasterizationStateRasterizationOrderAMDInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkRasterizationOrderAMD' value specifying the primitive rasterization order to use.
     */
    rasterizationOrder?: VkRasterizationOrderAMD
  }

  declare interface VkPipelineRasterizationStateRasterizationOrderAMDConstructor {
    readonly prototype: VkPipelineRasterizationStateRasterizationOrderAMD
    new (
      param?: VkPipelineRasterizationStateRasterizationOrderAMDInitializer | null
    ): VkPipelineRasterizationStateRasterizationOrderAMD

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRasterizationStateRasterizationOrderAMD: VkPipelineRasterizationStateRasterizationOrderAMDConstructor

  /**
   * Specify validation features to enable or disable for a Vulkan instance
   */
  interface VkValidationFeaturesEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of features to enable.
     */
    enabledValidationFeatureCount: number

    /**
     * is an array of 'VkValidationFeatureEnableEXT' values specifying the validation features to be enabled.
     */
    pEnabledValidationFeatures: Int32Array | null

    /**
     * is the number of features to disable.
     */
    disabledValidationFeatureCount: number

    /**
     * is an array of 'VkValidationFeatureDisableEXT' values specifying the validation features to be disabled.
     */
    pDisabledValidationFeatures: Int32Array | null
  }

  declare interface VkValidationFeaturesEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of features to enable.
     */
    enabledValidationFeatureCount?: number

    /**
     * is an array of 'VkValidationFeatureEnableEXT' values specifying the validation features to be enabled.
     */
    pEnabledValidationFeatures?: Int32Array | null

    /**
     * is the number of features to disable.
     */
    disabledValidationFeatureCount?: number

    /**
     * is an array of 'VkValidationFeatureDisableEXT' values specifying the validation features to be disabled.
     */
    pDisabledValidationFeatures?: Int32Array | null
  }

  declare interface VkValidationFeaturesEXTConstructor {
    readonly prototype: VkValidationFeaturesEXT
    new (
      param?: VkValidationFeaturesEXTInitializer | null
    ): VkValidationFeaturesEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkValidationFeaturesEXT: VkValidationFeaturesEXTConstructor

  /**
   * Specify validation checks to disable for a Vulkan instance
   */
  interface VkValidationFlagsEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of checks to disable.
     */
    disabledValidationCheckCount: number

    /**
     * is an array of 'VkValidationCheckEXT' values specifying the validation checks to be disabled.
     */
    pDisabledValidationChecks: Int32Array | null
  }

  declare interface VkValidationFlagsEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of checks to disable.
     */
    disabledValidationCheckCount?: number

    /**
     * is an array of 'VkValidationCheckEXT' values specifying the validation checks to be disabled.
     */
    pDisabledValidationChecks?: Int32Array | null
  }

  declare interface VkValidationFlagsEXTConstructor {
    readonly prototype: VkValidationFlagsEXT
    new (param?: VkValidationFlagsEXTInitializer | null): VkValidationFlagsEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkValidationFlagsEXT: VkValidationFlagsEXTConstructor

  /**
   * Structure specifying parameters of a newly created debug report callback
   */
  interface VkDebugReportCallbackCreateInfoEXT {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkDebugReportFlagBitsEXT' specifying which event(s) will cause this callback to be called.
     */
    flags: VkDebugReportFlagBitsEXT

    /**
     * is the application callback function to call.
     */
    pfnCallback: vkDebugReportCallbackEXT | null

    /**
     * is user data to be passed to the callback.
     */
    pUserData: ArrayBuffer | null
  }

  declare interface VkDebugReportCallbackCreateInfoEXTInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkDebugReportFlagBitsEXT' specifying which event(s) will cause this callback to be called.
     */
    flags?: VkDebugReportFlagBitsEXT

    /**
     * is the application callback function to call.
     */
    pfnCallback?: vkDebugReportCallbackEXT | null

    /**
     * is user data to be passed to the callback.
     */
    pUserData?: ArrayBuffer | null
  }

  declare interface VkDebugReportCallbackCreateInfoEXTConstructor {
    readonly prototype: VkDebugReportCallbackCreateInfoEXT
    new (
      param?: VkDebugReportCallbackCreateInfoEXTInitializer | null
    ): VkDebugReportCallbackCreateInfoEXT

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDebugReportCallbackCreateInfoEXT: VkDebugReportCallbackCreateInfoEXTConstructor

  /**
   * Structure describing parameters of a queue presentation
   */
  interface VkPresentInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of semaphores to wait for before issuing the present request. The number 'may' be zero.
     */
    waitSemaphoreCount: number

    /**
     * is <i>null</i> or a reference to an array of 'VkSemaphore' objects with 'waitSemaphoreCount' entries, and specifies the semaphores to wait for before issuing the present request.
     */
    pWaitSemaphores: VkSemaphore[] | null

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount: number

    /**
     * is an array of 'VkSwapchainKHR' objects with 'swapchainCount' entries. A given swapchain 'must' not appear in this list more than once.
     */
    pSwapchains: VkSwapchainKHR[] | null

    /**
     * is an array of indices into the array of each swapchain's presentable images, with 'swapchainCount' entries. Each entry in this array identifies the image to present on the corresponding entry in the 'pSwapchains' array.
     */
    pImageIndices: Uint32Array | null

    /**
     * is an array of 'VkResult' typed elements with 'swapchainCount' entries. Applications that do not need per-swapchain results 'can' use <i>null</i> for 'pResults'. If non-<i>null</i>, each entry in 'pResults' will be set to the 'VkResult' for presenting the swapchain corresponding to the same index in 'pSwapchains'.
     */
    pResults: Int32Array | null
  }

  declare interface VkPresentInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of semaphores to wait for before issuing the present request. The number 'may' be zero.
     */
    waitSemaphoreCount?: number

    /**
     * is <i>null</i> or a reference to an array of 'VkSemaphore' objects with 'waitSemaphoreCount' entries, and specifies the semaphores to wait for before issuing the present request.
     */
    pWaitSemaphores?: VkSemaphore[] | null

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount?: number

    /**
     * is an array of 'VkSwapchainKHR' objects with 'swapchainCount' entries. A given swapchain 'must' not appear in this list more than once.
     */
    pSwapchains?: VkSwapchainKHR[] | null

    /**
     * is an array of indices into the array of each swapchain's presentable images, with 'swapchainCount' entries. Each entry in this array identifies the image to present on the corresponding entry in the 'pSwapchains' array.
     */
    pImageIndices?: Uint32Array | null

    /**
     * is an array of 'VkResult' typed elements with 'swapchainCount' entries. Applications that do not need per-swapchain results 'can' use <i>null</i> for 'pResults'. If non-<i>null</i>, each entry in 'pResults' will be set to the 'VkResult' for presenting the swapchain corresponding to the same index in 'pSwapchains'.
     */
    pResults?: Int32Array | null
  }

  declare interface VkPresentInfoKHRConstructor {
    readonly prototype: VkPresentInfoKHR
    new (param?: VkPresentInfoKHRInitializer | null): VkPresentInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPresentInfoKHR: VkPresentInfoKHRConstructor

  /**
   * Structure specifying parameters of a newly created swapchain object
   */
  interface VkSwapchainCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkSwapchainCreateFlagBitsKHR' indicating parameters of the swapchain creation.
     */
    flags: VkSwapchainCreateFlagBitsKHR

    /**
     * is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with 'surface'.
     */
    surface: VkSurfaceKHR | null

    /**
     * is the minimum number of presentable images that the application needs. The implementation will either create the swapchain with at least that many images, or it will fail to create the swapchain.
     */
    minImageCount: number

    /**
     * is a 'VkFormat' value specifying the format the swapchain image(s) will be created with.
     */
    imageFormat: VkFormat

    /**
     * is a 'VkColorSpaceKHR' value specifying the way the swapchain interprets image data.
     */
    imageColorSpace: VkColorSpaceKHR

    /**
     * is the size (in pixels) of the swapchain image(s). The behavior is platform-dependent if the image extent does not match the surface's 'currentExtent' as returned by 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR'.
     */
    imageExtent: VkExtent2D | null

    /**
     *
     */
    imageArrayLayers: number

    /**
     *
     */
    imageUsage: VkImageUsageFlagBits

    /**
     *
     */
    imageSharingMode: VkSharingMode

    /**
     *
     */
    queueFamilyIndexCount: number

    /**
     *
     */
    pQueueFamilyIndices: Uint32Array | null

    /**
     *
     */
    preTransform: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    compositeAlpha: VkCompositeAlphaFlagBitsKHR

    /**
     *
     */
    presentMode: VkPresentModeKHR

    /**
     *
     */
    clipped: boolean

    /**
     *
     */
    oldSwapchain: VkSwapchainKHR | null
  }

  declare interface VkSwapchainCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkSwapchainCreateFlagBitsKHR' indicating parameters of the swapchain creation.
     */
    flags?: VkSwapchainCreateFlagBitsKHR

    /**
     * is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with 'surface'.
     */
    surface?: VkSurfaceKHR | null

    /**
     * is the minimum number of presentable images that the application needs. The implementation will either create the swapchain with at least that many images, or it will fail to create the swapchain.
     */
    minImageCount?: number

    /**
     * is a 'VkFormat' value specifying the format the swapchain image(s) will be created with.
     */
    imageFormat?: VkFormat

    /**
     * is a 'VkColorSpaceKHR' value specifying the way the swapchain interprets image data.
     */
    imageColorSpace?: VkColorSpaceKHR

    /**
     * is the size (in pixels) of the swapchain image(s). The behavior is platform-dependent if the image extent does not match the surface's 'currentExtent' as returned by 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR'.
     */
    imageExtent?: VkExtent2D | null

    /**
     *
     */
    imageArrayLayers?: number

    /**
     *
     */
    imageUsage?: VkImageUsageFlagBits

    /**
     *
     */
    imageSharingMode?: VkSharingMode

    /**
     *
     */
    queueFamilyIndexCount?: number

    /**
     *
     */
    pQueueFamilyIndices?: Uint32Array | null

    /**
     *
     */
    preTransform?: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    compositeAlpha?: VkCompositeAlphaFlagBitsKHR

    /**
     *
     */
    presentMode?: VkPresentModeKHR

    /**
     *
     */
    clipped?: boolean

    /**
     *
     */
    oldSwapchain?: VkSwapchainKHR | null
  }

  declare interface VkSwapchainCreateInfoKHRConstructor {
    readonly prototype: VkSwapchainCreateInfoKHR
    new (
      param?: VkSwapchainCreateInfoKHRInitializer | null
    ): VkSwapchainCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSwapchainCreateInfoKHR: VkSwapchainCreateInfoKHRConstructor

  /**
   * Structure describing a supported swapchain format-color space pair
   */
  interface VkSurfaceFormatKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkFormat' that is compatible with the specified surface.
     */
    readonly format: VkFormat

    /**
     * is a presentation 'VkColorSpaceKHR' that is compatible with the surface.
     */
    readonly colorSpace: VkColorSpaceKHR
  }

  declare interface VkSurfaceFormatKHRInitializer {
    /**
     * is a 'VkFormat' that is compatible with the specified surface.
     */
    readonly format?: VkFormat

    /**
     * is a presentation 'VkColorSpaceKHR' that is compatible with the surface.
     */
    readonly colorSpace?: VkColorSpaceKHR
  }

  declare interface VkSurfaceFormatKHRConstructor {
    readonly prototype: VkSurfaceFormatKHR
    new (param?: VkSurfaceFormatKHRInitializer | null): VkSurfaceFormatKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceFormatKHR: VkSurfaceFormatKHRConstructor

  /**
   * Structure specifying parameters of a newly created Win32 surface object
   */
  interface VkWin32SurfaceCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the Win32 'HINSTANCE' for the window to associate the surface with.
     */
    hinstance: bigint | number

    /**
     * is the Win32 'HWND' for the window to associate the surface with.
     */
    hwnd: bigint | number
  }

  declare interface VkWin32SurfaceCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the Win32 'HINSTANCE' for the window to associate the surface with.
     */
    hinstance?: bigint | number

    /**
     * is the Win32 'HWND' for the window to associate the surface with.
     */
    hwnd?: bigint | number
  }

  declare interface VkWin32SurfaceCreateInfoKHRConstructor {
    readonly prototype: VkWin32SurfaceCreateInfoKHR
    new (
      param?: VkWin32SurfaceCreateInfoKHRInitializer | null
    ): VkWin32SurfaceCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkWin32SurfaceCreateInfoKHR: VkWin32SurfaceCreateInfoKHRConstructor

  /**
   * Structure describing capabilities of a surface
   */
  interface VkSurfaceCapabilitiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.
     */
    readonly minImageCount: number

    /**
     * is the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to 'minImageCount'. A value of 0 means that there is no limit on the number of images, though there 'may' be limits related to the total amount of memory used by presentable images.
     */
    readonly maxImageCount: number

    /**
     * is the current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.
     */
    readonly currentExtent: VkExtent2D | null

    /**
     * contains the smallest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be less than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly minImageExtent: VkExtent2D | null

    /**
     * contains the largest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'minImageExtent'. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly maxImageExtent: VkExtent2D | null

    /**
     * is the maximum number of layers presentable images 'can' have for a swapchain created for this device and surface, and will be at least one.
     */
    readonly maxImageArrayLayers: number

    /**
     * is a bitmask of 'VkSurfaceTransformFlagBitsKHR' indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.
     */
    readonly supportedTransforms: VkSurfaceTransformFlagBitsKHR

    /**
     * is 'VkSurfaceTransformFlagBitsKHR' value indicating the surface's current transform relative to the presentation engine's natural orientation.
     */
    readonly currentTransform: VkSurfaceTransformFlagBitsKHR

    /**
     * is a bitmask of 'VkCompositeAlphaFlagBitsKHR', representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition 'can' be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.
     */
    readonly supportedCompositeAlpha: VkCompositeAlphaFlagBitsKHR

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the presentable images of a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_IMMEDIATE_KHR', 'VK_PRESENT_MODE_MAILBOX_KHR', 'VK_PRESENT_MODE_FIFO_KHR' or 'VK_PRESENT_MODE_FIFO_RELAXED_KHR'
     */
    readonly supportedUsageFlags: VkImageUsageFlagBits
  }

  declare interface VkSurfaceCapabilitiesKHRInitializer {
    /**
     * is the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.
     */
    readonly minImageCount?: number

    /**
     * is the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to 'minImageCount'. A value of 0 means that there is no limit on the number of images, though there 'may' be limits related to the total amount of memory used by presentable images.
     */
    readonly maxImageCount?: number

    /**
     * is the current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.
     */
    readonly currentExtent?: VkExtent2D | null

    /**
     * contains the smallest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be less than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly minImageExtent?: VkExtent2D | null

    /**
     * contains the largest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'minImageExtent'. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly maxImageExtent?: VkExtent2D | null

    /**
     * is the maximum number of layers presentable images 'can' have for a swapchain created for this device and surface, and will be at least one.
     */
    readonly maxImageArrayLayers?: number

    /**
     * is a bitmask of 'VkSurfaceTransformFlagBitsKHR' indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.
     */
    readonly supportedTransforms?: VkSurfaceTransformFlagBitsKHR

    /**
     * is 'VkSurfaceTransformFlagBitsKHR' value indicating the surface's current transform relative to the presentation engine's natural orientation.
     */
    readonly currentTransform?: VkSurfaceTransformFlagBitsKHR

    /**
     * is a bitmask of 'VkCompositeAlphaFlagBitsKHR', representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition 'can' be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.
     */
    readonly supportedCompositeAlpha?: VkCompositeAlphaFlagBitsKHR

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the presentable images of a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_IMMEDIATE_KHR', 'VK_PRESENT_MODE_MAILBOX_KHR', 'VK_PRESENT_MODE_FIFO_KHR' or 'VK_PRESENT_MODE_FIFO_RELAXED_KHR'
     */
    readonly supportedUsageFlags?: VkImageUsageFlagBits
  }

  declare interface VkSurfaceCapabilitiesKHRConstructor {
    readonly prototype: VkSurfaceCapabilitiesKHR
    new (
      param?: VkSurfaceCapabilitiesKHRInitializer | null
    ): VkSurfaceCapabilitiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSurfaceCapabilitiesKHR: VkSurfaceCapabilitiesKHRConstructor

  /**
   * Structure describing parameters of a queue presentation to a swapchain
   */
  interface VkDisplayPresentInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a rectangular region of pixels to present. It 'must' be a subset of the image being presented. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire presentable image.
     */
    srcRect: VkRect2D | null

    /**
     * is a rectangular region within the visible region of the swapchain's display mode. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.
     */
    dstRect: VkRect2D | null

    /**
     *
     */
    persistent: boolean
  }

  declare interface VkDisplayPresentInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a rectangular region of pixels to present. It 'must' be a subset of the image being presented. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire presentable image.
     */
    srcRect?: VkRect2D | null

    /**
     * is a rectangular region within the visible region of the swapchain's display mode. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.
     */
    dstRect?: VkRect2D | null

    /**
     *
     */
    persistent?: boolean
  }

  declare interface VkDisplayPresentInfoKHRConstructor {
    readonly prototype: VkDisplayPresentInfoKHR
    new (
      param?: VkDisplayPresentInfoKHRInitializer | null
    ): VkDisplayPresentInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPresentInfoKHR: VkDisplayPresentInfoKHRConstructor

  /**
   * Structure specifying parameters of a newly created display plane surface object
   */
  interface VkDisplaySurfaceCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags: number

    /**
     * is a 'VkDisplayModeKHR' handle specifying the mode to use when displaying this surface.
     */
    displayMode: VkDisplayModeKHR | null

    /**
     * is the plane on which this surface appears.
     */
    planeIndex: number

    /**
     * is the z-order of the plane.
     */
    planeStackIndex: number

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value specifying the transformation to apply to images as part of the scanout operation.
     */
    transform: VkSurfaceTransformFlagBitsKHR

    /**
     * is the global alpha value. This value is ignored if 'alphaMode' is not 'VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR'.
     */
    globalAlpha: number

    /**
     * is a 'VkDisplayPlaneAlphaFlagBitsKHR' value specifying the type of alpha blending to use.
     */
    alphaMode: VkDisplayPlaneAlphaFlagBitsKHR

    /**
     * The size of the presentable images to use with the surface.
     */
    imageExtent: VkExtent2D | null
  }

  declare interface VkDisplaySurfaceCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags?: number

    /**
     * is a 'VkDisplayModeKHR' handle specifying the mode to use when displaying this surface.
     */
    displayMode?: VkDisplayModeKHR | null

    /**
     * is the plane on which this surface appears.
     */
    planeIndex?: number

    /**
     * is the z-order of the plane.
     */
    planeStackIndex?: number

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value specifying the transformation to apply to images as part of the scanout operation.
     */
    transform?: VkSurfaceTransformFlagBitsKHR

    /**
     * is the global alpha value. This value is ignored if 'alphaMode' is not 'VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR'.
     */
    globalAlpha?: number

    /**
     * is a 'VkDisplayPlaneAlphaFlagBitsKHR' value specifying the type of alpha blending to use.
     */
    alphaMode?: VkDisplayPlaneAlphaFlagBitsKHR

    /**
     * The size of the presentable images to use with the surface.
     */
    imageExtent?: VkExtent2D | null
  }

  declare interface VkDisplaySurfaceCreateInfoKHRConstructor {
    readonly prototype: VkDisplaySurfaceCreateInfoKHR
    new (
      param?: VkDisplaySurfaceCreateInfoKHRInitializer | null
    ): VkDisplaySurfaceCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplaySurfaceCreateInfoKHR: VkDisplaySurfaceCreateInfoKHRConstructor

  /**
   * Structure describing capabilities of a mode and plane combination
   */
  interface VkDisplayPlaneCapabilitiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkDisplayPlaneAlphaFlagBitsKHR' describing the supported alpha blending modes.
     */
    readonly supportedAlpha: VkDisplayPlaneAlphaFlagBitsKHR

    /**
     * is the minimum source rectangle offset supported by this plane using the specified mode.
     */
    readonly minSrcPosition: VkOffset2D | null

    /**
     * is the maximum source rectangle offset supported by this plane using the specified mode. The 'x' and 'y' components of 'maxSrcPosition' 'must' each be greater than or equal to the 'x' and 'y' components of 'minSrcPosition', respectively.
     */
    readonly maxSrcPosition: VkOffset2D | null

    /**
     * is the minimum source rectangle size supported by this plane using the specified mode.
     */
    readonly minSrcExtent: VkExtent2D | null

    /**
     * is the maximum source rectangle size supported by this plane using the specified mode.
     */
    readonly maxSrcExtent: VkExtent2D | null

    /**
     *
     */
    readonly minDstPosition: VkOffset2D | null

    /**
     *
     */
    readonly maxDstPosition: VkOffset2D | null

    /**
     *
     */
    readonly minDstExtent: VkExtent2D | null

    /**
     *
     */
    readonly maxDstExtent: VkExtent2D | null
  }

  declare interface VkDisplayPlaneCapabilitiesKHRInitializer {
    /**
     * is a bitmask of 'VkDisplayPlaneAlphaFlagBitsKHR' describing the supported alpha blending modes.
     */
    readonly supportedAlpha?: VkDisplayPlaneAlphaFlagBitsKHR

    /**
     * is the minimum source rectangle offset supported by this plane using the specified mode.
     */
    readonly minSrcPosition?: VkOffset2D | null

    /**
     * is the maximum source rectangle offset supported by this plane using the specified mode. The 'x' and 'y' components of 'maxSrcPosition' 'must' each be greater than or equal to the 'x' and 'y' components of 'minSrcPosition', respectively.
     */
    readonly maxSrcPosition?: VkOffset2D | null

    /**
     * is the minimum source rectangle size supported by this plane using the specified mode.
     */
    readonly minSrcExtent?: VkExtent2D | null

    /**
     * is the maximum source rectangle size supported by this plane using the specified mode.
     */
    readonly maxSrcExtent?: VkExtent2D | null

    /**
     *
     */
    readonly minDstPosition?: VkOffset2D | null

    /**
     *
     */
    readonly maxDstPosition?: VkOffset2D | null

    /**
     *
     */
    readonly minDstExtent?: VkExtent2D | null

    /**
     *
     */
    readonly maxDstExtent?: VkExtent2D | null
  }

  declare interface VkDisplayPlaneCapabilitiesKHRConstructor {
    readonly prototype: VkDisplayPlaneCapabilitiesKHR
    new (
      param?: VkDisplayPlaneCapabilitiesKHRInitializer | null
    ): VkDisplayPlaneCapabilitiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPlaneCapabilitiesKHR: VkDisplayPlaneCapabilitiesKHRConstructor

  /**
   * Structure specifying parameters of a newly created display mode object
   */
  interface VkDisplayModeCreateInfoKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags: number

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation 'must' return 'VK_ERROR_INITIALIZATION_FAILED'.
     */
    parameters: VkDisplayModeParametersKHR | null
  }

  declare interface VkDisplayModeCreateInfoKHRInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags?: number

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation 'must' return 'VK_ERROR_INITIALIZATION_FAILED'.
     */
    parameters?: VkDisplayModeParametersKHR | null
  }

  declare interface VkDisplayModeCreateInfoKHRConstructor {
    readonly prototype: VkDisplayModeCreateInfoKHR
    new (
      param?: VkDisplayModeCreateInfoKHRInitializer | null
    ): VkDisplayModeCreateInfoKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayModeCreateInfoKHR: VkDisplayModeCreateInfoKHRConstructor

  /**
   * Structure describing display mode properties
   */
  interface VkDisplayModePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly displayMode: VkDisplayModeKHR | null

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters associated with 'displayMode'.
     */
    readonly parameters: VkDisplayModeParametersKHR | null
  }

  declare interface VkDisplayModePropertiesKHRInitializer {
    /**
     * is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly displayMode?: VkDisplayModeKHR | null

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters associated with 'displayMode'.
     */
    readonly parameters?: VkDisplayModeParametersKHR | null
  }

  declare interface VkDisplayModePropertiesKHRConstructor {
    readonly prototype: VkDisplayModePropertiesKHR
    new (
      param?: VkDisplayModePropertiesKHRInitializer | null
    ): VkDisplayModePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayModePropertiesKHR: VkDisplayModePropertiesKHRConstructor

  /**
   * Structure describing display parameters associated with a display mode
   */
  interface VkDisplayModeParametersKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the 2D extents of the visible region.
     */
    visibleRegion: VkExtent2D | null

    /**
     * is a 'uint32_t' that is the number of times the display is refreshed each second multiplied by 1000.
     */
    refreshRate: number
  }

  declare interface VkDisplayModeParametersKHRInitializer {
    /**
     * is the 2D extents of the visible region.
     */
    visibleRegion?: VkExtent2D | null

    /**
     * is a 'uint32_t' that is the number of times the display is refreshed each second multiplied by 1000.
     */
    refreshRate?: number
  }

  declare interface VkDisplayModeParametersKHRConstructor {
    readonly prototype: VkDisplayModeParametersKHR
    new (
      param?: VkDisplayModeParametersKHRInitializer | null
    ): VkDisplayModeParametersKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayModeParametersKHR: VkDisplayModeParametersKHRConstructor

  /**
   * Structure describing display plane properties
   */
  interface VkDisplayPlanePropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be 'VK_NULL_HANDLE'.
     */
    readonly currentDisplay: VkDisplayKHR | null

    /**
     * is the current z-order of the plane. This will be between 0 and the value returned by 'vkGetPhysicalDeviceDisplayPlanePropertiesKHR' in 'pPropertyCount'.
     */
    readonly currentStackIndex: number
  }

  declare interface VkDisplayPlanePropertiesKHRInitializer {
    /**
     * is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be 'VK_NULL_HANDLE'.
     */
    readonly currentDisplay?: VkDisplayKHR | null

    /**
     * is the current z-order of the plane. This will be between 0 and the value returned by 'vkGetPhysicalDeviceDisplayPlanePropertiesKHR' in 'pPropertyCount'.
     */
    readonly currentStackIndex?: number
  }

  declare interface VkDisplayPlanePropertiesKHRConstructor {
    readonly prototype: VkDisplayPlanePropertiesKHR
    new (
      param?: VkDisplayPlanePropertiesKHRInitializer | null
    ): VkDisplayPlanePropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPlanePropertiesKHR: VkDisplayPlanePropertiesKHRConstructor

  /**
   * Structure describing an available display device
   */
  interface VkDisplayPropertiesKHR {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly display: VkDisplayKHR | null

    /**
     * is a reference to a string containing the name of the display. Generally, this will be the name provided by the display's EDID. It 'can' be <i>null</i> if no suitable name is available. If not <i>null</i>, the memory it reference to 'must' remain accessible as long as 'display' is valid.
     */
    readonly displayName: string | null

    /**
     * describes the physical width and height of the visible portion of the display, in millimeters.
     */
    readonly physicalDimensions: VkExtent2D | null

    /**
     * describes the physical, native, or preferred resolution of the display.
     */
    readonly physicalResolution: VkExtent2D | null

    /**
     *
     */
    readonly supportedTransforms: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    readonly planeReorderPossible: boolean

    /**
     *
     */
    readonly persistentContent: boolean
  }

  declare interface VkDisplayPropertiesKHRInitializer {
    /**
     * is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly display?: VkDisplayKHR | null

    /**
     * is a reference to a string containing the name of the display. Generally, this will be the name provided by the display's EDID. It 'can' be <i>null</i> if no suitable name is available. If not <i>null</i>, the memory it reference to 'must' remain accessible as long as 'display' is valid.
     */
    readonly displayName?: string | null

    /**
     * describes the physical width and height of the visible portion of the display, in millimeters.
     */
    readonly physicalDimensions?: VkExtent2D | null

    /**
     * describes the physical, native, or preferred resolution of the display.
     */
    readonly physicalResolution?: VkExtent2D | null

    /**
     *
     */
    readonly supportedTransforms?: VkSurfaceTransformFlagBitsKHR

    /**
     *
     */
    readonly planeReorderPossible?: boolean

    /**
     *
     */
    readonly persistentContent?: boolean
  }

  declare interface VkDisplayPropertiesKHRConstructor {
    readonly prototype: VkDisplayPropertiesKHR
    new (
      param?: VkDisplayPropertiesKHRInitializer | null
    ): VkDisplayPropertiesKHR

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDisplayPropertiesKHR: VkDisplayPropertiesKHRConstructor

  /**
   * Structure specifying a queue submit operation
   */
  interface VkSubmitInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of semaphores upon which to wait before executing the command buffers for the batch.
     */
    waitSemaphoreCount: number

    /**
     * is an array of 'VkSemaphore' handles upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores: VkSemaphore[] | null

    /**
     * is an array of pipeline stages at which each corresponding semaphore wait will occur.
     */
    pWaitDstStageMask: Int32Array | null

    /**
     * is the number of command buffers to execute in the batch.
     */
    commandBufferCount: number

    /**
     * is an array of 'VkCommandBuffer' handles to execute in the batch.
     */
    pCommandBuffers: VkCommandBuffer[] | null

    /**
     * is the number of semaphores to be signaled once the commands specified in 'pCommandBuffers' have completed execution.
     */
    signalSemaphoreCount: number

    /**
     * is an array of 'VkSemaphore' handles which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores: VkSemaphore[] | null
  }

  declare interface VkSubmitInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of semaphores upon which to wait before executing the command buffers for the batch.
     */
    waitSemaphoreCount?: number

    /**
     * is an array of 'VkSemaphore' handles upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores?: VkSemaphore[] | null

    /**
     * is an array of pipeline stages at which each corresponding semaphore wait will occur.
     */
    pWaitDstStageMask?: Int32Array | null

    /**
     * is the number of command buffers to execute in the batch.
     */
    commandBufferCount?: number

    /**
     * is an array of 'VkCommandBuffer' handles to execute in the batch.
     */
    pCommandBuffers?: VkCommandBuffer[] | null

    /**
     * is the number of semaphores to be signaled once the commands specified in 'pCommandBuffers' have completed execution.
     */
    signalSemaphoreCount?: number

    /**
     * is an array of 'VkSemaphore' handles which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores?: VkSemaphore[] | null
  }

  declare interface VkSubmitInfoConstructor {
    readonly prototype: VkSubmitInfo
    new (param?: VkSubmitInfoInitializer | null): VkSubmitInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubmitInfo: VkSubmitInfoConstructor

  /**
   * Structure specifying a dispatch indirect command
   */
  interface VkDispatchIndirectCommand {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of local workgroups to dispatch in the X dimension.
     */
    x: number

    /**
     * is the number of local workgroups to dispatch in the Y dimension.
     */
    y: number

    /**
     * is the number of local workgroups to dispatch in the Z dimension.
     */
    z: number
  }

  declare interface VkDispatchIndirectCommandInitializer {
    /**
     * is the number of local workgroups to dispatch in the X dimension.
     */
    x?: number

    /**
     * is the number of local workgroups to dispatch in the Y dimension.
     */
    y?: number

    /**
     * is the number of local workgroups to dispatch in the Z dimension.
     */
    z?: number
  }

  declare interface VkDispatchIndirectCommandConstructor {
    readonly prototype: VkDispatchIndirectCommand
    new (
      param?: VkDispatchIndirectCommandInitializer | null
    ): VkDispatchIndirectCommand

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDispatchIndirectCommand: VkDispatchIndirectCommandConstructor

  /**
   * Structure specifying a draw indexed indirect command
   */
  interface VkDrawIndexedIndirectCommand {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of vertices to draw.
     */
    indexCount: number

    /**
     * is the number of instances to draw.
     */
    instanceCount: number

    /**
     * is the base index within the index buffer.
     */
    firstIndex: number

    /**
     * is the value added to the vertex index before indexing into the vertex buffer.
     */
    vertexOffset: number

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance: number
  }

  declare interface VkDrawIndexedIndirectCommandInitializer {
    /**
     * is the number of vertices to draw.
     */
    indexCount?: number

    /**
     * is the number of instances to draw.
     */
    instanceCount?: number

    /**
     * is the base index within the index buffer.
     */
    firstIndex?: number

    /**
     * is the value added to the vertex index before indexing into the vertex buffer.
     */
    vertexOffset?: number

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance?: number
  }

  declare interface VkDrawIndexedIndirectCommandConstructor {
    readonly prototype: VkDrawIndexedIndirectCommand
    new (
      param?: VkDrawIndexedIndirectCommandInitializer | null
    ): VkDrawIndexedIndirectCommand

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDrawIndexedIndirectCommand: VkDrawIndexedIndirectCommandConstructor

  /**
   * Structure specifying a draw indirect command
   */
  interface VkDrawIndirectCommand {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of vertices to draw.
     */
    vertexCount: number

    /**
     * is the number of instances to draw.
     */
    instanceCount: number

    /**
     * is the index of the first vertex to draw.
     */
    firstVertex: number

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance: number
  }

  declare interface VkDrawIndirectCommandInitializer {
    /**
     * is the number of vertices to draw.
     */
    vertexCount?: number

    /**
     * is the number of instances to draw.
     */
    instanceCount?: number

    /**
     * is the index of the first vertex to draw.
     */
    firstVertex?: number

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance?: number
  }

  declare interface VkDrawIndirectCommandConstructor {
    readonly prototype: VkDrawIndirectCommand
    new (param?: VkDrawIndirectCommandInitializer | null): VkDrawIndirectCommand

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDrawIndirectCommand: VkDrawIndirectCommandConstructor

  /**
   * Structure specifying parameters of a newly created framebuffer
   */
  interface VkFramebufferCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkFramebufferCreateFlagBits'
     */
    flags: VkFramebufferCreateFlagBits

    /**
     * is a render pass defining what render passes the framebuffer will be compatible with. See <<renderpass-compatibility,Render Pass Compatibility>> for details.
     */
    renderPass: VkRenderPass | null

    /**
     * is the number of attachments.
     */
    attachmentCount: number

    /**
     * is an array of 'VkImageView' handles, each of which will be used as the corresponding attachment in a render pass instance. If 'flags' includes 'VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR', this parameter is ignored.
     */
    pAttachments: VkImageView[] | null

    /**
     *
     */
    width: number

    /**
     *
     */
    height: number

    /**
     *
     */
    layers: number
  }

  declare interface VkFramebufferCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkFramebufferCreateFlagBits'
     */
    flags?: VkFramebufferCreateFlagBits

    /**
     * is a render pass defining what render passes the framebuffer will be compatible with. See <<renderpass-compatibility,Render Pass Compatibility>> for details.
     */
    renderPass?: VkRenderPass | null

    /**
     * is the number of attachments.
     */
    attachmentCount?: number

    /**
     * is an array of 'VkImageView' handles, each of which will be used as the corresponding attachment in a render pass instance. If 'flags' includes 'VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR', this parameter is ignored.
     */
    pAttachments?: VkImageView[] | null

    /**
     *
     */
    width?: number

    /**
     *
     */
    height?: number

    /**
     *
     */
    layers?: number
  }

  declare interface VkFramebufferCreateInfoConstructor {
    readonly prototype: VkFramebufferCreateInfo
    new (
      param?: VkFramebufferCreateInfoInitializer | null
    ): VkFramebufferCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFramebufferCreateInfo: VkFramebufferCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created query pool
   */
  interface VkQueryPoolCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is a 'VkQueryType' value specifying the type of queries managed by the pool.
     */
    queryType: VkQueryType

    /**
     * is the number of queries managed by the pool.
     */
    queryCount: number

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying which counters will be returned in queries on the new pool, as described below in <<queries-pipestats>>.
     */
    pipelineStatistics: VkQueryPipelineStatisticFlagBits
  }

  declare interface VkQueryPoolCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is a 'VkQueryType' value specifying the type of queries managed by the pool.
     */
    queryType?: VkQueryType

    /**
     * is the number of queries managed by the pool.
     */
    queryCount?: number

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying which counters will be returned in queries on the new pool, as described below in <<queries-pipestats>>.
     */
    pipelineStatistics?: VkQueryPipelineStatisticFlagBits
  }

  declare interface VkQueryPoolCreateInfoConstructor {
    readonly prototype: VkQueryPoolCreateInfo
    new (param?: VkQueryPoolCreateInfoInitializer | null): VkQueryPoolCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkQueryPoolCreateInfo: VkQueryPoolCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created semaphore
   */
  interface VkSemaphoreCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number
  }

  declare interface VkSemaphoreCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number
  }

  declare interface VkSemaphoreCreateInfoConstructor {
    readonly prototype: VkSemaphoreCreateInfo
    new (param?: VkSemaphoreCreateInfoInitializer | null): VkSemaphoreCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSemaphoreCreateInfo: VkSemaphoreCreateInfoConstructor

  /**
   * Structure reporting implementation-dependent physical device limits
   */
  interface VkPhysicalDeviceLimits {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly maxImageDimension1D: number

    /**
     *
     */
    readonly maxImageDimension2D: number

    /**
     *
     */
    readonly maxImageDimension3D: number

    /**
     *
     */
    readonly maxImageDimensionCube: number

    /**
     *
     */
    readonly maxImageArrayLayers: number

    /**
     *
     */
    readonly maxTexelBufferElements: number

    /**
     *
     */
    readonly maxUniformBufferRange: number

    /**
     *
     */
    readonly maxStorageBufferRange: number

    /**
     *
     */
    readonly maxPushConstantsSize: number

    /**
     * is the maximum number of device memory allocations, as created by 'vkAllocateMemory', which 'can' simultaneously exist.
     */
    readonly maxMemoryAllocationCount: number

    /**
     * is the maximum number of sampler objects, as created by 'vkCreateSampler', which 'can' simultaneously exist on a device.
     */
    readonly maxSamplerAllocationCount: number

    /**
     * is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources 'can' be bound to adjacent offsets in the same 'VkDeviceMemory' object without aliasing. See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for more details.
     */
    readonly bufferImageGranularity: bigint | number

    /**
     * is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.
     */
    readonly sparseAddressSpaceSize: bigint | number

    /**
     * is the maximum number of descriptor sets that 'can' be simultaneously used by a pipeline. All 'DescriptorSet' decorations in shader modules 'must' have a value less than 'maxBoundDescriptorSets'. See <<descriptorsets-sets>>.
     */
    readonly maxBoundDescriptorSets: number

    /**
     * is the maximum number of samplers that 'can' be accessible to a single shader stage in a pipeline layout. Descriptors with a type of 'VK_DESCRIPTOR_TYPE_SAMPLER' or 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' count against this limit. Only descriptors in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set count against this limit.
     */
    readonly maxPerStageDescriptorSamplers: number

    /**
     *
     */
    readonly maxPerStageDescriptorUniformBuffers: number

    /**
     *
     */
    readonly maxPerStageDescriptorStorageBuffers: number

    /**
     *
     */
    readonly maxPerStageDescriptorSampledImages: number

    /**
     *
     */
    readonly maxPerStageDescriptorStorageImages: number

    /**
     *
     */
    readonly maxPerStageDescriptorInputAttachments: number

    /**
     *
     */
    readonly maxPerStageResources: number

    /**
     *
     */
    readonly maxDescriptorSetSamplers: number

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffers: number

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffersDynamic: number

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffers: number

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffersDynamic: number

    /**
     *
     */
    readonly maxDescriptorSetSampledImages: number

    /**
     *
     */
    readonly maxDescriptorSetStorageImages: number

    /**
     *
     */
    readonly maxDescriptorSetInputAttachments: number

    /**
     *
     */
    readonly maxVertexInputAttributes: number

    /**
     *
     */
    readonly maxVertexInputBindings: number

    /**
     *
     */
    readonly maxVertexInputAttributeOffset: number

    /**
     *
     */
    readonly maxVertexInputBindingStride: number

    /**
     *
     */
    readonly maxVertexOutputComponents: number

    /**
     *
     */
    readonly maxTessellationGenerationLevel: number

    /**
     *
     */
    readonly maxTessellationPatchSize: number

    /**
     *
     */
    readonly maxTessellationControlPerVertexInputComponents: number

    /**
     *
     */
    readonly maxTessellationControlPerVertexOutputComponents: number

    /**
     *
     */
    readonly maxTessellationControlPerPatchOutputComponents: number

    /**
     *
     */
    readonly maxTessellationControlTotalOutputComponents: number

    /**
     *
     */
    readonly maxTessellationEvaluationInputComponents: number

    /**
     *
     */
    readonly maxTessellationEvaluationOutputComponents: number

    /**
     *
     */
    readonly maxGeometryShaderInvocations: number

    /**
     *
     */
    readonly maxGeometryInputComponents: number

    /**
     *
     */
    readonly maxGeometryOutputComponents: number

    /**
     *
     */
    readonly maxGeometryOutputVertices: number

    /**
     *
     */
    readonly maxGeometryTotalOutputComponents: number

    /**
     *
     */
    readonly maxFragmentInputComponents: number

    /**
     *
     */
    readonly maxFragmentOutputAttachments: number

    /**
     *
     */
    readonly maxFragmentDualSrcAttachments: number

    /**
     *
     */
    readonly maxFragmentCombinedOutputResources: number

    /**
     *
     */
    readonly maxComputeSharedMemorySize: number

    /**
     *
     */
    readonly maxComputeWorkGroupCount: number[] | null

    /**
     *
     */
    readonly maxComputeWorkGroupInvocations: number

    /**
     *
     */
    readonly maxComputeWorkGroupSize: number[] | null

    /**
     *
     */
    readonly subPixelPrecisionBits: number

    /**
     *
     */
    readonly subTexelPrecisionBits: number

    /**
     *
     */
    readonly mipmapPrecisionBits: number

    /**
     *
     */
    readonly maxDrawIndexedIndexValue: number

    /**
     *
     */
    readonly maxDrawIndirectCount: number

    /**
     *
     */
    readonly maxSamplerLodBias: number

    /**
     *
     */
    readonly maxSamplerAnisotropy: number

    /**
     *
     */
    readonly maxViewports: number

    /**
     *
     */
    readonly maxViewportDimensions: number[] | null

    /**
     *
     */
    readonly viewportBoundsRange: number[] | null

    /**
     *
     */
    readonly viewportSubPixelBits: number

    /**
     *
     */
    readonly minMemoryMapAlignment: bigint | number

    /**
     *
     */
    readonly minTexelBufferOffsetAlignment: bigint | number

    /**
     *
     */
    readonly minUniformBufferOffsetAlignment: bigint | number

    /**
     *
     */
    readonly minStorageBufferOffsetAlignment: bigint | number

    /**
     *
     */
    readonly minTexelOffset: number

    /**
     *
     */
    readonly maxTexelOffset: number

    /**
     *
     */
    readonly minTexelGatherOffset: number

    /**
     *
     */
    readonly maxTexelGatherOffset: number

    /**
     *
     */
    readonly minInterpolationOffset: number

    /**
     *
     */
    readonly maxInterpolationOffset: number

    /**
     *
     */
    readonly subPixelInterpolationOffsetBits: number

    /**
     *
     */
    readonly maxFramebufferWidth: number

    /**
     *
     */
    readonly maxFramebufferHeight: number

    /**
     *
     */
    readonly maxFramebufferLayers: number

    /**
     *
     */
    readonly framebufferColorSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly framebufferDepthSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly framebufferStencilSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly framebufferNoAttachmentsSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly maxColorAttachments: number

    /**
     *
     */
    readonly sampledImageColorSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly sampledImageIntegerSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly sampledImageDepthSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly sampledImageStencilSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly storageImageSampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly maxSampleMaskWords: number

    /**
     *
     */
    readonly timestampComputeAndGraphics: boolean

    /**
     *
     */
    readonly timestampPeriod: number

    /**
     *
     */
    readonly maxClipDistances: number

    /**
     *
     */
    readonly maxCullDistances: number

    /**
     *
     */
    readonly maxCombinedClipAndCullDistances: number

    /**
     *
     */
    readonly discreteQueuePriorities: number

    /**
     *
     */
    readonly pointSizeRange: number[] | null

    /**
     *
     */
    readonly lineWidthRange: number[] | null

    /**
     *
     */
    readonly pointSizeGranularity: number

    /**
     *
     */
    readonly lineWidthGranularity: number

    /**
     *
     */
    readonly strictLines: boolean

    /**
     *
     */
    readonly standardSampleLocations: boolean

    /**
     *
     */
    readonly optimalBufferCopyOffsetAlignment: bigint | number

    /**
     *
     */
    readonly optimalBufferCopyRowPitchAlignment: bigint | number

    /**
     *
     */
    readonly nonCoherentAtomSize: bigint | number
  }

  declare interface VkPhysicalDeviceLimitsInitializer {
    /**
     *
     */
    readonly maxImageDimension1D?: number

    /**
     *
     */
    readonly maxImageDimension2D?: number

    /**
     *
     */
    readonly maxImageDimension3D?: number

    /**
     *
     */
    readonly maxImageDimensionCube?: number

    /**
     *
     */
    readonly maxImageArrayLayers?: number

    /**
     *
     */
    readonly maxTexelBufferElements?: number

    /**
     *
     */
    readonly maxUniformBufferRange?: number

    /**
     *
     */
    readonly maxStorageBufferRange?: number

    /**
     *
     */
    readonly maxPushConstantsSize?: number

    /**
     * is the maximum number of device memory allocations, as created by 'vkAllocateMemory', which 'can' simultaneously exist.
     */
    readonly maxMemoryAllocationCount?: number

    /**
     * is the maximum number of sampler objects, as created by 'vkCreateSampler', which 'can' simultaneously exist on a device.
     */
    readonly maxSamplerAllocationCount?: number

    /**
     * is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources 'can' be bound to adjacent offsets in the same 'VkDeviceMemory' object without aliasing. See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for more details.
     */
    readonly bufferImageGranularity?: bigint | number

    /**
     * is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.
     */
    readonly sparseAddressSpaceSize?: bigint | number

    /**
     * is the maximum number of descriptor sets that 'can' be simultaneously used by a pipeline. All 'DescriptorSet' decorations in shader modules 'must' have a value less than 'maxBoundDescriptorSets'. See <<descriptorsets-sets>>.
     */
    readonly maxBoundDescriptorSets?: number

    /**
     * is the maximum number of samplers that 'can' be accessible to a single shader stage in a pipeline layout. Descriptors with a type of 'VK_DESCRIPTOR_TYPE_SAMPLER' or 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' count against this limit. Only descriptors in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT' bit set count against this limit.
     */
    readonly maxPerStageDescriptorSamplers?: number

    /**
     *
     */
    readonly maxPerStageDescriptorUniformBuffers?: number

    /**
     *
     */
    readonly maxPerStageDescriptorStorageBuffers?: number

    /**
     *
     */
    readonly maxPerStageDescriptorSampledImages?: number

    /**
     *
     */
    readonly maxPerStageDescriptorStorageImages?: number

    /**
     *
     */
    readonly maxPerStageDescriptorInputAttachments?: number

    /**
     *
     */
    readonly maxPerStageResources?: number

    /**
     *
     */
    readonly maxDescriptorSetSamplers?: number

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffers?: number

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffersDynamic?: number

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffers?: number

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffersDynamic?: number

    /**
     *
     */
    readonly maxDescriptorSetSampledImages?: number

    /**
     *
     */
    readonly maxDescriptorSetStorageImages?: number

    /**
     *
     */
    readonly maxDescriptorSetInputAttachments?: number

    /**
     *
     */
    readonly maxVertexInputAttributes?: number

    /**
     *
     */
    readonly maxVertexInputBindings?: number

    /**
     *
     */
    readonly maxVertexInputAttributeOffset?: number

    /**
     *
     */
    readonly maxVertexInputBindingStride?: number

    /**
     *
     */
    readonly maxVertexOutputComponents?: number

    /**
     *
     */
    readonly maxTessellationGenerationLevel?: number

    /**
     *
     */
    readonly maxTessellationPatchSize?: number

    /**
     *
     */
    readonly maxTessellationControlPerVertexInputComponents?: number

    /**
     *
     */
    readonly maxTessellationControlPerVertexOutputComponents?: number

    /**
     *
     */
    readonly maxTessellationControlPerPatchOutputComponents?: number

    /**
     *
     */
    readonly maxTessellationControlTotalOutputComponents?: number

    /**
     *
     */
    readonly maxTessellationEvaluationInputComponents?: number

    /**
     *
     */
    readonly maxTessellationEvaluationOutputComponents?: number

    /**
     *
     */
    readonly maxGeometryShaderInvocations?: number

    /**
     *
     */
    readonly maxGeometryInputComponents?: number

    /**
     *
     */
    readonly maxGeometryOutputComponents?: number

    /**
     *
     */
    readonly maxGeometryOutputVertices?: number

    /**
     *
     */
    readonly maxGeometryTotalOutputComponents?: number

    /**
     *
     */
    readonly maxFragmentInputComponents?: number

    /**
     *
     */
    readonly maxFragmentOutputAttachments?: number

    /**
     *
     */
    readonly maxFragmentDualSrcAttachments?: number

    /**
     *
     */
    readonly maxFragmentCombinedOutputResources?: number

    /**
     *
     */
    readonly maxComputeSharedMemorySize?: number

    /**
     *
     */
    readonly maxComputeWorkGroupCount?: number[] | null

    /**
     *
     */
    readonly maxComputeWorkGroupInvocations?: number

    /**
     *
     */
    readonly maxComputeWorkGroupSize?: number[] | null

    /**
     *
     */
    readonly subPixelPrecisionBits?: number

    /**
     *
     */
    readonly subTexelPrecisionBits?: number

    /**
     *
     */
    readonly mipmapPrecisionBits?: number

    /**
     *
     */
    readonly maxDrawIndexedIndexValue?: number

    /**
     *
     */
    readonly maxDrawIndirectCount?: number

    /**
     *
     */
    readonly maxSamplerLodBias?: number

    /**
     *
     */
    readonly maxSamplerAnisotropy?: number

    /**
     *
     */
    readonly maxViewports?: number

    /**
     *
     */
    readonly maxViewportDimensions?: number[] | null

    /**
     *
     */
    readonly viewportBoundsRange?: number[] | null

    /**
     *
     */
    readonly viewportSubPixelBits?: number

    /**
     *
     */
    readonly minMemoryMapAlignment?: bigint | number

    /**
     *
     */
    readonly minTexelBufferOffsetAlignment?: bigint | number

    /**
     *
     */
    readonly minUniformBufferOffsetAlignment?: bigint | number

    /**
     *
     */
    readonly minStorageBufferOffsetAlignment?: bigint | number

    /**
     *
     */
    readonly minTexelOffset?: number

    /**
     *
     */
    readonly maxTexelOffset?: number

    /**
     *
     */
    readonly minTexelGatherOffset?: number

    /**
     *
     */
    readonly maxTexelGatherOffset?: number

    /**
     *
     */
    readonly minInterpolationOffset?: number

    /**
     *
     */
    readonly maxInterpolationOffset?: number

    /**
     *
     */
    readonly subPixelInterpolationOffsetBits?: number

    /**
     *
     */
    readonly maxFramebufferWidth?: number

    /**
     *
     */
    readonly maxFramebufferHeight?: number

    /**
     *
     */
    readonly maxFramebufferLayers?: number

    /**
     *
     */
    readonly framebufferColorSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly framebufferDepthSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly framebufferStencilSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly framebufferNoAttachmentsSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly maxColorAttachments?: number

    /**
     *
     */
    readonly sampledImageColorSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly sampledImageIntegerSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly sampledImageDepthSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly sampledImageStencilSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly storageImageSampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly maxSampleMaskWords?: number

    /**
     *
     */
    readonly timestampComputeAndGraphics?: boolean

    /**
     *
     */
    readonly timestampPeriod?: number

    /**
     *
     */
    readonly maxClipDistances?: number

    /**
     *
     */
    readonly maxCullDistances?: number

    /**
     *
     */
    readonly maxCombinedClipAndCullDistances?: number

    /**
     *
     */
    readonly discreteQueuePriorities?: number

    /**
     *
     */
    readonly pointSizeRange?: number[] | null

    /**
     *
     */
    readonly lineWidthRange?: number[] | null

    /**
     *
     */
    readonly pointSizeGranularity?: number

    /**
     *
     */
    readonly lineWidthGranularity?: number

    /**
     *
     */
    readonly strictLines?: boolean

    /**
     *
     */
    readonly standardSampleLocations?: boolean

    /**
     *
     */
    readonly optimalBufferCopyOffsetAlignment?: bigint | number

    /**
     *
     */
    readonly optimalBufferCopyRowPitchAlignment?: bigint | number

    /**
     *
     */
    readonly nonCoherentAtomSize?: bigint | number
  }

  declare interface VkPhysicalDeviceLimitsConstructor {
    readonly prototype: VkPhysicalDeviceLimits
    new (
      param?: VkPhysicalDeviceLimitsInitializer | null
    ): VkPhysicalDeviceLimits

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceLimits: VkPhysicalDeviceLimitsConstructor

  /**
   * Structure specifying physical device sparse memory properties
   */
  interface VkPhysicalDeviceSparseProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly residencyStandard2DBlockShape: boolean

    /**
     *
     */
    readonly residencyStandard2DMultisampleBlockShape: boolean

    /**
     *
     */
    readonly residencyStandard3DBlockShape: boolean

    /**
     *
     */
    readonly residencyAlignedMipSize: boolean

    /**
     * specifies whether the physical device 'can' consistently access non-resident regions of a resource. If this property is 'VK_TRUE', access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.
     */
    readonly residencyNonResidentStrict: boolean
  }

  declare interface VkPhysicalDeviceSparsePropertiesInitializer {
    /**
     *
     */
    readonly residencyStandard2DBlockShape?: boolean

    /**
     *
     */
    readonly residencyStandard2DMultisampleBlockShape?: boolean

    /**
     *
     */
    readonly residencyStandard3DBlockShape?: boolean

    /**
     *
     */
    readonly residencyAlignedMipSize?: boolean

    /**
     * specifies whether the physical device 'can' consistently access non-resident regions of a resource. If this property is 'VK_TRUE', access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.
     */
    readonly residencyNonResidentStrict?: boolean
  }

  declare interface VkPhysicalDeviceSparsePropertiesConstructor {
    readonly prototype: VkPhysicalDeviceSparseProperties
    new (
      param?: VkPhysicalDeviceSparsePropertiesInitializer | null
    ): VkPhysicalDeviceSparseProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceSparseProperties: VkPhysicalDeviceSparsePropertiesConstructor

  /**
   * Structure describing the fine-grained features that can be supported by an implementation
   */
  interface VkPhysicalDeviceFeatures {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by 'VkDescriptorBufferInfo'::'range', 'VkBufferViewCreateInfo'::'range', or the size of the buffer). Out of bounds accesses 'must' not cause application termination, and the effects of shader loads, stores, and atomics 'must' conform to an implementation-dependent behavior as described below.
     */
    robustBufferAccess: boolean

    /**
     *
     */
    fullDrawIndexUint32: boolean

    /**
     *
     */
    imageCubeArray: boolean

    /**
     *
     */
    independentBlend: boolean

    /**
     *
     */
    geometryShader: boolean

    /**
     *
     */
    tessellationShader: boolean

    /**
     *
     */
    sampleRateShading: boolean

    /**
     *
     */
    dualSrcBlend: boolean

    /**
     *
     */
    logicOp: boolean

    /**
     *
     */
    multiDrawIndirect: boolean

    /**
     *
     */
    drawIndirectFirstInstance: boolean

    /**
     *
     */
    depthClamp: boolean

    /**
     *
     */
    depthBiasClamp: boolean

    /**
     *
     */
    fillModeNonSolid: boolean

    /**
     *
     */
    depthBounds: boolean

    /**
     *
     */
    wideLines: boolean

    /**
     *
     */
    largePoints: boolean

    /**
     *
     */
    alphaToOne: boolean

    /**
     *
     */
    multiViewport: boolean

    /**
     *
     */
    samplerAnisotropy: boolean

    /**
     *
     */
    textureCompressionETC2: boolean

    /**
     *
     */
    textureCompressionASTC_LDR: boolean

    /**
     *
     */
    textureCompressionBC: boolean

    /**
     *
     */
    occlusionQueryPrecise: boolean

    /**
     *
     */
    pipelineStatisticsQuery: boolean

    /**
     *
     */
    vertexPipelineStoresAndAtomics: boolean

    /**
     *
     */
    fragmentStoresAndAtomics: boolean

    /**
     *
     */
    shaderTessellationAndGeometryPointSize: boolean

    /**
     *
     */
    shaderImageGatherExtended: boolean

    /**
     *
     */
    shaderStorageImageExtendedFormats: boolean

    /**
     *
     */
    shaderStorageImageMultisample: boolean

    /**
     *
     */
    shaderStorageImageReadWithoutFormat: boolean

    /**
     *
     */
    shaderStorageImageWriteWithoutFormat: boolean

    /**
     *
     */
    shaderUniformBufferArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderSampledImageArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderStorageBufferArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderStorageImageArrayDynamicIndexing: boolean

    /**
     *
     */
    shaderClipDistance: boolean

    /**
     *
     */
    shaderCullDistance: boolean

    /**
     *
     */
    shaderFloat64: boolean

    /**
     *
     */
    shaderInt64: boolean

    /**
     *
     */
    shaderInt16: boolean

    /**
     *
     */
    shaderResourceResidency: boolean

    /**
     *
     */
    shaderResourceMinLod: boolean

    /**
     *
     */
    sparseBinding: boolean

    /**
     *
     */
    sparseResidencyBuffer: boolean

    /**
     *
     */
    sparseResidencyImage2D: boolean

    /**
     *
     */
    sparseResidencyImage3D: boolean

    /**
     *
     */
    sparseResidency2Samples: boolean

    /**
     *
     */
    sparseResidency4Samples: boolean

    /**
     *
     */
    sparseResidency8Samples: boolean

    /**
     *
     */
    sparseResidency16Samples: boolean

    /**
     *
     */
    sparseResidencyAliased: boolean

    /**
     *
     */
    variableMultisampleRate: boolean

    /**
     *
     */
    inheritedQueries: boolean
  }

  declare interface VkPhysicalDeviceFeaturesInitializer {
    /**
     * specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by 'VkDescriptorBufferInfo'::'range', 'VkBufferViewCreateInfo'::'range', or the size of the buffer). Out of bounds accesses 'must' not cause application termination, and the effects of shader loads, stores, and atomics 'must' conform to an implementation-dependent behavior as described below.
     */
    robustBufferAccess?: boolean

    /**
     *
     */
    fullDrawIndexUint32?: boolean

    /**
     *
     */
    imageCubeArray?: boolean

    /**
     *
     */
    independentBlend?: boolean

    /**
     *
     */
    geometryShader?: boolean

    /**
     *
     */
    tessellationShader?: boolean

    /**
     *
     */
    sampleRateShading?: boolean

    /**
     *
     */
    dualSrcBlend?: boolean

    /**
     *
     */
    logicOp?: boolean

    /**
     *
     */
    multiDrawIndirect?: boolean

    /**
     *
     */
    drawIndirectFirstInstance?: boolean

    /**
     *
     */
    depthClamp?: boolean

    /**
     *
     */
    depthBiasClamp?: boolean

    /**
     *
     */
    fillModeNonSolid?: boolean

    /**
     *
     */
    depthBounds?: boolean

    /**
     *
     */
    wideLines?: boolean

    /**
     *
     */
    largePoints?: boolean

    /**
     *
     */
    alphaToOne?: boolean

    /**
     *
     */
    multiViewport?: boolean

    /**
     *
     */
    samplerAnisotropy?: boolean

    /**
     *
     */
    textureCompressionETC2?: boolean

    /**
     *
     */
    textureCompressionASTC_LDR?: boolean

    /**
     *
     */
    textureCompressionBC?: boolean

    /**
     *
     */
    occlusionQueryPrecise?: boolean

    /**
     *
     */
    pipelineStatisticsQuery?: boolean

    /**
     *
     */
    vertexPipelineStoresAndAtomics?: boolean

    /**
     *
     */
    fragmentStoresAndAtomics?: boolean

    /**
     *
     */
    shaderTessellationAndGeometryPointSize?: boolean

    /**
     *
     */
    shaderImageGatherExtended?: boolean

    /**
     *
     */
    shaderStorageImageExtendedFormats?: boolean

    /**
     *
     */
    shaderStorageImageMultisample?: boolean

    /**
     *
     */
    shaderStorageImageReadWithoutFormat?: boolean

    /**
     *
     */
    shaderStorageImageWriteWithoutFormat?: boolean

    /**
     *
     */
    shaderUniformBufferArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderSampledImageArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderStorageBufferArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderStorageImageArrayDynamicIndexing?: boolean

    /**
     *
     */
    shaderClipDistance?: boolean

    /**
     *
     */
    shaderCullDistance?: boolean

    /**
     *
     */
    shaderFloat64?: boolean

    /**
     *
     */
    shaderInt64?: boolean

    /**
     *
     */
    shaderInt16?: boolean

    /**
     *
     */
    shaderResourceResidency?: boolean

    /**
     *
     */
    shaderResourceMinLod?: boolean

    /**
     *
     */
    sparseBinding?: boolean

    /**
     *
     */
    sparseResidencyBuffer?: boolean

    /**
     *
     */
    sparseResidencyImage2D?: boolean

    /**
     *
     */
    sparseResidencyImage3D?: boolean

    /**
     *
     */
    sparseResidency2Samples?: boolean

    /**
     *
     */
    sparseResidency4Samples?: boolean

    /**
     *
     */
    sparseResidency8Samples?: boolean

    /**
     *
     */
    sparseResidency16Samples?: boolean

    /**
     *
     */
    sparseResidencyAliased?: boolean

    /**
     *
     */
    variableMultisampleRate?: boolean

    /**
     *
     */
    inheritedQueries?: boolean
  }

  declare interface VkPhysicalDeviceFeaturesConstructor {
    readonly prototype: VkPhysicalDeviceFeatures
    new (
      param?: VkPhysicalDeviceFeaturesInitializer | null
    ): VkPhysicalDeviceFeatures

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceFeatures: VkPhysicalDeviceFeaturesConstructor

  /**
   * Structure specifying parameters of a newly created fence
   */
  interface VkFenceCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkFenceCreateFlagBits' specifying the initial state and behavior of the fence.
     */
    flags: VkFenceCreateFlagBits
  }

  declare interface VkFenceCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkFenceCreateFlagBits' specifying the initial state and behavior of the fence.
     */
    flags?: VkFenceCreateFlagBits
  }

  declare interface VkFenceCreateInfoConstructor {
    readonly prototype: VkFenceCreateInfo
    new (param?: VkFenceCreateInfoInitializer | null): VkFenceCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFenceCreateInfo: VkFenceCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created event
   */
  interface VkEventCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number
  }

  declare interface VkEventCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number
  }

  declare interface VkEventCreateInfoConstructor {
    readonly prototype: VkEventCreateInfo
    new (param?: VkEventCreateInfoInitializer | null): VkEventCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkEventCreateInfo: VkEventCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created render pass
   */
  interface VkRenderPassCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: VkRenderPassCreateFlagBits

    /**
     * 'VkAttachmentDescription' structures describing the attachments used by the render pass.
     */
    attachmentCount: number

    /**
     *
     */
    pAttachments: VkAttachmentDescription[] | null

    /**
     * 'VkSubpassDescription' structures describing each subpass.
     */
    subpassCount: number

    /**
     *
     */
    pSubpasses: VkSubpassDescription[] | null

    /**
     * 'VkSubpassDependency' structures describing dependencies between pairs of subpasses.
     */
    dependencyCount: number

    /**
     *
     */
    pDependencies: VkSubpassDependency[] | null
  }

  declare interface VkRenderPassCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: VkRenderPassCreateFlagBits

    /**
     * 'VkAttachmentDescription' structures describing the attachments used by the render pass.
     */
    attachmentCount?: number

    /**
     *
     */
    pAttachments?: VkAttachmentDescription[] | null

    /**
     * 'VkSubpassDescription' structures describing each subpass.
     */
    subpassCount?: number

    /**
     *
     */
    pSubpasses?: VkSubpassDescription[] | null

    /**
     * 'VkSubpassDependency' structures describing dependencies between pairs of subpasses.
     */
    dependencyCount?: number

    /**
     *
     */
    pDependencies?: VkSubpassDependency[] | null
  }

  declare interface VkRenderPassCreateInfoConstructor {
    readonly prototype: VkRenderPassCreateInfo
    new (
      param?: VkRenderPassCreateInfoInitializer | null
    ): VkRenderPassCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassCreateInfo: VkRenderPassCreateInfoConstructor

  /**
   * Structure specifying a subpass dependency
   */
  interface VkSubpassDependency {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the subpass index of the first subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    srcSubpass: number

    /**
     * is the subpass index of the second subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    dstSubpass: number

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
     */
    srcStageMask: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>
     */
    dstStageMask: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkDependencyFlagBits'.
     */
    dependencyFlags: VkDependencyFlagBits
  }

  declare interface VkSubpassDependencyInitializer {
    /**
     * is the subpass index of the first subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    srcSubpass?: number

    /**
     * is the subpass index of the second subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    dstSubpass?: number

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
     */
    srcStageMask?: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>
     */
    dstStageMask?: VkPipelineStageFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkDependencyFlagBits'.
     */
    dependencyFlags?: VkDependencyFlagBits
  }

  declare interface VkSubpassDependencyConstructor {
    readonly prototype: VkSubpassDependency
    new (param?: VkSubpassDependencyInitializer | null): VkSubpassDependency

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassDependency: VkSubpassDependencyConstructor

  /**
   * Structure specifying a subpass description
   */
  interface VkSubpassDescription {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkSubpassDescriptionFlagBits' specifying usage of the subpass.
     */
    flags: VkSubpassDescriptionFlagBits

    /**
     * is a 'VkPipelineBindPoint' value specifying the pipeline type supported for this subpass.
     */
    pipelineBindPoint: VkPipelineBindPoint

    /**
     * is the number of input attachments.
     */
    inputAttachmentCount: number

    /**
     * is an array of 'VkAttachmentReference' structures defining the input attachments for this subpass and their layouts.
     */
    pInputAttachments: VkAttachmentReference[] | null

    /**
     * is the number of color attachments.
     */
    colorAttachmentCount: number

    /**
     * is an array of 'VkAttachmentReference' structures defining the color attachments for this subpass and their layouts.
     */
    pColorAttachments: VkAttachmentReference[] | null

    /**
     * is an optional array of 'colorAttachmentCount' 'VkAttachmentReference' structures defining the resolve attachments for this subpass and their layouts.
     */
    pResolveAttachments: VkAttachmentReference[] | null

    /**
     * is a reference to a 'VkAttachmentReference' structure specifying the depth/stencil attachment for this subpass and its layout.
     */
    pDepthStencilAttachment: VkAttachmentReference | null

    /**
     * is the number of preserved attachments.
     */
    preserveAttachmentCount: number

    /**
     * is an array of 'preserveAttachmentCount' render pass attachment indices identifying attachments that are not used by this subpass, but whose contents 'must' be preserved throughout the subpass.
     */
    pPreserveAttachments: Uint32Array | null
  }

  declare interface VkSubpassDescriptionInitializer {
    /**
     * is a bitmask of 'VkSubpassDescriptionFlagBits' specifying usage of the subpass.
     */
    flags?: VkSubpassDescriptionFlagBits

    /**
     * is a 'VkPipelineBindPoint' value specifying the pipeline type supported for this subpass.
     */
    pipelineBindPoint?: VkPipelineBindPoint

    /**
     * is the number of input attachments.
     */
    inputAttachmentCount?: number

    /**
     * is an array of 'VkAttachmentReference' structures defining the input attachments for this subpass and their layouts.
     */
    pInputAttachments?: VkAttachmentReference[] | null

    /**
     * is the number of color attachments.
     */
    colorAttachmentCount?: number

    /**
     * is an array of 'VkAttachmentReference' structures defining the color attachments for this subpass and their layouts.
     */
    pColorAttachments?: VkAttachmentReference[] | null

    /**
     * is an optional array of 'colorAttachmentCount' 'VkAttachmentReference' structures defining the resolve attachments for this subpass and their layouts.
     */
    pResolveAttachments?: VkAttachmentReference[] | null

    /**
     * is a reference to a 'VkAttachmentReference' structure specifying the depth/stencil attachment for this subpass and its layout.
     */
    pDepthStencilAttachment?: VkAttachmentReference | null

    /**
     * is the number of preserved attachments.
     */
    preserveAttachmentCount?: number

    /**
     * is an array of 'preserveAttachmentCount' render pass attachment indices identifying attachments that are not used by this subpass, but whose contents 'must' be preserved throughout the subpass.
     */
    pPreserveAttachments?: Uint32Array | null
  }

  declare interface VkSubpassDescriptionConstructor {
    readonly prototype: VkSubpassDescription
    new (param?: VkSubpassDescriptionInitializer | null): VkSubpassDescription

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubpassDescription: VkSubpassDescriptionConstructor

  /**
   * Structure specifying an attachment reference
   */
  interface VkAttachmentReference {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is either a number value identifying an attachment at the corresponding index in 'VkRenderPassCreateInfo'::'pAttachments', or 'VK_ATTACHMENT_UNUSED' to signify that this attachment is not used.
     */
    attachment: number

    /**
     * is a 'VkImageLayout' value specifying the layout the attachment uses during the subpass.
     */
    layout: VkImageLayout
  }

  declare interface VkAttachmentReferenceInitializer {
    /**
     * is either a number value identifying an attachment at the corresponding index in 'VkRenderPassCreateInfo'::'pAttachments', or 'VK_ATTACHMENT_UNUSED' to signify that this attachment is not used.
     */
    attachment?: number

    /**
     * is a 'VkImageLayout' value specifying the layout the attachment uses during the subpass.
     */
    layout?: VkImageLayout
  }

  declare interface VkAttachmentReferenceConstructor {
    readonly prototype: VkAttachmentReference
    new (param?: VkAttachmentReferenceInitializer | null): VkAttachmentReference

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAttachmentReference: VkAttachmentReferenceConstructor

  /**
   * Structure specifying an attachment description
   */
  interface VkAttachmentDescription {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkAttachmentDescriptionFlagBits' specifying additional properties of the attachment.
     */
    flags: VkAttachmentDescriptionFlagBits

    /**
     * is a 'VkFormat' value specifying the format of the image view that will be used for the attachment.
     */
    format: VkFormat

    /**
     * is the number of samples of the image as defined in 'VkSampleCountFlagBits'.
     */
    samples: VkSampleCountFlagBits

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    loadOp: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
     */
    storeOp: VkAttachmentStoreOp

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    stencilLoadOp: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
     */
    stencilStoreOp: VkAttachmentStoreOp

    /**
     * is the layout the attachment image subresource will be in when a render pass instance begins.
     */
    initialLayout: VkImageLayout

    /**
     * is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
     */
    finalLayout: VkImageLayout
  }

  declare interface VkAttachmentDescriptionInitializer {
    /**
     * is a bitmask of 'VkAttachmentDescriptionFlagBits' specifying additional properties of the attachment.
     */
    flags?: VkAttachmentDescriptionFlagBits

    /**
     * is a 'VkFormat' value specifying the format of the image view that will be used for the attachment.
     */
    format?: VkFormat

    /**
     * is the number of samples of the image as defined in 'VkSampleCountFlagBits'.
     */
    samples?: VkSampleCountFlagBits

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    loadOp?: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
     */
    storeOp?: VkAttachmentStoreOp

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    stencilLoadOp?: VkAttachmentLoadOp

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
     */
    stencilStoreOp?: VkAttachmentStoreOp

    /**
     * is the layout the attachment image subresource will be in when a render pass instance begins.
     */
    initialLayout?: VkImageLayout

    /**
     * is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
     */
    finalLayout?: VkImageLayout
  }

  declare interface VkAttachmentDescriptionConstructor {
    readonly prototype: VkAttachmentDescription
    new (
      param?: VkAttachmentDescriptionInitializer | null
    ): VkAttachmentDescription

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAttachmentDescription: VkAttachmentDescriptionConstructor

  /**
   * Structure specifying a clear attachment
   */
  interface VkClearAttachment {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared.
     */
    aspectMask: VkImageAspectFlagBits

    /**
     * is only meaningful if 'VK_IMAGE_ASPECT_COLOR_BIT' is set in 'aspectMask', in which case it is an index to the 'pColorAttachments' array in the 'VkSubpassDescription' structure of the current subpass which selects the color attachment to clear.
     */
    colorAttachment: number

    /**
     * is the color or depth/stencil value to clear the attachment to, as described in <<clears-values,Clear Values>> below.
     */
    clearValue: VkClearValue | null
  }

  declare interface VkClearAttachmentInitializer {
    /**
     * is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared.
     */
    aspectMask?: VkImageAspectFlagBits

    /**
     * is only meaningful if 'VK_IMAGE_ASPECT_COLOR_BIT' is set in 'aspectMask', in which case it is an index to the 'pColorAttachments' array in the 'VkSubpassDescription' structure of the current subpass which selects the color attachment to clear.
     */
    colorAttachment?: number

    /**
     * is the color or depth/stencil value to clear the attachment to, as described in <<clears-values,Clear Values>> below.
     */
    clearValue?: VkClearValue | null
  }

  declare interface VkClearAttachmentConstructor {
    readonly prototype: VkClearAttachment
    new (param?: VkClearAttachmentInitializer | null): VkClearAttachment

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkClearAttachment: VkClearAttachmentConstructor

  /**
   * Structure specifying a clear depth stencil value
   */
  interface VkClearDepthStencilValue {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.
     */
    depth: number

    /**
     * is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.
     */
    stencil: number
  }

  declare interface VkClearDepthStencilValueInitializer {
    /**
     * is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.
     */
    depth?: number

    /**
     * is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.
     */
    stencil?: number
  }

  declare interface VkClearDepthStencilValueConstructor {
    readonly prototype: VkClearDepthStencilValue
    new (
      param?: VkClearDepthStencilValueInitializer | null
    ): VkClearDepthStencilValue

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkClearDepthStencilValue: VkClearDepthStencilValueConstructor

  /**
   * Structure specifying render pass begin info
   */
  interface VkRenderPassBeginInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the render pass to begin an instance of.
     */
    renderPass: VkRenderPass | null

    /**
     * is the framebuffer containing the attachments that are used with the render pass.
     */
    framebuffer: VkFramebuffer | null

    /**
     * is the render area that is affected by the render pass instance, and is described in more detail below.
     */
    renderArea: VkRect2D | null

    /**
     * 'VkClearValue' structures that contains clear values for each attachment, if the attachment uses a 'loadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR' or if the attachment has a depth/stencil format and uses a 'stencilLoadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR'. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of 'pClearValues' are ignored.
     */
    clearValueCount: number

    /**
     *
     */
    pClearValues: VkClearValue[] | null
  }

  declare interface VkRenderPassBeginInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the render pass to begin an instance of.
     */
    renderPass?: VkRenderPass | null

    /**
     * is the framebuffer containing the attachments that are used with the render pass.
     */
    framebuffer?: VkFramebuffer | null

    /**
     * is the render area that is affected by the render pass instance, and is described in more detail below.
     */
    renderArea?: VkRect2D | null

    /**
     * 'VkClearValue' structures that contains clear values for each attachment, if the attachment uses a 'loadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR' or if the attachment has a depth/stencil format and uses a 'stencilLoadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR'. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of 'pClearValues' are ignored.
     */
    clearValueCount?: number

    /**
     *
     */
    pClearValues?: VkClearValue[] | null
  }

  declare interface VkRenderPassBeginInfoConstructor {
    readonly prototype: VkRenderPassBeginInfo
    new (param?: VkRenderPassBeginInfoInitializer | null): VkRenderPassBeginInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRenderPassBeginInfo: VkRenderPassBeginInfoConstructor

  /**
   * Structure specifying a command buffer begin operation
   */
  interface VkCommandBufferBeginInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkCommandBufferUsageFlagBits' specifying usage behavior for the command buffer.
     */
    flags: VkCommandBufferUsageFlagBits

    /**
     * is a reference to a 'VkCommandBufferInheritanceInfo' structure, used if 'commandBuffer' is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
     */
    pInheritanceInfo: VkCommandBufferInheritanceInfo | null
  }

  declare interface VkCommandBufferBeginInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkCommandBufferUsageFlagBits' specifying usage behavior for the command buffer.
     */
    flags?: VkCommandBufferUsageFlagBits

    /**
     * is a reference to a 'VkCommandBufferInheritanceInfo' structure, used if 'commandBuffer' is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
     */
    pInheritanceInfo?: VkCommandBufferInheritanceInfo | null
  }

  declare interface VkCommandBufferBeginInfoConstructor {
    readonly prototype: VkCommandBufferBeginInfo
    new (
      param?: VkCommandBufferBeginInfoInitializer | null
    ): VkCommandBufferBeginInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCommandBufferBeginInfo: VkCommandBufferBeginInfoConstructor

  /**
   * Structure specifying command buffer inheritance info
   */
  interface VkCommandBufferInheritanceInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a 'VkRenderPass' object defining which render passes the 'VkCommandBuffer' will be <<renderpass-compatibility, compatible>> with and 'can' be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'renderPass' is ignored.
     */
    renderPass: VkRenderPass | null

    /**
     * is the index of the subpass within the render pass instance that the 'VkCommandBuffer' will be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'subpass' is ignored.
     */
    subpass: number

    /**
     * optionally refers to the 'VkFramebuffer' object that the 'VkCommandBuffer' will be rendering to if it is executed within a render pass instance. It 'can' be 'VK_NULL_HANDLE' if the framebuffer is not known, or if the 'VkCommandBuffer' will not be executed within a render pass instance.+[NOTE].Note====Specifying the exact framebuffer that the secondary command buffer will beexecuted with 'may' result in better performance at command buffer executiontime.====
     */
    framebuffer: VkFramebuffer | null

    /**
     * specifies whether the command buffer 'can' be executed while an occlusion query is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has an occlusion query active or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have an occlusion query active.
     */
    occlusionQueryEnable: boolean

    /**
     * specifies the query flags that 'can' be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the 'VK_QUERY_CONTROL_PRECISE_BIT' bit, then the active query 'can' return boolean results or actual sample counts. If this bit is not set, then the active query 'must' not use the 'VK_QUERY_CONTROL_PRECISE_BIT' bit.
     */
    queryFlags: VkQueryControlFlagBits

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying the set of pipeline statistics that 'can' be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer 'can' be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query 'must' not be from a query pool that counts that statistic.
     */
    pipelineStatistics: VkQueryPipelineStatisticFlagBits
  }

  declare interface VkCommandBufferInheritanceInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a 'VkRenderPass' object defining which render passes the 'VkCommandBuffer' will be <<renderpass-compatibility, compatible>> with and 'can' be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'renderPass' is ignored.
     */
    renderPass?: VkRenderPass | null

    /**
     * is the index of the subpass within the render pass instance that the 'VkCommandBuffer' will be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'subpass' is ignored.
     */
    subpass?: number

    /**
     * optionally refers to the 'VkFramebuffer' object that the 'VkCommandBuffer' will be rendering to if it is executed within a render pass instance. It 'can' be 'VK_NULL_HANDLE' if the framebuffer is not known, or if the 'VkCommandBuffer' will not be executed within a render pass instance.+[NOTE].Note====Specifying the exact framebuffer that the secondary command buffer will beexecuted with 'may' result in better performance at command buffer executiontime.====
     */
    framebuffer?: VkFramebuffer | null

    /**
     * specifies whether the command buffer 'can' be executed while an occlusion query is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has an occlusion query active or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have an occlusion query active.
     */
    occlusionQueryEnable?: boolean

    /**
     * specifies the query flags that 'can' be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the 'VK_QUERY_CONTROL_PRECISE_BIT' bit, then the active query 'can' return boolean results or actual sample counts. If this bit is not set, then the active query 'must' not use the 'VK_QUERY_CONTROL_PRECISE_BIT' bit.
     */
    queryFlags?: VkQueryControlFlagBits

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying the set of pipeline statistics that 'can' be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer 'can' be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query 'must' not be from a query pool that counts that statistic.
     */
    pipelineStatistics?: VkQueryPipelineStatisticFlagBits
  }

  declare interface VkCommandBufferInheritanceInfoConstructor {
    readonly prototype: VkCommandBufferInheritanceInfo
    new (
      param?: VkCommandBufferInheritanceInfoInitializer | null
    ): VkCommandBufferInheritanceInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCommandBufferInheritanceInfo: VkCommandBufferInheritanceInfoConstructor

  /**
   * Structure specifying the allocation parameters for command buffer object
   */
  interface VkCommandBufferAllocateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the command pool from which the command buffers are allocated.
     */
    commandPool: VkCommandPool | null

    /**
     * is a 'VkCommandBufferLevel' value specifying the command buffer level.
     */
    level: VkCommandBufferLevel

    /**
     * is the number of command buffers to allocate from the pool.
     */
    commandBufferCount: number
  }

  declare interface VkCommandBufferAllocateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the command pool from which the command buffers are allocated.
     */
    commandPool?: VkCommandPool | null

    /**
     * is a 'VkCommandBufferLevel' value specifying the command buffer level.
     */
    level?: VkCommandBufferLevel

    /**
     * is the number of command buffers to allocate from the pool.
     */
    commandBufferCount?: number
  }

  declare interface VkCommandBufferAllocateInfoConstructor {
    readonly prototype: VkCommandBufferAllocateInfo
    new (
      param?: VkCommandBufferAllocateInfoInitializer | null
    ): VkCommandBufferAllocateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCommandBufferAllocateInfo: VkCommandBufferAllocateInfoConstructor

  /**
   * Structure specifying parameters of a newly created command pool
   */
  interface VkCommandPoolCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkCommandPoolCreateFlagBits' indicating usage behavior for the pool and command buffers allocated from it.
     */
    flags: VkCommandPoolCreateFlagBits

    /**
     * designates a queue family as described in section <<devsandqueues-queueprops,Queue Family Properties>>. All command buffers allocated from this command pool 'must' be submitted on queues from the same queue family.
     */
    queueFamilyIndex: number
  }

  declare interface VkCommandPoolCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkCommandPoolCreateFlagBits' indicating usage behavior for the pool and command buffers allocated from it.
     */
    flags?: VkCommandPoolCreateFlagBits

    /**
     * designates a queue family as described in section <<devsandqueues-queueprops,Queue Family Properties>>. All command buffers allocated from this command pool 'must' be submitted on queues from the same queue family.
     */
    queueFamilyIndex?: number
  }

  declare interface VkCommandPoolCreateInfoConstructor {
    readonly prototype: VkCommandPoolCreateInfo
    new (
      param?: VkCommandPoolCreateInfoInitializer | null
    ): VkCommandPoolCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCommandPoolCreateInfo: VkCommandPoolCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created sampler
   */
  interface VkSamplerCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkSamplerCreateFlagBits' describing additional parameters of the sampler.
     */
    flags: VkSamplerCreateFlagBits

    /**
     * is a 'VkFilter' value specifying the magnification filter to apply to lookups.
     */
    magFilter: VkFilter

    /**
     * is a 'VkFilter' value specifying the minification filter to apply to lookups.
     */
    minFilter: VkFilter

    /**
     * is a 'VkSamplerMipmapMode' value specifying the mipmap filter to apply to lookups.
     */
    mipmapMode: VkSamplerMipmapMode

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for U coordinate.
     */
    addressModeU: VkSamplerAddressMode

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for V coordinate.
     */
    addressModeV: VkSamplerAddressMode

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for W coordinate.
     */
    addressModeW: VkSamplerAddressMode

    /**
     * is the bias to be added to mipmap LOD (level-of-detail) calculation and bias provided by image sampling functions in SPIR-V, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    mipLodBias: number

    /**
     *
     */
    anisotropyEnable: boolean

    /**
     * is the anisotropy value clamp used by the sampler when 'anisotropyEnable' is 'VK_TRUE'. If 'anisotropyEnable' is 'VK_FALSE', 'maxAnisotropy' is ignored.
     */
    maxAnisotropy: number

    /**
     *
     */
    compareEnable: boolean

    /**
     * is a 'VkCompareOp' value specifying the comparison function to apply to fetched data before filtering as described in the <<textures-depth-compare-operation, Depth Compare Operation>> section.
     */
    compareOp: VkCompareOp

    /**
     *
     */
    minLod: number

    /**
     * are the values used to clamp the computed LOD value, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    maxLod: number

    /**
     * is a 'VkBorderColor' value specifying the predefined border color to use.
     */
    borderColor: VkBorderColor

    /**
     * controls whether to use unnormalized or normalized texel coordinates to address texels of the image. When set to 'VK_TRUE', the range of the image coordinates used to lookup the texel is in the range of zero to the image dimensions for x, y and z. When set to 'VK_FALSE' the range of image coordinates is zero to one.+When 'unnormalizedCoordinates' is 'VK_TRUE', images the sampler isused with in the shader have the following requirements:+
     */
    unnormalizedCoordinates: boolean
  }

  declare interface VkSamplerCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkSamplerCreateFlagBits' describing additional parameters of the sampler.
     */
    flags?: VkSamplerCreateFlagBits

    /**
     * is a 'VkFilter' value specifying the magnification filter to apply to lookups.
     */
    magFilter?: VkFilter

    /**
     * is a 'VkFilter' value specifying the minification filter to apply to lookups.
     */
    minFilter?: VkFilter

    /**
     * is a 'VkSamplerMipmapMode' value specifying the mipmap filter to apply to lookups.
     */
    mipmapMode?: VkSamplerMipmapMode

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for U coordinate.
     */
    addressModeU?: VkSamplerAddressMode

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for V coordinate.
     */
    addressModeV?: VkSamplerAddressMode

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for W coordinate.
     */
    addressModeW?: VkSamplerAddressMode

    /**
     * is the bias to be added to mipmap LOD (level-of-detail) calculation and bias provided by image sampling functions in SPIR-V, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    mipLodBias?: number

    /**
     *
     */
    anisotropyEnable?: boolean

    /**
     * is the anisotropy value clamp used by the sampler when 'anisotropyEnable' is 'VK_TRUE'. If 'anisotropyEnable' is 'VK_FALSE', 'maxAnisotropy' is ignored.
     */
    maxAnisotropy?: number

    /**
     *
     */
    compareEnable?: boolean

    /**
     * is a 'VkCompareOp' value specifying the comparison function to apply to fetched data before filtering as described in the <<textures-depth-compare-operation, Depth Compare Operation>> section.
     */
    compareOp?: VkCompareOp

    /**
     *
     */
    minLod?: number

    /**
     * are the values used to clamp the computed LOD value, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    maxLod?: number

    /**
     * is a 'VkBorderColor' value specifying the predefined border color to use.
     */
    borderColor?: VkBorderColor

    /**
     * controls whether to use unnormalized or normalized texel coordinates to address texels of the image. When set to 'VK_TRUE', the range of the image coordinates used to lookup the texel is in the range of zero to the image dimensions for x, y and z. When set to 'VK_FALSE' the range of image coordinates is zero to one.+When 'unnormalizedCoordinates' is 'VK_TRUE', images the sampler isused with in the shader have the following requirements:+
     */
    unnormalizedCoordinates?: boolean
  }

  declare interface VkSamplerCreateInfoConstructor {
    readonly prototype: VkSamplerCreateInfo
    new (param?: VkSamplerCreateInfoInitializer | null): VkSamplerCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSamplerCreateInfo: VkSamplerCreateInfoConstructor

  /**
   * Structure specifying the parameters of a newly created pipeline layout object
   */
  interface VkPipelineLayoutCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the number of descriptor sets included in the pipeline layout.
     */
    setLayoutCount: number

    /**
     * is an array of 'VkDescriptorSetLayout' objects.
     */
    pSetLayouts: VkDescriptorSetLayout[] | null

    /**
     * is the number of push constant ranges included in the pipeline layout.
     */
    pushConstantRangeCount: number

    /**
     * is an array of 'VkPushConstantRange' structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants 'can' be accessed by each stage of the pipeline.+[NOTE].Note====Push constants represent a high speed path to modify constant data inpipelines that is expected to outperform memory-backed resource updates.====
     */
    pPushConstantRanges: VkPushConstantRange[] | null
  }

  declare interface VkPipelineLayoutCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the number of descriptor sets included in the pipeline layout.
     */
    setLayoutCount?: number

    /**
     * is an array of 'VkDescriptorSetLayout' objects.
     */
    pSetLayouts?: VkDescriptorSetLayout[] | null

    /**
     * is the number of push constant ranges included in the pipeline layout.
     */
    pushConstantRangeCount?: number

    /**
     * is an array of 'VkPushConstantRange' structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants 'can' be accessed by each stage of the pipeline.+[NOTE].Note====Push constants represent a high speed path to modify constant data inpipelines that is expected to outperform memory-backed resource updates.====
     */
    pPushConstantRanges?: VkPushConstantRange[] | null
  }

  declare interface VkPipelineLayoutCreateInfoConstructor {
    readonly prototype: VkPipelineLayoutCreateInfo
    new (
      param?: VkPipelineLayoutCreateInfoInitializer | null
    ): VkPipelineLayoutCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineLayoutCreateInfo: VkPipelineLayoutCreateInfoConstructor

  /**
   * Structure specifying a push constant range
   */
  interface VkPushConstantRange {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will return 'undefined' values.
     */
    stageFlags: VkShaderStageFlagBits

    /**
     *
     */
    offset: number

    /**
     * are the start offset and size, respectively, consumed by the range. Both 'offset' and 'size' are in units of bytes and 'must' be a multiple of 4. The layout of the push constant variables is specified in the shader.
     */
    size: number
  }

  declare interface VkPushConstantRangeInitializer {
    /**
     * is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will return 'undefined' values.
     */
    stageFlags?: VkShaderStageFlagBits

    /**
     *
     */
    offset?: number

    /**
     * are the start offset and size, respectively, consumed by the range. Both 'offset' and 'size' are in units of bytes and 'must' be a multiple of 4. The layout of the push constant variables is specified in the shader.
     */
    size?: number
  }

  declare interface VkPushConstantRangeConstructor {
    readonly prototype: VkPushConstantRange
    new (param?: VkPushConstantRangeInitializer | null): VkPushConstantRange

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPushConstantRange: VkPushConstantRangeConstructor

  /**
   * Structure specifying parameters of a newly created pipeline cache
   */
  interface VkPipelineCacheCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     *
     */
    initialDataSize: bigint | number

    /**
     * is a reference to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If 'initialDataSize' is zero, 'pInitialData' is ignored.
     */
    pInitialData: ArrayBuffer | null
  }

  declare interface VkPipelineCacheCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     *
     */
    initialDataSize?: bigint | number

    /**
     * is a reference to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If 'initialDataSize' is zero, 'pInitialData' is ignored.
     */
    pInitialData?: ArrayBuffer | null
  }

  declare interface VkPipelineCacheCreateInfoConstructor {
    readonly prototype: VkPipelineCacheCreateInfo
    new (
      param?: VkPipelineCacheCreateInfoInitializer | null
    ): VkPipelineCacheCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineCacheCreateInfo: VkPipelineCacheCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created graphics pipeline
   */
  interface VkGraphicsPipelineCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the graphics pipeline.
     */
    stageCount: number

    /**
     * array.
     */
    pStages: VkPipelineShaderStageCreateInfo[] | null

    /**
     * is a reference to a 'VkPipelineVertexInputStateCreateInfo' structure. It is ignored if the pipeline includes a mesh shader stage.
     */
    pVertexInputState: VkPipelineVertexInputStateCreateInfo | null

    /**
     *
     */
    pInputAssemblyState: VkPipelineInputAssemblyStateCreateInfo | null

    /**
     *
     */
    pTessellationState: VkPipelineTessellationStateCreateInfo | null

    /**
     *
     */
    pViewportState: VkPipelineViewportStateCreateInfo | null

    /**
     *
     */
    pRasterizationState: VkPipelineRasterizationStateCreateInfo | null

    /**
     *
     */
    pMultisampleState: VkPipelineMultisampleStateCreateInfo | null

    /**
     *
     */
    pDepthStencilState: VkPipelineDepthStencilStateCreateInfo | null

    /**
     *
     */
    pColorBlendState: VkPipelineColorBlendStateCreateInfo | null

    /**
     *
     */
    pDynamicState: VkPipelineDynamicStateCreateInfo | null

    /**
     *
     */
    layout: VkPipelineLayout | null

    /**
     *
     */
    renderPass: VkRenderPass | null

    /**
     *
     */
    subpass: number

    /**
     *
     */
    basePipelineHandle: VkPipeline | null

    /**
     *
     */
    basePipelineIndex: number
  }

  declare interface VkGraphicsPipelineCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the graphics pipeline.
     */
    stageCount?: number

    /**
     * array.
     */
    pStages?: VkPipelineShaderStageCreateInfo[] | null

    /**
     * is a reference to a 'VkPipelineVertexInputStateCreateInfo' structure. It is ignored if the pipeline includes a mesh shader stage.
     */
    pVertexInputState?: VkPipelineVertexInputStateCreateInfo | null

    /**
     *
     */
    pInputAssemblyState?: VkPipelineInputAssemblyStateCreateInfo | null

    /**
     *
     */
    pTessellationState?: VkPipelineTessellationStateCreateInfo | null

    /**
     *
     */
    pViewportState?: VkPipelineViewportStateCreateInfo | null

    /**
     *
     */
    pRasterizationState?: VkPipelineRasterizationStateCreateInfo | null

    /**
     *
     */
    pMultisampleState?: VkPipelineMultisampleStateCreateInfo | null

    /**
     *
     */
    pDepthStencilState?: VkPipelineDepthStencilStateCreateInfo | null

    /**
     *
     */
    pColorBlendState?: VkPipelineColorBlendStateCreateInfo | null

    /**
     *
     */
    pDynamicState?: VkPipelineDynamicStateCreateInfo | null

    /**
     *
     */
    layout?: VkPipelineLayout | null

    /**
     *
     */
    renderPass?: VkRenderPass | null

    /**
     *
     */
    subpass?: number

    /**
     *
     */
    basePipelineHandle?: VkPipeline | null

    /**
     *
     */
    basePipelineIndex?: number
  }

  declare interface VkGraphicsPipelineCreateInfoConstructor {
    readonly prototype: VkGraphicsPipelineCreateInfo
    new (
      param?: VkGraphicsPipelineCreateInfoInitializer | null
    ): VkGraphicsPipelineCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkGraphicsPipelineCreateInfo: VkGraphicsPipelineCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline depth stencil state
   */
  interface VkPipelineDepthStencilStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * controls whether <<fragops-depth,depth testing>> is enabled.
     */
    depthTestEnable: boolean

    /**
     * controls whether <<fragops-depth-write,depth writes>> are enabled when 'depthTestEnable' is 'VK_TRUE'. Depth writes are always disabled when 'depthTestEnable' is 'VK_FALSE'.
     */
    depthWriteEnable: boolean

    /**
     * is the comparison operator used in the <<fragops-depth,depth test>>.
     */
    depthCompareOp: VkCompareOp

    /**
     * controls whether <<fragops-dbt,depth bounds testing>> is enabled.
     */
    depthBoundsTestEnable: boolean

    /**
     * controls whether <<fragops-stencil,stencil testing>> is enabled.
     */
    stencilTestEnable: boolean

    /**
     *
     */
    front: VkStencilOpState | null

    /**
     * control the parameters of the <<fragops-stencil,stencil test>>.
     */
    back: VkStencilOpState | null

    /**
     *
     */
    minDepthBounds: number

    /**
     * define the range of values used in the <<fragops-dbt,depth bounds test>>.
     */
    maxDepthBounds: number
  }

  declare interface VkPipelineDepthStencilStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * controls whether <<fragops-depth,depth testing>> is enabled.
     */
    depthTestEnable?: boolean

    /**
     * controls whether <<fragops-depth-write,depth writes>> are enabled when 'depthTestEnable' is 'VK_TRUE'. Depth writes are always disabled when 'depthTestEnable' is 'VK_FALSE'.
     */
    depthWriteEnable?: boolean

    /**
     * is the comparison operator used in the <<fragops-depth,depth test>>.
     */
    depthCompareOp?: VkCompareOp

    /**
     * controls whether <<fragops-dbt,depth bounds testing>> is enabled.
     */
    depthBoundsTestEnable?: boolean

    /**
     * controls whether <<fragops-stencil,stencil testing>> is enabled.
     */
    stencilTestEnable?: boolean

    /**
     *
     */
    front?: VkStencilOpState | null

    /**
     * control the parameters of the <<fragops-stencil,stencil test>>.
     */
    back?: VkStencilOpState | null

    /**
     *
     */
    minDepthBounds?: number

    /**
     * define the range of values used in the <<fragops-dbt,depth bounds test>>.
     */
    maxDepthBounds?: number
  }

  declare interface VkPipelineDepthStencilStateCreateInfoConstructor {
    readonly prototype: VkPipelineDepthStencilStateCreateInfo
    new (
      param?: VkPipelineDepthStencilStateCreateInfoInitializer | null
    ): VkPipelineDepthStencilStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineDepthStencilStateCreateInfo: VkPipelineDepthStencilStateCreateInfoConstructor

  /**
   * Structure specifying stencil operation state
   */
  interface VkStencilOpState {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that fail the stencil test.
     */
    failOp: VkStencilOp

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass both the depth and stencil tests.
     */
    passOp: VkStencilOp

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass the stencil test and fail the depth test.
     */
    depthFailOp: VkStencilOp

    /**
     * is a 'VkCompareOp' value specifying the comparison operator used in the stencil test.
     */
    compareOp: VkCompareOp

    /**
     * selects the bits of the unsigned integer stencil values participating in the stencil test.
     */
    compareMask: number

    /**
     * selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.
     */
    writeMask: number

    /**
     * is a number reference value that is used in the unsigned stencil comparison.
     */
    reference: number
  }

  declare interface VkStencilOpStateInitializer {
    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that fail the stencil test.
     */
    failOp?: VkStencilOp

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass both the depth and stencil tests.
     */
    passOp?: VkStencilOp

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass the stencil test and fail the depth test.
     */
    depthFailOp?: VkStencilOp

    /**
     * is a 'VkCompareOp' value specifying the comparison operator used in the stencil test.
     */
    compareOp?: VkCompareOp

    /**
     * selects the bits of the unsigned integer stencil values participating in the stencil test.
     */
    compareMask?: number

    /**
     * selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.
     */
    writeMask?: number

    /**
     * is a number reference value that is used in the unsigned stencil comparison.
     */
    reference?: number
  }

  declare interface VkStencilOpStateConstructor {
    readonly prototype: VkStencilOpState
    new (param?: VkStencilOpStateInitializer | null): VkStencilOpState

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkStencilOpState: VkStencilOpStateConstructor

  /**
   * Structure specifying parameters of a newly created pipeline dynamic state
   */
  interface VkPipelineDynamicStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the number of elements in the 'pDynamicStates' array.
     */
    dynamicStateCount: number

    /**
     * is an array of 'VkDynamicState' values specifying which pieces of pipeline state will use the values from dynamic state commands rather than from pipeline state creation info.
     */
    pDynamicStates: Int32Array | null
  }

  declare interface VkPipelineDynamicStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the number of elements in the 'pDynamicStates' array.
     */
    dynamicStateCount?: number

    /**
     * is an array of 'VkDynamicState' values specifying which pieces of pipeline state will use the values from dynamic state commands rather than from pipeline state creation info.
     */
    pDynamicStates?: Int32Array | null
  }

  declare interface VkPipelineDynamicStateCreateInfoConstructor {
    readonly prototype: VkPipelineDynamicStateCreateInfo
    new (
      param?: VkPipelineDynamicStateCreateInfoInitializer | null
    ): VkPipelineDynamicStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineDynamicStateCreateInfo: VkPipelineDynamicStateCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline color blend state
   */
  interface VkPipelineColorBlendStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * controls whether to apply <<framebuffer-logicop, Logical Operations>>.
     */
    logicOpEnable: boolean

    /**
     * selects which logical operation to apply.
     */
    logicOp: VkLogicOp

    /**
     * is the number of 'VkPipelineColorBlendAttachmentState' elements in 'pAttachments'. This value 'must' equal the 'colorAttachmentCount' for the subpass in which this pipeline is used.
     */
    attachmentCount: number

    /**
     *
     */
    pAttachments: VkPipelineColorBlendAttachmentState[] | null

    /**
     * is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.
     */
    blendConstants: number[] | null
  }

  declare interface VkPipelineColorBlendStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * controls whether to apply <<framebuffer-logicop, Logical Operations>>.
     */
    logicOpEnable?: boolean

    /**
     * selects which logical operation to apply.
     */
    logicOp?: VkLogicOp

    /**
     * is the number of 'VkPipelineColorBlendAttachmentState' elements in 'pAttachments'. This value 'must' equal the 'colorAttachmentCount' for the subpass in which this pipeline is used.
     */
    attachmentCount?: number

    /**
     *
     */
    pAttachments?: VkPipelineColorBlendAttachmentState[] | null

    /**
     * is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.
     */
    blendConstants?: number[] | null
  }

  declare interface VkPipelineColorBlendStateCreateInfoConstructor {
    readonly prototype: VkPipelineColorBlendStateCreateInfo
    new (
      param?: VkPipelineColorBlendStateCreateInfoInitializer | null
    ): VkPipelineColorBlendStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineColorBlendStateCreateInfo: VkPipelineColorBlendStateCreateInfoConstructor

  /**
   * Structure specifying a pipeline color blend attachment state
   */
  interface VkPipelineColorBlendAttachmentState {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.
     */
    blendEnable: boolean

    /**
     * selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.
     */
    srcColorBlendFactor: VkBlendFactor

    /**
     * selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.
     */
    dstColorBlendFactor: VkBlendFactor

    /**
     * selects which blend operation is used to calculate the RGB values to write to the color attachment.
     */
    colorBlendOp: VkBlendOp

    /**
     * selects which blend factor is used to determine the source factor [eq]#S~a~#.
     */
    srcAlphaBlendFactor: VkBlendFactor

    /**
     * selects which blend factor is used to determine the destination factor [eq]#D~a~#.
     */
    dstAlphaBlendFactor: VkBlendFactor

    /**
     * selects which blend operation is use to calculate the alpha values to write to the color attachment.
     */
    alphaBlendOp: VkBlendOp

    /**
     * is a bitmask of 'VkColorComponentFlagBits' specifying which of the R, G, B, and/or A components are enabled for writing, as described for the <<framebuffer-color-write-mask,Color Write Mask>>.
     */
    colorWriteMask: VkColorComponentFlagBits
  }

  declare interface VkPipelineColorBlendAttachmentStateInitializer {
    /**
     * controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.
     */
    blendEnable?: boolean

    /**
     * selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.
     */
    srcColorBlendFactor?: VkBlendFactor

    /**
     * selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.
     */
    dstColorBlendFactor?: VkBlendFactor

    /**
     * selects which blend operation is used to calculate the RGB values to write to the color attachment.
     */
    colorBlendOp?: VkBlendOp

    /**
     * selects which blend factor is used to determine the source factor [eq]#S~a~#.
     */
    srcAlphaBlendFactor?: VkBlendFactor

    /**
     * selects which blend factor is used to determine the destination factor [eq]#D~a~#.
     */
    dstAlphaBlendFactor?: VkBlendFactor

    /**
     * selects which blend operation is use to calculate the alpha values to write to the color attachment.
     */
    alphaBlendOp?: VkBlendOp

    /**
     * is a bitmask of 'VkColorComponentFlagBits' specifying which of the R, G, B, and/or A components are enabled for writing, as described for the <<framebuffer-color-write-mask,Color Write Mask>>.
     */
    colorWriteMask?: VkColorComponentFlagBits
  }

  declare interface VkPipelineColorBlendAttachmentStateConstructor {
    readonly prototype: VkPipelineColorBlendAttachmentState
    new (
      param?: VkPipelineColorBlendAttachmentStateInitializer | null
    ): VkPipelineColorBlendAttachmentState

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineColorBlendAttachmentState: VkPipelineColorBlendAttachmentStateConstructor

  /**
   * Structure specifying parameters of a newly created pipeline multisample state
   */
  interface VkPipelineMultisampleStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of samples used in rasterization.
     */
    rasterizationSamples: VkSampleCountFlagBits

    /**
     * 'can' be used to enable <<primsrast-sampleshading,Sample Shading>>.
     */
    sampleShadingEnable: boolean

    /**
     * specifies a minimum fraction of sample shading if 'sampleShadingEnable' is set to 'VK_TRUE'.
     */
    minSampleShading: number

    /**
     * is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in <<fragops-samplemask,Sample Mask>>.
     */
    pSampleMask: Uint32Array | null

    /**
     * controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the <<fragops-covg,Multisample Coverage>> section.
     */
    alphaToCoverageEnable: boolean

    /**
     * controls whether the alpha component of the fragment's first color output is replaced with one as described in <<fragops-covg,Multisample Coverage>>.
     */
    alphaToOneEnable: boolean
  }

  declare interface VkPipelineMultisampleStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of samples used in rasterization.
     */
    rasterizationSamples?: VkSampleCountFlagBits

    /**
     * 'can' be used to enable <<primsrast-sampleshading,Sample Shading>>.
     */
    sampleShadingEnable?: boolean

    /**
     * specifies a minimum fraction of sample shading if 'sampleShadingEnable' is set to 'VK_TRUE'.
     */
    minSampleShading?: number

    /**
     * is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in <<fragops-samplemask,Sample Mask>>.
     */
    pSampleMask?: Uint32Array | null

    /**
     * controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the <<fragops-covg,Multisample Coverage>> section.
     */
    alphaToCoverageEnable?: boolean

    /**
     * controls whether the alpha component of the fragment's first color output is replaced with one as described in <<fragops-covg,Multisample Coverage>>.
     */
    alphaToOneEnable?: boolean
  }

  declare interface VkPipelineMultisampleStateCreateInfoConstructor {
    readonly prototype: VkPipelineMultisampleStateCreateInfo
    new (
      param?: VkPipelineMultisampleStateCreateInfoInitializer | null
    ): VkPipelineMultisampleStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineMultisampleStateCreateInfo: VkPipelineMultisampleStateCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline rasterization state
   */
  interface VkPipelineRasterizationStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * controls whether to clamp the fragment's depth values as described in <<fragops-depth,Depth Test>>. If the pipeline is not created with 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' present then enabling depth clamp will also disable clipping primitives to the z planes of the frustrum as described in <<vertexpostproc-clipping, Primitive Clipping>>. Otherwise depth clipping is controlled by the state set in 'VkPipelineRasterizationDepthClipStateCreateInfoEXT'.
     */
    depthClampEnable: boolean

    /**
     *
     */
    rasterizerDiscardEnable: boolean

    /**
     *
     */
    polygonMode: VkPolygonMode

    /**
     *
     */
    cullMode: VkCullModeFlagBits

    /**
     *
     */
    frontFace: VkFrontFace

    /**
     *
     */
    depthBiasEnable: boolean

    /**
     *
     */
    depthBiasConstantFactor: number

    /**
     *
     */
    depthBiasClamp: number

    /**
     *
     */
    depthBiasSlopeFactor: number

    /**
     *
     */
    lineWidth: number
  }

  declare interface VkPipelineRasterizationStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * controls whether to clamp the fragment's depth values as described in <<fragops-depth,Depth Test>>. If the pipeline is not created with 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' present then enabling depth clamp will also disable clipping primitives to the z planes of the frustrum as described in <<vertexpostproc-clipping, Primitive Clipping>>. Otherwise depth clipping is controlled by the state set in 'VkPipelineRasterizationDepthClipStateCreateInfoEXT'.
     */
    depthClampEnable?: boolean

    /**
     *
     */
    rasterizerDiscardEnable?: boolean

    /**
     *
     */
    polygonMode?: VkPolygonMode

    /**
     *
     */
    cullMode?: VkCullModeFlagBits

    /**
     *
     */
    frontFace?: VkFrontFace

    /**
     *
     */
    depthBiasEnable?: boolean

    /**
     *
     */
    depthBiasConstantFactor?: number

    /**
     *
     */
    depthBiasClamp?: number

    /**
     *
     */
    depthBiasSlopeFactor?: number

    /**
     *
     */
    lineWidth?: number
  }

  declare interface VkPipelineRasterizationStateCreateInfoConstructor {
    readonly prototype: VkPipelineRasterizationStateCreateInfo
    new (
      param?: VkPipelineRasterizationStateCreateInfoInitializer | null
    ): VkPipelineRasterizationStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineRasterizationStateCreateInfo: VkPipelineRasterizationStateCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline viewport state
   */
  interface VkPipelineViewportStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the number of viewports used by the pipeline.
     */
    viewportCount: number

    /**
     * is an array of 'VkViewport' structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.
     */
    pViewports: VkViewport[] | null

    /**
     * is the number of <<fragops-scissor,scissors>> and 'must' match the number of viewports.
     */
    scissorCount: number

    /**
     * is an array of 'VkRect2D' structures defining the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.
     */
    pScissors: VkRect2D[] | null
  }

  declare interface VkPipelineViewportStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the number of viewports used by the pipeline.
     */
    viewportCount?: number

    /**
     * is an array of 'VkViewport' structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.
     */
    pViewports?: VkViewport[] | null

    /**
     * is the number of <<fragops-scissor,scissors>> and 'must' match the number of viewports.
     */
    scissorCount?: number

    /**
     * is an array of 'VkRect2D' structures defining the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.
     */
    pScissors?: VkRect2D[] | null
  }

  declare interface VkPipelineViewportStateCreateInfoConstructor {
    readonly prototype: VkPipelineViewportStateCreateInfo
    new (
      param?: VkPipelineViewportStateCreateInfoInitializer | null
    ): VkPipelineViewportStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineViewportStateCreateInfo: VkPipelineViewportStateCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline tessellation state
   */
  interface VkPipelineTessellationStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * number of control reference per patch.
     */
    patchControlPoints: number
  }

  declare interface VkPipelineTessellationStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * number of control reference per patch.
     */
    patchControlPoints?: number
  }

  declare interface VkPipelineTessellationStateCreateInfoConstructor {
    readonly prototype: VkPipelineTessellationStateCreateInfo
    new (
      param?: VkPipelineTessellationStateCreateInfoInitializer | null
    ): VkPipelineTessellationStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineTessellationStateCreateInfo: VkPipelineTessellationStateCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline input assembly state
   */
  interface VkPipelineInputAssemblyStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is a 'VkPrimitiveTopology' defining the primitive topology, as described below.
     */
    topology: VkPrimitiveTopology

    /**
     * controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws ('vkCmdDrawIndexed' and 'vkCmdDrawIndexedIndirect'), and the special index value is either 0xFFFFFFFF when the 'indexType' parameter of 'vkCmdBindIndexBuffer' is equal to 'VK_INDEX_TYPE_UINT32', 0xFF when 'indexType' is equal to 'VK_INDEX_TYPE_UINT8_EXT',
     */
    primitiveRestartEnable: boolean
  }

  declare interface VkPipelineInputAssemblyStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is a 'VkPrimitiveTopology' defining the primitive topology, as described below.
     */
    topology?: VkPrimitiveTopology

    /**
     * controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws ('vkCmdDrawIndexed' and 'vkCmdDrawIndexedIndirect'), and the special index value is either 0xFFFFFFFF when the 'indexType' parameter of 'vkCmdBindIndexBuffer' is equal to 'VK_INDEX_TYPE_UINT32', 0xFF when 'indexType' is equal to 'VK_INDEX_TYPE_UINT8_EXT',
     */
    primitiveRestartEnable?: boolean
  }

  declare interface VkPipelineInputAssemblyStateCreateInfoConstructor {
    readonly prototype: VkPipelineInputAssemblyStateCreateInfo
    new (
      param?: VkPipelineInputAssemblyStateCreateInfoInitializer | null
    ): VkPipelineInputAssemblyStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineInputAssemblyStateCreateInfo: VkPipelineInputAssemblyStateCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline vertex input state
   */
  interface VkPipelineVertexInputStateCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the number of vertex binding descriptions provided in 'pVertexBindingDescriptions'.
     */
    vertexBindingDescriptionCount: number

    /**
     * is an array of 'VkVertexInputBindingDescription' structures.
     */
    pVertexBindingDescriptions: VkVertexInputBindingDescription[] | null

    /**
     * is the number of vertex attribute descriptions provided in 'pVertexAttributeDescriptions'.
     */
    vertexAttributeDescriptionCount: number

    /**
     * is an array of 'VkVertexInputAttributeDescription' structures.
     */
    pVertexAttributeDescriptions: VkVertexInputAttributeDescription[] | null
  }

  declare interface VkPipelineVertexInputStateCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the number of vertex binding descriptions provided in 'pVertexBindingDescriptions'.
     */
    vertexBindingDescriptionCount?: number

    /**
     * is an array of 'VkVertexInputBindingDescription' structures.
     */
    pVertexBindingDescriptions?: VkVertexInputBindingDescription[] | null

    /**
     * is the number of vertex attribute descriptions provided in 'pVertexAttributeDescriptions'.
     */
    vertexAttributeDescriptionCount?: number

    /**
     * is an array of 'VkVertexInputAttributeDescription' structures.
     */
    pVertexAttributeDescriptions?: VkVertexInputAttributeDescription[] | null
  }

  declare interface VkPipelineVertexInputStateCreateInfoConstructor {
    readonly prototype: VkPipelineVertexInputStateCreateInfo
    new (
      param?: VkPipelineVertexInputStateCreateInfoInitializer | null
    ): VkPipelineVertexInputStateCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineVertexInputStateCreateInfo: VkPipelineVertexInputStateCreateInfoConstructor

  /**
   * Structure specifying vertex input attribute description
   */
  interface VkVertexInputAttributeDescription {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the shader binding location number for this attribute.
     */
    location: number

    /**
     * is the binding number which this attribute takes its data from.
     */
    binding: number

    /**
     * is the size and type of the vertex attribute data.
     */
    format: VkFormat

    /**
     * is a byte offset of this attribute relative to the start of an element in the vertex input binding.
     */
    offset: number
  }

  declare interface VkVertexInputAttributeDescriptionInitializer {
    /**
     * is the shader binding location number for this attribute.
     */
    location?: number

    /**
     * is the binding number which this attribute takes its data from.
     */
    binding?: number

    /**
     * is the size and type of the vertex attribute data.
     */
    format?: VkFormat

    /**
     * is a byte offset of this attribute relative to the start of an element in the vertex input binding.
     */
    offset?: number
  }

  declare interface VkVertexInputAttributeDescriptionConstructor {
    readonly prototype: VkVertexInputAttributeDescription
    new (
      param?: VkVertexInputAttributeDescriptionInitializer | null
    ): VkVertexInputAttributeDescription

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkVertexInputAttributeDescription: VkVertexInputAttributeDescriptionConstructor

  /**
   * Structure specifying vertex input binding description
   */
  interface VkVertexInputBindingDescription {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the binding number that this structure describes.
     */
    binding: number

    /**
     * is the distance in bytes between two consecutive elements within the buffer.
     */
    stride: number

    /**
     * is a 'VkVertexInputRate' value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index.
     */
    inputRate: VkVertexInputRate
  }

  declare interface VkVertexInputBindingDescriptionInitializer {
    /**
     * is the binding number that this structure describes.
     */
    binding?: number

    /**
     * is the distance in bytes between two consecutive elements within the buffer.
     */
    stride?: number

    /**
     * is a 'VkVertexInputRate' value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index.
     */
    inputRate?: VkVertexInputRate
  }

  declare interface VkVertexInputBindingDescriptionConstructor {
    readonly prototype: VkVertexInputBindingDescription
    new (
      param?: VkVertexInputBindingDescriptionInitializer | null
    ): VkVertexInputBindingDescription

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkVertexInputBindingDescription: VkVertexInputBindingDescriptionConstructor

  /**
   * Structure specifying parameters of a newly created compute pipeline
   */
  interface VkComputePipelineCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits

    /**
     * is a 'VkPipelineShaderStageCreateInfo' structure describing the compute shader.
     */
    stage: VkPipelineShaderStageCreateInfo | null

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout: VkPipelineLayout | null

    /**
     * is a pipeline to derive from
     */
    basePipelineHandle: VkPipeline | null

    /**
     *
     */
    basePipelineIndex: number
  }

  declare interface VkComputePipelineCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits

    /**
     * is a 'VkPipelineShaderStageCreateInfo' structure describing the compute shader.
     */
    stage?: VkPipelineShaderStageCreateInfo | null

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout?: VkPipelineLayout | null

    /**
     * is a pipeline to derive from
     */
    basePipelineHandle?: VkPipeline | null

    /**
     *
     */
    basePipelineIndex?: number
  }

  declare interface VkComputePipelineCreateInfoConstructor {
    readonly prototype: VkComputePipelineCreateInfo
    new (
      param?: VkComputePipelineCreateInfoInitializer | null
    ): VkComputePipelineCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkComputePipelineCreateInfo: VkComputePipelineCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created pipeline shader stage
   */
  interface VkPipelineShaderStageCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkPipelineShaderStageCreateFlagBits' specifying how the pipeline shader stage will be generated.
     */
    flags: VkPipelineShaderStageCreateFlagBits

    /**
     * is a 'VkShaderStageFlagBits' value specifying a single pipeline stage.
     */
    stage: VkShaderStageFlagBits

    /**
     * is a 'VkShaderModule' object containing the shader for this stage.
     */
    module: VkShaderModule | null

    /**
     * is a reference to a string specifying the entry point name of the shader for this stage.
     */
    pName: string | null

    /**
     * is a reference to a 'VkSpecializationInfo' structure, as described in <<pipelines-specialization-constants,Specialization Constants>>, or <i>null</i>.
     */
    pSpecializationInfo: VkSpecializationInfo | null
  }

  declare interface VkPipelineShaderStageCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkPipelineShaderStageCreateFlagBits' specifying how the pipeline shader stage will be generated.
     */
    flags?: VkPipelineShaderStageCreateFlagBits

    /**
     * is a 'VkShaderStageFlagBits' value specifying a single pipeline stage.
     */
    stage?: VkShaderStageFlagBits

    /**
     * is a 'VkShaderModule' object containing the shader for this stage.
     */
    module?: VkShaderModule | null

    /**
     * is a reference to a string specifying the entry point name of the shader for this stage.
     */
    pName?: string | null

    /**
     * is a reference to a 'VkSpecializationInfo' structure, as described in <<pipelines-specialization-constants,Specialization Constants>>, or <i>null</i>.
     */
    pSpecializationInfo?: VkSpecializationInfo | null
  }

  declare interface VkPipelineShaderStageCreateInfoConstructor {
    readonly prototype: VkPipelineShaderStageCreateInfo
    new (
      param?: VkPipelineShaderStageCreateInfoInitializer | null
    ): VkPipelineShaderStageCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPipelineShaderStageCreateInfo: VkPipelineShaderStageCreateInfoConstructor

  /**
   * Structure specifying specialization info
   */
  interface VkSpecializationInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    mapEntryCount: number

    /**
     * is an array of 'VkSpecializationMapEntry' structures which map constant IDs to offsets in 'pData'.
     */
    pMapEntries: VkSpecializationMapEntry[] | null

    /**
     *
     */
    dataSize: bigint | number

    /**
     * contains the actual constant values to specialize with.
     */
    pData: ArrayBuffer | null
  }

  declare interface VkSpecializationInfoInitializer {
    /**
     *
     */
    mapEntryCount?: number

    /**
     * is an array of 'VkSpecializationMapEntry' structures which map constant IDs to offsets in 'pData'.
     */
    pMapEntries?: VkSpecializationMapEntry[] | null

    /**
     *
     */
    dataSize?: bigint | number

    /**
     * contains the actual constant values to specialize with.
     */
    pData?: ArrayBuffer | null
  }

  declare interface VkSpecializationInfoConstructor {
    readonly prototype: VkSpecializationInfo
    new (param?: VkSpecializationInfoInitializer | null): VkSpecializationInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSpecializationInfo: VkSpecializationInfoConstructor

  /**
   * Structure specifying a specialization map entry
   */
  interface VkSpecializationMapEntry {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the ID of the specialization constant in SPIR-V.
     */
    constantID: number

    /**
     * is the byte offset of the specialization constant value within the supplied data buffer.
     */
    offset: number

    /**
     * is the byte size of the specialization constant value within the supplied data buffer.
     */
    size: bigint | number
  }

  declare interface VkSpecializationMapEntryInitializer {
    /**
     * is the ID of the specialization constant in SPIR-V.
     */
    constantID?: number

    /**
     * is the byte offset of the specialization constant value within the supplied data buffer.
     */
    offset?: number

    /**
     * is the byte size of the specialization constant value within the supplied data buffer.
     */
    size?: bigint | number
  }

  declare interface VkSpecializationMapEntryConstructor {
    readonly prototype: VkSpecializationMapEntry
    new (
      param?: VkSpecializationMapEntryInitializer | null
    ): VkSpecializationMapEntry

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSpecializationMapEntry: VkSpecializationMapEntryConstructor

  /**
   * Structure specifying the allocation parameters for descriptor sets
   */
  interface VkDescriptorSetAllocateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the pool which the sets will be allocated from.
     */
    descriptorPool: VkDescriptorPool | null

    /**
     * determines the number of descriptor sets to be allocated from the pool.
     */
    descriptorSetCount: number

    /**
     * is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
     */
    pSetLayouts: VkDescriptorSetLayout[] | null
  }

  declare interface VkDescriptorSetAllocateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the pool which the sets will be allocated from.
     */
    descriptorPool?: VkDescriptorPool | null

    /**
     * determines the number of descriptor sets to be allocated from the pool.
     */
    descriptorSetCount?: number

    /**
     * is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
     */
    pSetLayouts?: VkDescriptorSetLayout[] | null
  }

  declare interface VkDescriptorSetAllocateInfoConstructor {
    readonly prototype: VkDescriptorSetAllocateInfo
    new (
      param?: VkDescriptorSetAllocateInfoInitializer | null
    ): VkDescriptorSetAllocateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetAllocateInfo: VkDescriptorSetAllocateInfoConstructor

  /**
   * Structure specifying parameters of a newly created descriptor pool
   */
  interface VkDescriptorPoolCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkDescriptorPoolCreateFlagBits' specifying certain supported operations on the pool.
     */
    flags: VkDescriptorPoolCreateFlagBits

    /**
     * is the maximum number of descriptor sets that 'can' be allocated from the pool.
     */
    maxSets: number

    /**
     *
     */
    poolSizeCount: number

    /**
     * is an array of 'VkDescriptorPoolSize' structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
     */
    pPoolSizes: VkDescriptorPoolSize[] | null
  }

  declare interface VkDescriptorPoolCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkDescriptorPoolCreateFlagBits' specifying certain supported operations on the pool.
     */
    flags?: VkDescriptorPoolCreateFlagBits

    /**
     * is the maximum number of descriptor sets that 'can' be allocated from the pool.
     */
    maxSets?: number

    /**
     *
     */
    poolSizeCount?: number

    /**
     * is an array of 'VkDescriptorPoolSize' structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
     */
    pPoolSizes?: VkDescriptorPoolSize[] | null
  }

  declare interface VkDescriptorPoolCreateInfoConstructor {
    readonly prototype: VkDescriptorPoolCreateInfo
    new (
      param?: VkDescriptorPoolCreateInfoInitializer | null
    ): VkDescriptorPoolCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorPoolCreateInfo: VkDescriptorPoolCreateInfoConstructor

  /**
   * Structure specifying descriptor pool size
   */
  interface VkDescriptorPoolSize {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of descriptor.
     */
    type: VkDescriptorType

    /**
     * is the number of descriptors of that type to allocate. If 'type' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'descriptorCount' is the number of bytes to allocate for descriptors of this type.
     */
    descriptorCount: number
  }

  declare interface VkDescriptorPoolSizeInitializer {
    /**
     * is the type of descriptor.
     */
    type?: VkDescriptorType

    /**
     * is the number of descriptors of that type to allocate. If 'type' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'descriptorCount' is the number of bytes to allocate for descriptors of this type.
     */
    descriptorCount?: number
  }

  declare interface VkDescriptorPoolSizeConstructor {
    readonly prototype: VkDescriptorPoolSize
    new (param?: VkDescriptorPoolSizeInitializer | null): VkDescriptorPoolSize

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorPoolSize: VkDescriptorPoolSizeConstructor

  /**
   * Structure specifying parameters of a newly created descriptor set layout
   */
  interface VkDescriptorSetLayoutCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkDescriptorSetLayoutCreateFlagBits'
     */
    flags: VkDescriptorSetLayoutCreateFlagBits

    /**
     *
     */
    bindingCount: number

    /**
     *
     */
    pBindings: VkDescriptorSetLayoutBinding[] | null
  }

  declare interface VkDescriptorSetLayoutCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkDescriptorSetLayoutCreateFlagBits'
     */
    flags?: VkDescriptorSetLayoutCreateFlagBits

    /**
     *
     */
    bindingCount?: number

    /**
     *
     */
    pBindings?: VkDescriptorSetLayoutBinding[] | null
  }

  declare interface VkDescriptorSetLayoutCreateInfoConstructor {
    readonly prototype: VkDescriptorSetLayoutCreateInfo
    new (
      param?: VkDescriptorSetLayoutCreateInfoInitializer | null
    ): VkDescriptorSetLayoutCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetLayoutCreateInfo: VkDescriptorSetLayoutCreateInfoConstructor

  /**
   * Structure specifying a descriptor set layout binding
   */
  interface VkDescriptorSetLayoutBinding {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
     */
    binding: number

    /**
     * is a 'VkDescriptorType' specifying which type of resource descriptors are used for this binding.
     */
    descriptorType: VkDescriptorType

    /**
     * is the number of descriptors contained in the binding, accessed in a shader as an array , except if 'descriptorType' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' in which case 'descriptorCount' is the size in bytes of the inline uniform block
     */
    descriptorCount: number

    /**
     *
     */
    stageFlags: VkShaderStageFlagBits

    /**
     *
     */
    pImmutableSamplers: VkSampler[] | null
  }

  declare interface VkDescriptorSetLayoutBindingInitializer {
    /**
     * is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
     */
    binding?: number

    /**
     * is a 'VkDescriptorType' specifying which type of resource descriptors are used for this binding.
     */
    descriptorType?: VkDescriptorType

    /**
     * is the number of descriptors contained in the binding, accessed in a shader as an array , except if 'descriptorType' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' in which case 'descriptorCount' is the size in bytes of the inline uniform block
     */
    descriptorCount?: number

    /**
     *
     */
    stageFlags?: VkShaderStageFlagBits

    /**
     *
     */
    pImmutableSamplers?: VkSampler[] | null
  }

  declare interface VkDescriptorSetLayoutBindingConstructor {
    readonly prototype: VkDescriptorSetLayoutBinding
    new (
      param?: VkDescriptorSetLayoutBindingInitializer | null
    ): VkDescriptorSetLayoutBinding

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorSetLayoutBinding: VkDescriptorSetLayoutBindingConstructor

  /**
   * Structure specifying parameters of a newly created shader module
   */
  interface VkShaderModuleCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: VkShaderModuleCreateFlagBits

    /**
     * is the size, in bytes, of the code pointed to by 'pCode'.
     */
    codeSize: bigint | number

    /**
     * is a reference to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by 'pCode'.
     */
    pCode: Uint8Array | null
  }

  declare interface VkShaderModuleCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: VkShaderModuleCreateFlagBits

    /**
     * is the size, in bytes, of the code pointed to by 'pCode'.
     */
    codeSize?: bigint | number

    /**
     * is a reference to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by 'pCode'.
     */
    pCode?: Uint8Array | null
  }

  declare interface VkShaderModuleCreateInfoConstructor {
    readonly prototype: VkShaderModuleCreateInfo
    new (
      param?: VkShaderModuleCreateInfoInitializer | null
    ): VkShaderModuleCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkShaderModuleCreateInfo: VkShaderModuleCreateInfoConstructor

  /**
   * Structure specifying an image resolve operation
   */
  interface VkImageResolve {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    srcSubresource: VkImageSubresourceLayers | null

    /**
     *
     */
    srcOffset: VkOffset3D | null

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
     */
    dstSubresource: VkImageSubresourceLayers | null

    /**
     *
     */
    dstOffset: VkOffset3D | null

    /**
     * is the size in texels of the source image to resolve in 'width', 'height' and 'depth'.
     */
    extent: VkExtent3D | null
  }

  declare interface VkImageResolveInitializer {
    /**
     *
     */
    srcSubresource?: VkImageSubresourceLayers | null

    /**
     *
     */
    srcOffset?: VkOffset3D | null

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
     */
    dstSubresource?: VkImageSubresourceLayers | null

    /**
     *
     */
    dstOffset?: VkOffset3D | null

    /**
     * is the size in texels of the source image to resolve in 'width', 'height' and 'depth'.
     */
    extent?: VkExtent3D | null
  }

  declare interface VkImageResolveConstructor {
    readonly prototype: VkImageResolve
    new (param?: VkImageResolveInitializer | null): VkImageResolve

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageResolve: VkImageResolveConstructor

  /**
   * Structure specifying a buffer image copy operation
   */
  interface VkBufferImageCopy {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the offset in bytes from the start of the buffer object where the image data is copied from or to.
     */
    bufferOffset: bigint | number

    /**
     *
     */
    bufferRowLength: number

    /**
     * specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the 'imageExtent'.
     */
    bufferImageHeight: number

    /**
     * is a 'VkImageSubresourceLayers' used to specify the specific image subresources of the image used for the source or destination image data.
     */
    imageSubresource: VkImageSubresourceLayers | null

    /**
     *
     */
    imageOffset: VkOffset3D | null

    /**
     * is the size in texels of the image to copy in 'width', 'height' and 'depth'.
     */
    imageExtent: VkExtent3D | null
  }

  declare interface VkBufferImageCopyInitializer {
    /**
     * is the offset in bytes from the start of the buffer object where the image data is copied from or to.
     */
    bufferOffset?: bigint | number

    /**
     *
     */
    bufferRowLength?: number

    /**
     * specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the 'imageExtent'.
     */
    bufferImageHeight?: number

    /**
     * is a 'VkImageSubresourceLayers' used to specify the specific image subresources of the image used for the source or destination image data.
     */
    imageSubresource?: VkImageSubresourceLayers | null

    /**
     *
     */
    imageOffset?: VkOffset3D | null

    /**
     * is the size in texels of the image to copy in 'width', 'height' and 'depth'.
     */
    imageExtent?: VkExtent3D | null
  }

  declare interface VkBufferImageCopyConstructor {
    readonly prototype: VkBufferImageCopy
    new (param?: VkBufferImageCopyInitializer | null): VkBufferImageCopy

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferImageCopy: VkBufferImageCopyConstructor

  /**
   * Structure specifying an image blit operation
   */
  interface VkImageBlit {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the subresource to blit from.
     */
    srcSubresource: VkImageSubresourceLayers | null

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the source region within 'srcSubresource'.
     */
    srcOffsets: VkOffset3D[] | null

    /**
     * is the subresource to blit into.
     */
    dstSubresource: VkImageSubresourceLayers | null

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the destination region within 'dstSubresource'.
     */
    dstOffsets: VkOffset3D[] | null
  }

  declare interface VkImageBlitInitializer {
    /**
     * is the subresource to blit from.
     */
    srcSubresource?: VkImageSubresourceLayers | null

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the source region within 'srcSubresource'.
     */
    srcOffsets?: VkOffset3D[] | null

    /**
     * is the subresource to blit into.
     */
    dstSubresource?: VkImageSubresourceLayers | null

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the destination region within 'dstSubresource'.
     */
    dstOffsets?: VkOffset3D[] | null
  }

  declare interface VkImageBlitConstructor {
    readonly prototype: VkImageBlit
    new (param?: VkImageBlitInitializer | null): VkImageBlit

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageBlit: VkImageBlitConstructor

  /**
   * Structure specifying an image copy operation
   */
  interface VkImageCopy {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    srcSubresource: VkImageSubresourceLayers | null

    /**
     *
     */
    srcOffset: VkOffset3D | null

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively.
     */
    dstSubresource: VkImageSubresourceLayers | null

    /**
     *
     */
    dstOffset: VkOffset3D | null

    /**
     *
     */
    extent: VkExtent3D | null
  }

  declare interface VkImageCopyInitializer {
    /**
     *
     */
    srcSubresource?: VkImageSubresourceLayers | null

    /**
     *
     */
    srcOffset?: VkOffset3D | null

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively.
     */
    dstSubresource?: VkImageSubresourceLayers | null

    /**
     *
     */
    dstOffset?: VkOffset3D | null

    /**
     *
     */
    extent?: VkExtent3D | null
  }

  declare interface VkImageCopyConstructor {
    readonly prototype: VkImageCopy
    new (param?: VkImageCopyInitializer | null): VkImageCopy

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageCopy: VkImageCopyConstructor

  /**
   * Structure specifying a sparse binding operation
   */
  interface VkBindSparseInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.
     */
    waitSemaphoreCount: number

    /**
     * is an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores: VkSemaphore[] | null

    /**
     * is the number of sparse buffer bindings to perform in the batch.
     */
    bufferBindCount: number

    /**
     * is an array of 'VkSparseBufferMemoryBindInfo' structures.
     */
    pBufferBinds: VkSparseBufferMemoryBindInfo[] | null

    /**
     * is the number of opaque sparse image bindings to perform.
     */
    imageOpaqueBindCount: number

    /**
     * is an array of 'VkSparseImageOpaqueMemoryBindInfo' structures, indicating opaque sparse image bindings to perform.
     */
    pImageOpaqueBinds: VkSparseImageOpaqueMemoryBindInfo[] | null

    /**
     * is the number of sparse image bindings to perform.
     */
    imageBindCount: number

    /**
     * is an array of 'VkSparseImageMemoryBindInfo' structures, indicating sparse image bindings to perform.
     */
    pImageBinds: VkSparseImageMemoryBindInfo[] | null

    /**
     * is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.
     */
    signalSemaphoreCount: number

    /**
     * is an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores: VkSemaphore[] | null
  }

  declare interface VkBindSparseInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.
     */
    waitSemaphoreCount?: number

    /**
     * is an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores?: VkSemaphore[] | null

    /**
     * is the number of sparse buffer bindings to perform in the batch.
     */
    bufferBindCount?: number

    /**
     * is an array of 'VkSparseBufferMemoryBindInfo' structures.
     */
    pBufferBinds?: VkSparseBufferMemoryBindInfo[] | null

    /**
     * is the number of opaque sparse image bindings to perform.
     */
    imageOpaqueBindCount?: number

    /**
     * is an array of 'VkSparseImageOpaqueMemoryBindInfo' structures, indicating opaque sparse image bindings to perform.
     */
    pImageOpaqueBinds?: VkSparseImageOpaqueMemoryBindInfo[] | null

    /**
     * is the number of sparse image bindings to perform.
     */
    imageBindCount?: number

    /**
     * is an array of 'VkSparseImageMemoryBindInfo' structures, indicating sparse image bindings to perform.
     */
    pImageBinds?: VkSparseImageMemoryBindInfo[] | null

    /**
     * is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.
     */
    signalSemaphoreCount?: number

    /**
     * is an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores?: VkSemaphore[] | null
  }

  declare interface VkBindSparseInfoConstructor {
    readonly prototype: VkBindSparseInfo
    new (param?: VkBindSparseInfoInitializer | null): VkBindSparseInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBindSparseInfo: VkBindSparseInfoConstructor

  /**
   * Structure specifying sparse image memory bind info
   */
  interface VkSparseImageMemoryBindInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the 'VkImage' object to be bound
     */
    image: VkImage | null

    /**
     * is the number of 'VkSparseImageMemoryBind' structures in 'pBinds' array
     */
    bindCount: number

    /**
     * is an array of 'VkSparseImageMemoryBind' structures
     */
    pBinds: VkSparseImageMemoryBind[] | null
  }

  declare interface VkSparseImageMemoryBindInfoInitializer {
    /**
     * is the 'VkImage' object to be bound
     */
    image?: VkImage | null

    /**
     * is the number of 'VkSparseImageMemoryBind' structures in 'pBinds' array
     */
    bindCount?: number

    /**
     * is an array of 'VkSparseImageMemoryBind' structures
     */
    pBinds?: VkSparseImageMemoryBind[] | null
  }

  declare interface VkSparseImageMemoryBindInfoConstructor {
    readonly prototype: VkSparseImageMemoryBindInfo
    new (
      param?: VkSparseImageMemoryBindInfoInitializer | null
    ): VkSparseImageMemoryBindInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageMemoryBindInfo: VkSparseImageMemoryBindInfoConstructor

  /**
   * Structure specifying sparse image opaque memory bind info
   */
  interface VkSparseImageOpaqueMemoryBindInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the 'VkImage' object to be bound.
     */
    image: VkImage | null

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount: number

    /**
     * is an array of 'VkSparseMemoryBind' structures.
     */
    pBinds: VkSparseMemoryBind[] | null
  }

  declare interface VkSparseImageOpaqueMemoryBindInfoInitializer {
    /**
     * is the 'VkImage' object to be bound.
     */
    image?: VkImage | null

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount?: number

    /**
     * is an array of 'VkSparseMemoryBind' structures.
     */
    pBinds?: VkSparseMemoryBind[] | null
  }

  declare interface VkSparseImageOpaqueMemoryBindInfoConstructor {
    readonly prototype: VkSparseImageOpaqueMemoryBindInfo
    new (
      param?: VkSparseImageOpaqueMemoryBindInfoInitializer | null
    ): VkSparseImageOpaqueMemoryBindInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageOpaqueMemoryBindInfo: VkSparseImageOpaqueMemoryBindInfoConstructor

  /**
   * Structure specifying a sparse buffer memory bind operation
   */
  interface VkSparseBufferMemoryBindInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the 'VkBuffer' object to be bound.
     */
    buffer: VkBuffer | null

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount: number

    /**
     * is a reference to array of 'VkSparseMemoryBind' structures.
     */
    pBinds: VkSparseMemoryBind[] | null
  }

  declare interface VkSparseBufferMemoryBindInfoInitializer {
    /**
     * is the 'VkBuffer' object to be bound.
     */
    buffer?: VkBuffer | null

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount?: number

    /**
     * is a reference to array of 'VkSparseMemoryBind' structures.
     */
    pBinds?: VkSparseMemoryBind[] | null
  }

  declare interface VkSparseBufferMemoryBindInfoConstructor {
    readonly prototype: VkSparseBufferMemoryBindInfo
    new (
      param?: VkSparseBufferMemoryBindInfoInitializer | null
    ): VkSparseBufferMemoryBindInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseBufferMemoryBindInfo: VkSparseBufferMemoryBindInfoConstructor

  /**
   * Structure specifying sparse image memory bind
   */
  interface VkSparseImageMemoryBind {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    subresource: VkImageSubresource | null

    /**
     *
     */
    offset: VkOffset3D | null

    /**
     *
     */
    extent: VkExtent3D | null

    /**
     * is the 'VkDeviceMemory' object that the sparse image blocks of the image are bound to. If 'memory' is 'VK_NULL_HANDLE', the sparse image blocks are unbound.
     */
    memory: VkDeviceMemory | null

    /**
     * is an offset into 'VkDeviceMemory' object. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset: bigint | number

    /**
     * are sparse memory binding flags.
     */
    flags: VkSparseMemoryBindFlagBits
  }

  declare interface VkSparseImageMemoryBindInitializer {
    /**
     *
     */
    subresource?: VkImageSubresource | null

    /**
     *
     */
    offset?: VkOffset3D | null

    /**
     *
     */
    extent?: VkExtent3D | null

    /**
     * is the 'VkDeviceMemory' object that the sparse image blocks of the image are bound to. If 'memory' is 'VK_NULL_HANDLE', the sparse image blocks are unbound.
     */
    memory?: VkDeviceMemory | null

    /**
     * is an offset into 'VkDeviceMemory' object. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset?: bigint | number

    /**
     * are sparse memory binding flags.
     */
    flags?: VkSparseMemoryBindFlagBits
  }

  declare interface VkSparseImageMemoryBindConstructor {
    readonly prototype: VkSparseImageMemoryBind
    new (
      param?: VkSparseImageMemoryBindInitializer | null
    ): VkSparseImageMemoryBind

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageMemoryBind: VkSparseImageMemoryBindConstructor

  /**
   * Structure specifying a sparse memory bind operation
   */
  interface VkSparseMemoryBind {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the offset into the resource.
     */
    resourceOffset: bigint | number

    /**
     * is the size of the memory region to be bound.
     */
    size: bigint | number

    /**
     * is the 'VkDeviceMemory' object that the range of the resource is bound to. If 'memory' is 'VK_NULL_HANDLE', the range is unbound.
     */
    memory: VkDeviceMemory | null

    /**
     * is the offset into the 'VkDeviceMemory' object to bind the resource range to. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset: bigint | number

    /**
     * is a bitmask of 'VkSparseMemoryBindFlagBits' specifying usage of the binding operation.
     */
    flags: VkSparseMemoryBindFlagBits
  }

  declare interface VkSparseMemoryBindInitializer {
    /**
     * is the offset into the resource.
     */
    resourceOffset?: bigint | number

    /**
     * is the size of the memory region to be bound.
     */
    size?: bigint | number

    /**
     * is the 'VkDeviceMemory' object that the range of the resource is bound to. If 'memory' is 'VK_NULL_HANDLE', the range is unbound.
     */
    memory?: VkDeviceMemory | null

    /**
     * is the offset into the 'VkDeviceMemory' object to bind the resource range to. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset?: bigint | number

    /**
     * is a bitmask of 'VkSparseMemoryBindFlagBits' specifying usage of the binding operation.
     */
    flags?: VkSparseMemoryBindFlagBits
  }

  declare interface VkSparseMemoryBindConstructor {
    readonly prototype: VkSparseMemoryBind
    new (param?: VkSparseMemoryBindInitializer | null): VkSparseMemoryBind

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseMemoryBind: VkSparseMemoryBindConstructor

  /**
   * Structure specifying a buffer copy operation
   */
  interface VkBufferCopy {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the starting offset in bytes from the start of 'srcBuffer'.
     */
    srcOffset: bigint | number

    /**
     * is the starting offset in bytes from the start of 'dstBuffer'.
     */
    dstOffset: bigint | number

    /**
     * is the number of bytes to copy.
     */
    size: bigint | number
  }

  declare interface VkBufferCopyInitializer {
    /**
     * is the starting offset in bytes from the start of 'srcBuffer'.
     */
    srcOffset?: bigint | number

    /**
     * is the starting offset in bytes from the start of 'dstBuffer'.
     */
    dstOffset?: bigint | number

    /**
     * is the number of bytes to copy.
     */
    size?: bigint | number
  }

  declare interface VkBufferCopyConstructor {
    readonly prototype: VkBufferCopy
    new (param?: VkBufferCopyInitializer | null): VkBufferCopy

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferCopy: VkBufferCopyConstructor

  /**
   * Structure specifying parameters of a newly created image view
   */
  interface VkImageViewCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkImageViewCreateFlagBits' describing additional parameters of the image view.
     */
    flags: VkImageViewCreateFlagBits

    /**
     * is a 'VkImage' on which the view will be created.
     */
    image: VkImage | null

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    viewType: VkImageViewType

    /**
     * is a 'VkFormat' describing the format and type used to interpret texel blocks in the image.
     */
    format: VkFormat

    /**
     * is a 'VkComponentMapping' specifies a remapping of color components (or of depth or stencil components after they have been converted into color components).
     */
    components: VkComponentMapping | null

    /**
     * is a 'VkImageSubresourceRange' selecting the set of mipmap levels and array layers to be accessible to the view.
     */
    subresourceRange: VkImageSubresourceRange | null
  }

  declare interface VkImageViewCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkImageViewCreateFlagBits' describing additional parameters of the image view.
     */
    flags?: VkImageViewCreateFlagBits

    /**
     * is a 'VkImage' on which the view will be created.
     */
    image?: VkImage | null

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    viewType?: VkImageViewType

    /**
     * is a 'VkFormat' describing the format and type used to interpret texel blocks in the image.
     */
    format?: VkFormat

    /**
     * is a 'VkComponentMapping' specifies a remapping of color components (or of depth or stencil components after they have been converted into color components).
     */
    components?: VkComponentMapping | null

    /**
     * is a 'VkImageSubresourceRange' selecting the set of mipmap levels and array layers to be accessible to the view.
     */
    subresourceRange?: VkImageSubresourceRange | null
  }

  declare interface VkImageViewCreateInfoConstructor {
    readonly prototype: VkImageViewCreateInfo
    new (param?: VkImageViewCreateInfoInitializer | null): VkImageViewCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageViewCreateInfo: VkImageViewCreateInfoConstructor

  /**
   * Structure specifying subresource layout
   */
  interface VkSubresourceLayout {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the byte offset from the start of the image or the plane
     */
    readonly offset: bigint | number

    /**
     *
     */
    readonly size: bigint | number

    /**
     *
     */
    readonly rowPitch: bigint | number

    /**
     *
     */
    readonly arrayPitch: bigint | number

    /**
     *
     */
    readonly depthPitch: bigint | number
  }

  declare interface VkSubresourceLayoutInitializer {
    /**
     * is the byte offset from the start of the image or the plane
     */
    readonly offset?: bigint | number

    /**
     *
     */
    readonly size?: bigint | number

    /**
     *
     */
    readonly rowPitch?: bigint | number

    /**
     *
     */
    readonly arrayPitch?: bigint | number

    /**
     *
     */
    readonly depthPitch?: bigint | number
  }

  declare interface VkSubresourceLayoutConstructor {
    readonly prototype: VkSubresourceLayout
    new (param?: VkSubresourceLayoutInitializer | null): VkSubresourceLayout

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSubresourceLayout: VkSubresourceLayoutConstructor

  /**
   * Structure specifying the parameters of a newly created image object
   */
  interface VkImageCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkImageCreateFlagBits' describing additional parameters of the image.
     */
    flags: VkImageCreateFlagBits

    /**
     * is a 'VkImageType' value specifying the basic dimensionality of the image. Layers in array textures do not count as a dimension for the purposes of the image type.
     */
    imageType: VkImageType

    /**
     * is a 'VkFormat' describing the format and type of the texel blocks that will be contained in the image.
     */
    format: VkFormat

    /**
     * is a 'VkExtent3D' describing the number of data elements in each dimension of the base level.
     */
    extent: VkExtent3D | null

    /**
     * describes the number of levels of detail available for minified sampling of the image.
     */
    mipLevels: number

    /**
     * is the number of layers in the image.
     */
    arrayLayers: number

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of <<primsrast-multisampling,samples per texel>>.
     */
    samples: VkSampleCountFlagBits

    /**
     * is a 'VkImageTiling' value specifying the tiling arrangement of the texel blocks in memory.
     */
    tiling: VkImageTiling

    /**
     * is a bitmask of 'VkImageUsageFlagBits' describing the intended usage of the image.
     */
    usage: VkImageUsageFlagBits

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the image when it will be accessed by multiple queue families.
     */
    sharingMode: VkSharingMode

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount: number

    /**
     * is a list of queue families that will access this image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices: Uint32Array | null

    /**
     * is a 'VkImageLayout' value specifying the initial 'VkImageLayout' of all image subresources of the image. See <<resources-image-layouts,Image Layouts>>.
     */
    initialLayout: VkImageLayout
  }

  declare interface VkImageCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkImageCreateFlagBits' describing additional parameters of the image.
     */
    flags?: VkImageCreateFlagBits

    /**
     * is a 'VkImageType' value specifying the basic dimensionality of the image. Layers in array textures do not count as a dimension for the purposes of the image type.
     */
    imageType?: VkImageType

    /**
     * is a 'VkFormat' describing the format and type of the texel blocks that will be contained in the image.
     */
    format?: VkFormat

    /**
     * is a 'VkExtent3D' describing the number of data elements in each dimension of the base level.
     */
    extent?: VkExtent3D | null

    /**
     * describes the number of levels of detail available for minified sampling of the image.
     */
    mipLevels?: number

    /**
     * is the number of layers in the image.
     */
    arrayLayers?: number

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of <<primsrast-multisampling,samples per texel>>.
     */
    samples?: VkSampleCountFlagBits

    /**
     * is a 'VkImageTiling' value specifying the tiling arrangement of the texel blocks in memory.
     */
    tiling?: VkImageTiling

    /**
     * is a bitmask of 'VkImageUsageFlagBits' describing the intended usage of the image.
     */
    usage?: VkImageUsageFlagBits

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the image when it will be accessed by multiple queue families.
     */
    sharingMode?: VkSharingMode

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount?: number

    /**
     * is a list of queue families that will access this image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices?: Uint32Array | null

    /**
     * is a 'VkImageLayout' value specifying the initial 'VkImageLayout' of all image subresources of the image. See <<resources-image-layouts,Image Layouts>>.
     */
    initialLayout?: VkImageLayout
  }

  declare interface VkImageCreateInfoConstructor {
    readonly prototype: VkImageCreateInfo
    new (param?: VkImageCreateInfoInitializer | null): VkImageCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageCreateInfo: VkImageCreateInfoConstructor

  /**
   * Structure specifying the parameters of an image memory barrier
   */
  interface VkImageMemoryBarrier {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits

    /**
     * is the old layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    oldLayout: VkImageLayout

    /**
     * is the new layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    newLayout: VkImageLayout

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex: number

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex: number

    /**
     * is a handle to the image affected by this barrier.
     */
    image: VkImage | null

    /**
     * describes the <<resources-image-views, image subresource range>> within 'image' that is affected by this barrier.
     */
    subresourceRange: VkImageSubresourceRange | null
  }

  declare interface VkImageMemoryBarrierInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits

    /**
     * is the old layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    oldLayout?: VkImageLayout

    /**
     * is the new layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    newLayout?: VkImageLayout

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex?: number

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex?: number

    /**
     * is a handle to the image affected by this barrier.
     */
    image?: VkImage | null

    /**
     * describes the <<resources-image-views, image subresource range>> within 'image' that is affected by this barrier.
     */
    subresourceRange?: VkImageSubresourceRange | null
  }

  declare interface VkImageMemoryBarrierConstructor {
    readonly prototype: VkImageMemoryBarrier
    new (param?: VkImageMemoryBarrierInitializer | null): VkImageMemoryBarrier

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageMemoryBarrier: VkImageMemoryBarrierConstructor

  /**
   * Structure specifying a buffer memory barrier
   */
  interface VkBufferMemoryBarrier {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex: number

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex: number

    /**
     * is a handle to the buffer whose backing memory is affected by the barrier.
     */
    buffer: VkBuffer | null

    /**
     * is an offset in bytes into the backing memory for 'buffer'; this is relative to the base offset as bound to the buffer (see 'vkBindBufferMemory').
     */
    offset: bigint | number

    /**
     * is a size in bytes of the affected area of backing memory for 'buffer', or 'VK_WHOLE_SIZE' to use the range from 'offset' to the end of the buffer.
     */
    size: bigint | number
  }

  declare interface VkBufferMemoryBarrierInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex?: number

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex?: number

    /**
     * is a handle to the buffer whose backing memory is affected by the barrier.
     */
    buffer?: VkBuffer | null

    /**
     * is an offset in bytes into the backing memory for 'buffer'; this is relative to the base offset as bound to the buffer (see 'vkBindBufferMemory').
     */
    offset?: bigint | number

    /**
     * is a size in bytes of the affected area of backing memory for 'buffer', or 'VK_WHOLE_SIZE' to use the range from 'offset' to the end of the buffer.
     */
    size?: bigint | number
  }

  declare interface VkBufferMemoryBarrierConstructor {
    readonly prototype: VkBufferMemoryBarrier
    new (param?: VkBufferMemoryBarrierInitializer | null): VkBufferMemoryBarrier

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferMemoryBarrier: VkBufferMemoryBarrierConstructor

  /**
   * Structure specifying a global memory barrier
   */
  interface VkMemoryBarrier {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits
  }

  declare interface VkMemoryBarrierInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits
  }

  declare interface VkMemoryBarrierConstructor {
    readonly prototype: VkMemoryBarrier
    new (param?: VkMemoryBarrierInitializer | null): VkMemoryBarrier

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryBarrier: VkMemoryBarrierConstructor

  /**
   * Structure specifying an image subresource range
   */
  interface VkImageSubresourceRange {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkImageAspectFlagBits' specifying which aspect(s) of the image are included in the view.
     */
    aspectMask: VkImageAspectFlagBits

    /**
     * is the first mipmap level accessible to the view.
     */
    baseMipLevel: number

    /**
     * is the number of mipmap levels (starting from 'baseMipLevel') accessible to the view.
     */
    levelCount: number

    /**
     * is the first array layer accessible to the view.
     */
    baseArrayLayer: number

    /**
     * is the number of array layers (starting from 'baseArrayLayer') accessible to the view.
     */
    layerCount: number
  }

  declare interface VkImageSubresourceRangeInitializer {
    /**
     * is a bitmask of 'VkImageAspectFlagBits' specifying which aspect(s) of the image are included in the view.
     */
    aspectMask?: VkImageAspectFlagBits

    /**
     * is the first mipmap level accessible to the view.
     */
    baseMipLevel?: number

    /**
     * is the number of mipmap levels (starting from 'baseMipLevel') accessible to the view.
     */
    levelCount?: number

    /**
     * is the first array layer accessible to the view.
     */
    baseArrayLayer?: number

    /**
     * is the number of array layers (starting from 'baseArrayLayer') accessible to the view.
     */
    layerCount?: number
  }

  declare interface VkImageSubresourceRangeConstructor {
    readonly prototype: VkImageSubresourceRange
    new (
      param?: VkImageSubresourceRangeInitializer | null
    ): VkImageSubresourceRange

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageSubresourceRange: VkImageSubresourceRangeConstructor

  /**
   * Structure specifying an image subresource layers
   */
  interface VkImageSubresourceLayers {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a combination of 'VkImageAspectFlagBits', selecting the color, depth and/or stencil aspects to be copied.
     */
    aspectMask: VkImageAspectFlagBits

    /**
     * is the mipmap level to copy from.
     */
    mipLevel: number

    /**
     *
     */
    baseArrayLayer: number

    /**
     * are the starting layer and number of layers to copy.
     */
    layerCount: number
  }

  declare interface VkImageSubresourceLayersInitializer {
    /**
     * is a combination of 'VkImageAspectFlagBits', selecting the color, depth and/or stencil aspects to be copied.
     */
    aspectMask?: VkImageAspectFlagBits

    /**
     * is the mipmap level to copy from.
     */
    mipLevel?: number

    /**
     *
     */
    baseArrayLayer?: number

    /**
     * are the starting layer and number of layers to copy.
     */
    layerCount?: number
  }

  declare interface VkImageSubresourceLayersConstructor {
    readonly prototype: VkImageSubresourceLayers
    new (
      param?: VkImageSubresourceLayersInitializer | null
    ): VkImageSubresourceLayers

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageSubresourceLayers: VkImageSubresourceLayersConstructor

  /**
   * Structure specifying an image subresource
   */
  interface VkImageSubresource {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkImageAspectFlags' selecting the image _aspect_.
     */
    aspectMask: VkImageAspectFlagBits

    /**
     * selects the mipmap level.
     */
    mipLevel: number

    /**
     * selects the array layer.
     */
    arrayLayer: number
  }

  declare interface VkImageSubresourceInitializer {
    /**
     * is a 'VkImageAspectFlags' selecting the image _aspect_.
     */
    aspectMask?: VkImageAspectFlagBits

    /**
     * selects the mipmap level.
     */
    mipLevel?: number

    /**
     * selects the array layer.
     */
    arrayLayer?: number
  }

  declare interface VkImageSubresourceConstructor {
    readonly prototype: VkImageSubresource
    new (param?: VkImageSubresourceInitializer | null): VkImageSubresource

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageSubresource: VkImageSubresourceConstructor

  /**
   * Structure specifying parameters of a newly created buffer view
   */
  interface VkBufferViewCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is a 'VkBuffer' on which the view will be created.
     */
    buffer: VkBuffer | null

    /**
     * is a 'VkFormat' describing the format of the data elements in the buffer.
     */
    format: VkFormat

    /**
     * is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.
     */
    offset: bigint | number

    /**
     * is a size in bytes of the buffer view. If 'range' is equal to 'VK_WHOLE_SIZE', the range from 'offset' to the end of the buffer is used. If 'VK_WHOLE_SIZE' is used and the remaining size of the buffer is not a multiple of the <<texel-block-size, texel block size>> of 'format', the nearest smaller multiple is used.
     */
    range: bigint | number
  }

  declare interface VkBufferViewCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is a 'VkBuffer' on which the view will be created.
     */
    buffer?: VkBuffer | null

    /**
     * is a 'VkFormat' describing the format of the data elements in the buffer.
     */
    format?: VkFormat

    /**
     * is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.
     */
    offset?: bigint | number

    /**
     * is a size in bytes of the buffer view. If 'range' is equal to 'VK_WHOLE_SIZE', the range from 'offset' to the end of the buffer is used. If 'VK_WHOLE_SIZE' is used and the remaining size of the buffer is not a multiple of the <<texel-block-size, texel block size>> of 'format', the nearest smaller multiple is used.
     */
    range?: bigint | number
  }

  declare interface VkBufferViewCreateInfoConstructor {
    readonly prototype: VkBufferViewCreateInfo
    new (
      param?: VkBufferViewCreateInfoInitializer | null
    ): VkBufferViewCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferViewCreateInfo: VkBufferViewCreateInfoConstructor

  /**
   * Structure specifying the parameters of a newly created buffer object
   */
  interface VkBufferCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is a bitmask of 'VkBufferCreateFlagBits' specifying additional parameters of the buffer.
     */
    flags: VkBufferCreateFlagBits

    /**
     * is the size in bytes of the buffer to be created.
     */
    size: bigint | number

    /**
     * is a bitmask of 'VkBufferUsageFlagBits' specifying allowed usages of the buffer.
     */
    usage: VkBufferUsageFlagBits

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
     */
    sharingMode: VkSharingMode

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount: number

    /**
     * is a list of queue families that will access this buffer (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices: Uint32Array | null
  }

  declare interface VkBufferCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is a bitmask of 'VkBufferCreateFlagBits' specifying additional parameters of the buffer.
     */
    flags?: VkBufferCreateFlagBits

    /**
     * is the size in bytes of the buffer to be created.
     */
    size?: bigint | number

    /**
     * is a bitmask of 'VkBufferUsageFlagBits' specifying allowed usages of the buffer.
     */
    usage?: VkBufferUsageFlagBits

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
     */
    sharingMode?: VkSharingMode

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount?: number

    /**
     * is a list of queue families that will access this buffer (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices?: Uint32Array | null
  }

  declare interface VkBufferCreateInfoConstructor {
    readonly prototype: VkBufferCreateInfo
    new (param?: VkBufferCreateInfoInitializer | null): VkBufferCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBufferCreateInfo: VkBufferCreateInfoConstructor

  /**
   * Structure specifying a copy descriptor set operation
   */
  interface VkCopyDescriptorSet {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     *
     */
    srcSet: VkDescriptorSet | null

    /**
     *
     */
    srcBinding: number

    /**
     * are the source set, binding, and array element, respectively. If the descriptor binding identified by 'srcSet' and 'srcBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'srcArrayElement' specifies the starting byte offset within the binding to copy from.
     */
    srcArrayElement: number

    /**
     *
     */
    dstSet: VkDescriptorSet | null

    /**
     *
     */
    dstBinding: number

    /**
     *
     */
    dstArrayElement: number

    /**
     *
     */
    descriptorCount: number
  }

  declare interface VkCopyDescriptorSetInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     *
     */
    srcSet?: VkDescriptorSet | null

    /**
     *
     */
    srcBinding?: number

    /**
     * are the source set, binding, and array element, respectively. If the descriptor binding identified by 'srcSet' and 'srcBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'srcArrayElement' specifies the starting byte offset within the binding to copy from.
     */
    srcArrayElement?: number

    /**
     *
     */
    dstSet?: VkDescriptorSet | null

    /**
     *
     */
    dstBinding?: number

    /**
     *
     */
    dstArrayElement?: number

    /**
     *
     */
    descriptorCount?: number
  }

  declare interface VkCopyDescriptorSetConstructor {
    readonly prototype: VkCopyDescriptorSet
    new (param?: VkCopyDescriptorSetInitializer | null): VkCopyDescriptorSet

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkCopyDescriptorSet: VkCopyDescriptorSetConstructor

  /**
   * Structure specifying the parameters of a descriptor set write operation
   */
  interface VkWriteDescriptorSet {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the destination descriptor set to update.
     */
    dstSet: VkDescriptorSet | null

    /**
     * is the descriptor binding within that set.
     */
    dstBinding: number

    /**
     * is the starting element in that array. If the descriptor binding identified by 'dstSet' and 'dstBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'dstArrayElement' specifies the starting byte offset within the binding.
     */
    dstArrayElement: number

    /**
     *
     */
    descriptorCount: number

    /**
     *
     */
    descriptorType: VkDescriptorType

    /**
     *
     */
    pImageInfo: VkDescriptorImageInfo[] | null

    /**
     *
     */
    pBufferInfo: VkDescriptorBufferInfo[] | null

    /**
     *
     */
    pTexelBufferView: VkBufferView[] | null
  }

  declare interface VkWriteDescriptorSetInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the destination descriptor set to update.
     */
    dstSet?: VkDescriptorSet | null

    /**
     * is the descriptor binding within that set.
     */
    dstBinding?: number

    /**
     * is the starting element in that array. If the descriptor binding identified by 'dstSet' and 'dstBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'dstArrayElement' specifies the starting byte offset within the binding.
     */
    dstArrayElement?: number

    /**
     *
     */
    descriptorCount?: number

    /**
     *
     */
    descriptorType?: VkDescriptorType

    /**
     *
     */
    pImageInfo?: VkDescriptorImageInfo[] | null

    /**
     *
     */
    pBufferInfo?: VkDescriptorBufferInfo[] | null

    /**
     *
     */
    pTexelBufferView?: VkBufferView[] | null
  }

  declare interface VkWriteDescriptorSetConstructor {
    readonly prototype: VkWriteDescriptorSet
    new (param?: VkWriteDescriptorSetInitializer | null): VkWriteDescriptorSet

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkWriteDescriptorSet: VkWriteDescriptorSetConstructor

  /**
   * Structure specifying descriptor image info
   */
  interface VkDescriptorImageInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a sampler handle, and is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLER' and 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' if the binding being updated does not use immutable samplers.
     */
    sampler: VkSampler | null

    /**
     * is an image view handle, and is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE', 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE', 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', and 'VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT'.
     */
    imageView: VkImageView | null

    /**
     * is the layout that the image subresources accessible from 'imageView' will be in at the time this descriptor is accessed. 'imageLayout' is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE', 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE', 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', and 'VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT'.
     */
    imageLayout: VkImageLayout
  }

  declare interface VkDescriptorImageInfoInitializer {
    /**
     * is a sampler handle, and is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLER' and 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' if the binding being updated does not use immutable samplers.
     */
    sampler?: VkSampler | null

    /**
     * is an image view handle, and is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE', 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE', 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', and 'VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT'.
     */
    imageView?: VkImageView | null

    /**
     * is the layout that the image subresources accessible from 'imageView' will be in at the time this descriptor is accessed. 'imageLayout' is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE', 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE', 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', and 'VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT'.
     */
    imageLayout?: VkImageLayout
  }

  declare interface VkDescriptorImageInfoConstructor {
    readonly prototype: VkDescriptorImageInfo
    new (param?: VkDescriptorImageInfoInitializer | null): VkDescriptorImageInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorImageInfo: VkDescriptorImageInfoConstructor

  /**
   * Structure specifying descriptor buffer info
   */
  interface VkDescriptorBufferInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the buffer resource.
     */
    buffer: VkBuffer | null

    /**
     *
     */
    offset: bigint | number

    /**
     * is the size in bytes that is used for this descriptor update, or 'VK_WHOLE_SIZE' to use the range from 'offset' to the end of the buffer.
     */
    range: bigint | number
  }

  declare interface VkDescriptorBufferInfoInitializer {
    /**
     * is the buffer resource.
     */
    buffer?: VkBuffer | null

    /**
     *
     */
    offset?: bigint | number

    /**
     * is the size in bytes that is used for this descriptor update, or 'VK_WHOLE_SIZE' to use the range from 'offset' to the end of the buffer.
     */
    range?: bigint | number
  }

  declare interface VkDescriptorBufferInfoConstructor {
    readonly prototype: VkDescriptorBufferInfo
    new (
      param?: VkDescriptorBufferInfoInitializer | null
    ): VkDescriptorBufferInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDescriptorBufferInfo: VkDescriptorBufferInfoConstructor

  /**
   * Structure specifying an image format properties
   */
  interface VkImageFormatProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * are the maximum image dimensions. See the <<features-extentperimagetype,Allowed Extent Values>> section below for how these values are constrained by 'type'.
     */
    readonly maxExtent: VkExtent3D | null

    /**
     * is the maximum number of mipmap levels. 'maxMipLevels' 'must' be equal to the number of levels in the complete mipmap chain based on the [eq]#'maxExtent.width'#, [eq]#'maxExtent.height'#, and [eq]#'maxExtent.depth'#, except when one of the following conditions is true, in which case it 'may' instead be `1`:
     */
    readonly maxMipLevels: number

    /**
     *
     */
    readonly maxArrayLayers: number

    /**
     *
     */
    readonly sampleCounts: VkSampleCountFlagBits

    /**
     *
     */
    readonly maxResourceSize: bigint | number
  }

  declare interface VkImageFormatPropertiesInitializer {
    /**
     * are the maximum image dimensions. See the <<features-extentperimagetype,Allowed Extent Values>> section below for how these values are constrained by 'type'.
     */
    readonly maxExtent?: VkExtent3D | null

    /**
     * is the maximum number of mipmap levels. 'maxMipLevels' 'must' be equal to the number of levels in the complete mipmap chain based on the [eq]#'maxExtent.width'#, [eq]#'maxExtent.height'#, and [eq]#'maxExtent.depth'#, except when one of the following conditions is true, in which case it 'may' instead be `1`:
     */
    readonly maxMipLevels?: number

    /**
     *
     */
    readonly maxArrayLayers?: number

    /**
     *
     */
    readonly sampleCounts?: VkSampleCountFlagBits

    /**
     *
     */
    readonly maxResourceSize?: bigint | number
  }

  declare interface VkImageFormatPropertiesConstructor {
    readonly prototype: VkImageFormatProperties
    new (
      param?: VkImageFormatPropertiesInitializer | null
    ): VkImageFormatProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkImageFormatProperties: VkImageFormatPropertiesConstructor

  /**
   * Structure specifying image format properties
   */
  interface VkFormatProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_LINEAR'.
     */
    readonly linearTilingFeatures: VkFormatFeatureFlagBits

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_OPTIMAL'.
     */
    readonly optimalTilingFeatures: VkFormatFeatureFlagBits

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by buffers.
     */
    readonly bufferFeatures: VkFormatFeatureFlagBits
  }

  declare interface VkFormatPropertiesInitializer {
    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_LINEAR'.
     */
    readonly linearTilingFeatures?: VkFormatFeatureFlagBits

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_OPTIMAL'.
     */
    readonly optimalTilingFeatures?: VkFormatFeatureFlagBits

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by buffers.
     */
    readonly bufferFeatures?: VkFormatFeatureFlagBits
  }

  declare interface VkFormatPropertiesConstructor {
    readonly prototype: VkFormatProperties
    new (param?: VkFormatPropertiesInitializer | null): VkFormatProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkFormatProperties: VkFormatPropertiesConstructor

  /**
   * Structure specifying a mapped memory range
   */
  interface VkMappedMemoryRange {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the memory object to which this range belongs.
     */
    memory: VkDeviceMemory | null

    /**
     * is the zero-based byte offset from the beginning of the memory object.
     */
    offset: bigint | number

    /**
     *
     */
    size: bigint | number
  }

  declare interface VkMappedMemoryRangeInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the memory object to which this range belongs.
     */
    memory?: VkDeviceMemory | null

    /**
     * is the zero-based byte offset from the beginning of the memory object.
     */
    offset?: bigint | number

    /**
     *
     */
    size?: bigint | number
  }

  declare interface VkMappedMemoryRangeConstructor {
    readonly prototype: VkMappedMemoryRange
    new (param?: VkMappedMemoryRangeInitializer | null): VkMappedMemoryRange

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMappedMemoryRange: VkMappedMemoryRangeConstructor

  /**
   * Structure specifying a memory heap
   */
  interface VkMemoryHeap {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the total memory size in bytes in the heap.
     */
    readonly size: bigint | number

    /**
     * is a bitmask of 'VkMemoryHeapFlagBits' specifying attribute flags for the heap.
     */
    readonly flags: VkMemoryHeapFlagBits
  }

  declare interface VkMemoryHeapInitializer {
    /**
     * is the total memory size in bytes in the heap.
     */
    readonly size?: bigint | number

    /**
     * is a bitmask of 'VkMemoryHeapFlagBits' specifying attribute flags for the heap.
     */
    readonly flags?: VkMemoryHeapFlagBits
  }

  declare interface VkMemoryHeapConstructor {
    readonly prototype: VkMemoryHeap
    new (param?: VkMemoryHeapInitializer | null): VkMemoryHeap

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryHeap: VkMemoryHeapConstructor

  /**
   * Structure specifying memory type
   */
  interface VkMemoryType {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkMemoryPropertyFlagBits' of properties for this memory type.
     */
    readonly propertyFlags: VkMemoryPropertyFlagBits

    /**
     * describes which memory heap this memory type corresponds to, and 'must' be less than 'memoryHeapCount' from the 'VkPhysicalDeviceMemoryProperties' structure.
     */
    readonly heapIndex: number
  }

  declare interface VkMemoryTypeInitializer {
    /**
     * is a bitmask of 'VkMemoryPropertyFlagBits' of properties for this memory type.
     */
    readonly propertyFlags?: VkMemoryPropertyFlagBits

    /**
     * describes which memory heap this memory type corresponds to, and 'must' be less than 'memoryHeapCount' from the 'VkPhysicalDeviceMemoryProperties' structure.
     */
    readonly heapIndex?: number
  }

  declare interface VkMemoryTypeConstructor {
    readonly prototype: VkMemoryType
    new (param?: VkMemoryTypeInitializer | null): VkMemoryType

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryType: VkMemoryTypeConstructor

  /**
   * Structure specifying sparse image memory requirements
   */
  interface VkSparseImageMemoryRequirements {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly formatProperties: VkSparseImageFormatProperties | null

    /**
     * is the first mip level at which image subresources are included in the mip tail region.
     */
    readonly imageMipTailFirstLod: number

    /**
     * is the memory size (in bytes) of the mip tail region. If 'formatProperties.flags' contains 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT', this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
     */
    readonly imageMipTailSize: bigint | number

    /**
     * is the opaque memory offset used with 'VkSparseImageOpaqueMemoryBindInfo' to bind the mip tail region(s).
     */
    readonly imageMipTailOffset: bigint | number

    /**
     * is the offset stride between each array-layer's mip tail, if 'formatProperties.flags' does not contain 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT' (otherwise the value is 'undefined').
     */
    readonly imageMipTailStride: bigint | number
  }

  declare interface VkSparseImageMemoryRequirementsInitializer {
    /**
     *
     */
    readonly formatProperties?: VkSparseImageFormatProperties | null

    /**
     * is the first mip level at which image subresources are included in the mip tail region.
     */
    readonly imageMipTailFirstLod?: number

    /**
     * is the memory size (in bytes) of the mip tail region. If 'formatProperties.flags' contains 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT', this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
     */
    readonly imageMipTailSize?: bigint | number

    /**
     * is the opaque memory offset used with 'VkSparseImageOpaqueMemoryBindInfo' to bind the mip tail region(s).
     */
    readonly imageMipTailOffset?: bigint | number

    /**
     * is the offset stride between each array-layer's mip tail, if 'formatProperties.flags' does not contain 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT' (otherwise the value is 'undefined').
     */
    readonly imageMipTailStride?: bigint | number
  }

  declare interface VkSparseImageMemoryRequirementsConstructor {
    readonly prototype: VkSparseImageMemoryRequirements
    new (
      param?: VkSparseImageMemoryRequirementsInitializer | null
    ): VkSparseImageMemoryRequirements

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageMemoryRequirements: VkSparseImageMemoryRequirementsConstructor

  /**
   * Structure specifying sparse image format properties
   */
  interface VkSparseImageFormatProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask 'VkImageAspectFlagBits' specifying which aspects of the image the properties apply to.
     */
    readonly aspectMask: VkImageAspectFlagBits

    /**
     * is the width, height, and depth of the sparse image block in texels or compressed texel blocks.
     */
    readonly imageGranularity: VkExtent3D | null

    /**
     * is a bitmask of 'VkSparseImageFormatFlagBits' specifying additional information about the sparse resource.
     */
    readonly flags: VkSparseImageFormatFlagBits
  }

  declare interface VkSparseImageFormatPropertiesInitializer {
    /**
     * is a bitmask 'VkImageAspectFlagBits' specifying which aspects of the image the properties apply to.
     */
    readonly aspectMask?: VkImageAspectFlagBits

    /**
     * is the width, height, and depth of the sparse image block in texels or compressed texel blocks.
     */
    readonly imageGranularity?: VkExtent3D | null

    /**
     * is a bitmask of 'VkSparseImageFormatFlagBits' specifying additional information about the sparse resource.
     */
    readonly flags?: VkSparseImageFormatFlagBits
  }

  declare interface VkSparseImageFormatPropertiesConstructor {
    readonly prototype: VkSparseImageFormatProperties
    new (
      param?: VkSparseImageFormatPropertiesInitializer | null
    ): VkSparseImageFormatProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkSparseImageFormatProperties: VkSparseImageFormatPropertiesConstructor

  /**
   * Structure specifying memory requirements
   */
  interface VkMemoryRequirements {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the size, in bytes, of the memory allocation 'required' for the resource.
     */
    readonly size: bigint | number

    /**
     * is the alignment, in bytes, of the offset within the allocation 'required' for the resource.
     */
    readonly alignment: bigint | number

    /**
     * is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the 'VkPhysicalDeviceMemoryProperties' structure for the physical device is supported for the resource.
     */
    readonly memoryTypeBits: number
  }

  declare interface VkMemoryRequirementsInitializer {
    /**
     * is the size, in bytes, of the memory allocation 'required' for the resource.
     */
    readonly size?: bigint | number

    /**
     * is the alignment, in bytes, of the offset within the allocation 'required' for the resource.
     */
    readonly alignment?: bigint | number

    /**
     * is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the 'VkPhysicalDeviceMemoryProperties' structure for the physical device is supported for the resource.
     */
    readonly memoryTypeBits?: number
  }

  declare interface VkMemoryRequirementsConstructor {
    readonly prototype: VkMemoryRequirements
    new (param?: VkMemoryRequirementsInitializer | null): VkMemoryRequirements

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryRequirements: VkMemoryRequirementsConstructor

  /**
   * Structure containing parameters of a memory allocation
   */
  interface VkMemoryAllocateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is the size of the allocation in bytes
     */
    allocationSize: bigint | number

    /**
     * is an index identifying a memory type from the 'memoryTypes' array of the 'VkPhysicalDeviceMemoryProperties' structure
     */
    memoryTypeIndex: number
  }

  declare interface VkMemoryAllocateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is the size of the allocation in bytes
     */
    allocationSize?: bigint | number

    /**
     * is an index identifying a memory type from the 'memoryTypes' array of the 'VkPhysicalDeviceMemoryProperties' structure
     */
    memoryTypeIndex?: number
  }

  declare interface VkMemoryAllocateInfoConstructor {
    readonly prototype: VkMemoryAllocateInfo
    new (param?: VkMemoryAllocateInfoInitializer | null): VkMemoryAllocateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkMemoryAllocateInfo: VkMemoryAllocateInfoConstructor

  /**
   * Structure specifying physical device memory properties
   */
  interface VkPhysicalDeviceMemoryProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the number of valid elements in the 'memoryTypes' array.
     */
    readonly memoryTypeCount: number

    /**
     *
     */
    readonly memoryTypes: VkMemoryType[] | null

    /**
     * is the number of valid elements in the 'memoryHeaps' array.
     */
    readonly memoryHeapCount: number

    /**
     *
     */
    readonly memoryHeaps: VkMemoryHeap[] | null
  }

  declare interface VkPhysicalDeviceMemoryPropertiesInitializer {
    /**
     * is the number of valid elements in the 'memoryTypes' array.
     */
    readonly memoryTypeCount?: number

    /**
     *
     */
    readonly memoryTypes?: VkMemoryType[] | null

    /**
     * is the number of valid elements in the 'memoryHeaps' array.
     */
    readonly memoryHeapCount?: number

    /**
     *
     */
    readonly memoryHeaps?: VkMemoryHeap[] | null
  }

  declare interface VkPhysicalDeviceMemoryPropertiesConstructor {
    readonly prototype: VkPhysicalDeviceMemoryProperties
    new (
      param?: VkPhysicalDeviceMemoryPropertiesInitializer | null
    ): VkPhysicalDeviceMemoryProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceMemoryProperties: VkPhysicalDeviceMemoryPropertiesConstructor

  /**
   * Structure providing information about a queue family
   */
  interface VkQueueFamilyProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a bitmask of 'VkQueueFlagBits' indicating capabilities of the queues in this queue family.
     */
    readonly queueFlags: VkQueueFlagBits

    /**
     * is the unsigned integer count of queues in this queue family. Each queue family 'must' support at least one queue.
     */
    readonly queueCount: number

    /**
     * is the unsigned integer count of meaningful bits in the timestamps written via 'vkCmdWriteTimestamp'. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.
     */
    readonly timestampValidBits: number

    /**
     * is the minimum granularity supported for image transfer operations on the queues in this queue family.
     */
    readonly minImageTransferGranularity: VkExtent3D | null
  }

  declare interface VkQueueFamilyPropertiesInitializer {
    /**
     * is a bitmask of 'VkQueueFlagBits' indicating capabilities of the queues in this queue family.
     */
    readonly queueFlags?: VkQueueFlagBits

    /**
     * is the unsigned integer count of queues in this queue family. Each queue family 'must' support at least one queue.
     */
    readonly queueCount?: number

    /**
     * is the unsigned integer count of meaningful bits in the timestamps written via 'vkCmdWriteTimestamp'. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.
     */
    readonly timestampValidBits?: number

    /**
     * is the minimum granularity supported for image transfer operations on the queues in this queue family.
     */
    readonly minImageTransferGranularity?: VkExtent3D | null
  }

  declare interface VkQueueFamilyPropertiesConstructor {
    readonly prototype: VkQueueFamilyProperties
    new (
      param?: VkQueueFamilyPropertiesInitializer | null
    ): VkQueueFamilyProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkQueueFamilyProperties: VkQueueFamilyPropertiesConstructor

  /**
   * Structure specifying parameters of a newly created instance
   */
  interface VkInstanceCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is <i>null</i> or a reference to a 'VkApplicationInfo' structure. If not <i>null</i>, this information helps implementations recognize behavior inherent to classes of applications. 'VkApplicationInfo' is defined in detail below.
     */
    pApplicationInfo: VkApplicationInfo | null

    /**
     * is the number of global layers to enable.
     */
    enabledLayerCount: number

    /**
     * is an array of 'enabledLayerCount' strings containing the names of layers to enable for the created instance. See the <<extendingvulkan-layers>> section for further details.
     */
    ppEnabledLayerNames: string[] | null

    /**
     * is the number of global extensions to enable.
     */
    enabledExtensionCount: number

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable.
     */
    ppEnabledExtensionNames: string[] | null
  }

  declare interface VkInstanceCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is <i>null</i> or a reference to a 'VkApplicationInfo' structure. If not <i>null</i>, this information helps implementations recognize behavior inherent to classes of applications. 'VkApplicationInfo' is defined in detail below.
     */
    pApplicationInfo?: VkApplicationInfo | null

    /**
     * is the number of global layers to enable.
     */
    enabledLayerCount?: number

    /**
     * is an array of 'enabledLayerCount' strings containing the names of layers to enable for the created instance. See the <<extendingvulkan-layers>> section for further details.
     */
    ppEnabledLayerNames?: string[] | null

    /**
     * is the number of global extensions to enable.
     */
    enabledExtensionCount?: number

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable.
     */
    ppEnabledExtensionNames?: string[] | null
  }

  declare interface VkInstanceCreateInfoConstructor {
    readonly prototype: VkInstanceCreateInfo
    new (param?: VkInstanceCreateInfoInitializer | null): VkInstanceCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkInstanceCreateInfo: VkInstanceCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created device
   */
  interface VkDeviceCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is reserved for future use.
     */
    flags: number

    /**
     * is the size of the 'pQueueCreateInfos' array. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    queueCreateInfoCount: number

    /**
     * is an array of 'VkDeviceQueueCreateInfo' structures describing the queues that are requested to be created along with the logical device. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    pQueueCreateInfos: VkDeviceQueueCreateInfo[] | null

    /**
     * is deprecated and ignored.
     */
    enabledLayerCount: number

    /**
     * is deprecated and ignored. See <<extendingvulkan-layers-devicelayerdeprecation>>.
     */
    ppEnabledLayerNames: string[] | null

    /**
     * is the number of device extensions to enable.
     */
    enabledExtensionCount: number

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable for the created device. See the <<extendingvulkan-extensions>> section for further details.
     */
    ppEnabledExtensionNames: string[] | null

    /**
     * is <i>null</i> or a reference to a 'VkPhysicalDeviceFeatures' structure containing boolean indicators of all the features to be enabled. Refer to the <<features,Features>> section for further details.
     */
    pEnabledFeatures: VkPhysicalDeviceFeatures | null
  }

  declare interface VkDeviceCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is reserved for future use.
     */
    flags?: number

    /**
     * is the size of the 'pQueueCreateInfos' array. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    queueCreateInfoCount?: number

    /**
     * is an array of 'VkDeviceQueueCreateInfo' structures describing the queues that are requested to be created along with the logical device. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    pQueueCreateInfos?: VkDeviceQueueCreateInfo[] | null

    /**
     * is deprecated and ignored.
     */
    enabledLayerCount?: number

    /**
     * is deprecated and ignored. See <<extendingvulkan-layers-devicelayerdeprecation>>.
     */
    ppEnabledLayerNames?: string[] | null

    /**
     * is the number of device extensions to enable.
     */
    enabledExtensionCount?: number

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable for the created device. See the <<extendingvulkan-extensions>> section for further details.
     */
    ppEnabledExtensionNames?: string[] | null

    /**
     * is <i>null</i> or a reference to a 'VkPhysicalDeviceFeatures' structure containing boolean indicators of all the features to be enabled. Refer to the <<features,Features>> section for further details.
     */
    pEnabledFeatures?: VkPhysicalDeviceFeatures | null
  }

  declare interface VkDeviceCreateInfoConstructor {
    readonly prototype: VkDeviceCreateInfo
    new (param?: VkDeviceCreateInfoInitializer | null): VkDeviceCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceCreateInfo: VkDeviceCreateInfoConstructor

  /**
   * Structure specifying parameters of a newly created device queue
   */
  interface VkDeviceQueueCreateInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.ifndef::VK_VERSION_1_1[]
     */
    pNext: null

    /**
     * is a bitmask indicating behavior of the queue.
     */
    flags: VkDeviceQueueCreateFlagBits

    /**
     *
     */
    queueFamilyIndex: number

    /**
     *
     */
    queueCount: number

    /**
     *
     */
    pQueuePriorities: Float32Array | null
  }

  declare interface VkDeviceQueueCreateInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.ifndef::VK_VERSION_1_1[]
     */
    pNext?: null

    /**
     * is a bitmask indicating behavior of the queue.
     */
    flags?: VkDeviceQueueCreateFlagBits

    /**
     *
     */
    queueFamilyIndex?: number

    /**
     *
     */
    queueCount?: number

    /**
     *
     */
    pQueuePriorities?: Float32Array | null
  }

  declare interface VkDeviceQueueCreateInfoConstructor {
    readonly prototype: VkDeviceQueueCreateInfo
    new (
      param?: VkDeviceQueueCreateInfoInitializer | null
    ): VkDeviceQueueCreateInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkDeviceQueueCreateInfo: VkDeviceQueueCreateInfoConstructor

  /**
   * Structure containing callback function references for memory allocation
   */
  interface VkAllocationCallbacks {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in 'VkAllocationCallbacks' are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value 'can' vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.
     */
    pUserData: ArrayBuffer | null

    /**
     * is a 'PFN_vkAllocationFunction' reference to an application-defined memory allocation function.
     */
    pfnAllocation: vkAllocationFunction | null

    /**
     * is a 'PFN_vkReallocationFunction' reference to an application-defined memory reallocation function.
     */
    pfnReallocation: vkReallocationFunction | null

    /**
     * is a 'PFN_vkFreeFunction' reference to an application-defined memory free function.
     */
    pfnFree: vkFreeFunction | null

    /**
     * is a 'PFN_vkInternalAllocationNotification' reference to an application-defined function that is called by the implementation when the implementation makes internal allocations.
     */
    pfnInternalAllocation: vkInternalAllocationNotification | null

    /**
     * is a 'PFN_vkInternalFreeNotification' reference to an application-defined function that is called by the implementation when the implementation frees internal allocations.
     */
    pfnInternalFree: vkInternalFreeNotification | null
  }

  declare interface VkAllocationCallbacksInitializer {
    /**
     * is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in 'VkAllocationCallbacks' are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value 'can' vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.
     */
    pUserData?: ArrayBuffer | null

    /**
     * is a 'PFN_vkAllocationFunction' reference to an application-defined memory allocation function.
     */
    pfnAllocation?: vkAllocationFunction | null

    /**
     * is a 'PFN_vkReallocationFunction' reference to an application-defined memory reallocation function.
     */
    pfnReallocation?: vkReallocationFunction | null

    /**
     * is a 'PFN_vkFreeFunction' reference to an application-defined memory free function.
     */
    pfnFree?: vkFreeFunction | null

    /**
     * is a 'PFN_vkInternalAllocationNotification' reference to an application-defined function that is called by the implementation when the implementation makes internal allocations.
     */
    pfnInternalAllocation?: vkInternalAllocationNotification | null

    /**
     * is a 'PFN_vkInternalFreeNotification' reference to an application-defined function that is called by the implementation when the implementation frees internal allocations.
     */
    pfnInternalFree?: vkInternalFreeNotification | null
  }

  declare interface VkAllocationCallbacksConstructor {
    readonly prototype: VkAllocationCallbacks
    new (param?: VkAllocationCallbacksInitializer | null): VkAllocationCallbacks

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkAllocationCallbacks: VkAllocationCallbacksConstructor

  /**
   * Structure specifying application info
   */
  interface VkApplicationInfo {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the type of this structure.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null

    /**
     * is <i>null</i> or is a reference to a string containing the name of the application.
     */
    pApplicationName: string | null

    /**
     * is a number variable containing the developer-supplied version number of the application.
     */
    applicationVersion: number

    /**
     * is <i>null</i> or is a reference to a string containing the name of the engine (if any) used to create the application.
     */
    pEngineName: string | null

    /**
     * is a number variable containing the developer-supplied version number of the engine used to create the application.ifndef::VK_VERSION_1_1[]
     */
    engineVersion: number

    /**
     * 'must' be the highest version of Vulkan that the application is designed to use, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    apiVersion: number
  }

  declare interface VkApplicationInfoInitializer {
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null

    /**
     * is <i>null</i> or is a reference to a string containing the name of the application.
     */
    pApplicationName?: string | null

    /**
     * is a number variable containing the developer-supplied version number of the application.
     */
    applicationVersion?: number

    /**
     * is <i>null</i> or is a reference to a string containing the name of the engine (if any) used to create the application.
     */
    pEngineName?: string | null

    /**
     * is a number variable containing the developer-supplied version number of the engine used to create the application.ifndef::VK_VERSION_1_1[]
     */
    engineVersion?: number

    /**
     * 'must' be the highest version of Vulkan that the application is designed to use, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    apiVersion?: number
  }

  declare interface VkApplicationInfoConstructor {
    readonly prototype: VkApplicationInfo
    new (param?: VkApplicationInfoInitializer | null): VkApplicationInfo

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkApplicationInfo: VkApplicationInfoConstructor

  /**
   * Structure specifying layer properties
   */
  interface VkLayerProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly layerName: string | null

    /**
     * is the Vulkan version the layer was written to, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly specVersion: number

    /**
     * is the version of this layer. It is a number, increasing with backward compatible changes.
     */
    readonly implementationVersion: number

    /**
     *
     */
    readonly description: string | null
  }

  declare interface VkLayerPropertiesInitializer {
    /**
     *
     */
    readonly layerName?: string | null

    /**
     * is the Vulkan version the layer was written to, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly specVersion?: number

    /**
     * is the version of this layer. It is a number, increasing with backward compatible changes.
     */
    readonly implementationVersion?: number

    /**
     *
     */
    readonly description?: string | null
  }

  declare interface VkLayerPropertiesConstructor {
    readonly prototype: VkLayerProperties
    new (param?: VkLayerPropertiesInitializer | null): VkLayerProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkLayerProperties: VkLayerPropertiesConstructor

  /**
   * Structure specifying an extension properties
   */
  interface VkExtensionProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    readonly extensionName: string | null

    /**
     * is the version of this extension. It is a number, incremented with backward compatible changes.
     */
    readonly specVersion: number
  }

  declare interface VkExtensionPropertiesInitializer {
    /**
     *
     */
    readonly extensionName?: string | null

    /**
     * is the version of this extension. It is a number, incremented with backward compatible changes.
     */
    readonly specVersion?: number
  }

  declare interface VkExtensionPropertiesConstructor {
    readonly prototype: VkExtensionProperties
    new (param?: VkExtensionPropertiesInitializer | null): VkExtensionProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExtensionProperties: VkExtensionPropertiesConstructor

  /**
   * Structure specifying physical device properties
   */
  interface VkPhysicalDeviceProperties {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the version of Vulkan supported by the device, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly apiVersion: number

    /**
     * is the vendor-specified version of the driver.
     */
    readonly driverVersion: number

    /**
     * is a unique identifier for the _vendor_ (see below) of the physical device.
     */
    readonly vendorID: number

    /**
     * is a unique identifier for the physical device among devices available from the vendor.
     */
    readonly deviceID: number

    /**
     * is a 'VkPhysicalDeviceType' specifying the type of device.
     */
    readonly deviceType: VkPhysicalDeviceType

    /**
     *
     */
    readonly deviceName: string | null

    /**
     *
     */
    readonly pipelineCacheUUID: number[] | null

    /**
     * is the 'VkPhysicalDeviceLimits' structure specifying device-specific limits of the physical device. See <<limits,Limits>> for details.
     */
    readonly limits: VkPhysicalDeviceLimits | null

    /**
     * is the 'VkPhysicalDeviceSparseProperties' structure specifying various sparse related properties of the physical device. See <<sparsememory-physicalprops,Sparse Properties>> for details.
     */
    readonly sparseProperties: VkPhysicalDeviceSparseProperties | null
  }

  declare interface VkPhysicalDevicePropertiesInitializer {
    /**
     * is the version of Vulkan supported by the device, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly apiVersion?: number

    /**
     * is the vendor-specified version of the driver.
     */
    readonly driverVersion?: number

    /**
     * is a unique identifier for the _vendor_ (see below) of the physical device.
     */
    readonly vendorID?: number

    /**
     * is a unique identifier for the physical device among devices available from the vendor.
     */
    readonly deviceID?: number

    /**
     * is a 'VkPhysicalDeviceType' specifying the type of device.
     */
    readonly deviceType?: VkPhysicalDeviceType

    /**
     *
     */
    readonly deviceName?: string | null

    /**
     *
     */
    readonly pipelineCacheUUID?: number[] | null

    /**
     * is the 'VkPhysicalDeviceLimits' structure specifying device-specific limits of the physical device. See <<limits,Limits>> for details.
     */
    readonly limits?: VkPhysicalDeviceLimits | null

    /**
     * is the 'VkPhysicalDeviceSparseProperties' structure specifying various sparse related properties of the physical device. See <<sparsememory-physicalprops,Sparse Properties>> for details.
     */
    readonly sparseProperties?: VkPhysicalDeviceSparseProperties | null
  }

  declare interface VkPhysicalDevicePropertiesConstructor {
    readonly prototype: VkPhysicalDeviceProperties
    new (
      param?: VkPhysicalDevicePropertiesInitializer | null
    ): VkPhysicalDeviceProperties

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkPhysicalDeviceProperties: VkPhysicalDevicePropertiesConstructor

  /**
   * Structure specifying a color component mapping
   */
  interface VkComponentMapping {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the R component of the output vector.
     */
    r: VkComponentSwizzle

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the G component of the output vector.
     */
    g: VkComponentSwizzle

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the B component of the output vector.
     */
    b: VkComponentSwizzle

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the A component of the output vector.
     */
    a: VkComponentSwizzle
  }

  declare interface VkComponentMappingInitializer {
    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the R component of the output vector.
     */
    r?: VkComponentSwizzle

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the G component of the output vector.
     */
    g?: VkComponentSwizzle

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the B component of the output vector.
     */
    b?: VkComponentSwizzle

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the A component of the output vector.
     */
    a?: VkComponentSwizzle
  }

  declare interface VkComponentMappingConstructor {
    readonly prototype: VkComponentMapping
    new (param?: VkComponentMappingInitializer | null): VkComponentMapping

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkComponentMapping: VkComponentMappingConstructor

  /**
   * Structure specifying a clear rectangle
   */
  interface VkClearRect {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the two-dimensional region to be cleared.
     */
    rect: VkRect2D | null

    /**
     * is the first layer to be cleared.
     */
    baseArrayLayer: number

    /**
     * is the number of layers to clear.
     */
    layerCount: number
  }

  declare interface VkClearRectInitializer {
    /**
     * is the two-dimensional region to be cleared.
     */
    rect?: VkRect2D | null

    /**
     * is the first layer to be cleared.
     */
    baseArrayLayer?: number

    /**
     * is the number of layers to clear.
     */
    layerCount?: number
  }

  declare interface VkClearRectConstructor {
    readonly prototype: VkClearRect
    new (param?: VkClearRectInitializer | null): VkClearRect

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkClearRect: VkClearRectConstructor

  /**
   * Structure specifying a two-dimensional subregion
   */
  interface VkRect2D {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is a 'VkOffset2D' specifying the rectangle offset.
     */
    offset: VkOffset2D | null

    /**
     * is a 'VkExtent2D' specifying the rectangle extent.
     */
    extent: VkExtent2D | null
  }

  declare interface VkRect2DInitializer {
    /**
     * is a 'VkOffset2D' specifying the rectangle offset.
     */
    offset?: VkOffset2D | null

    /**
     * is a 'VkExtent2D' specifying the rectangle extent.
     */
    extent?: VkExtent2D | null
  }

  declare interface VkRect2DConstructor {
    readonly prototype: VkRect2D
    new (param?: VkRect2DInitializer | null): VkRect2D

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkRect2D: VkRect2DConstructor

  /**
   * Structure specifying a viewport
   */
  interface VkViewport {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     *
     */
    x: number

    /**
     * are the viewport's upper left corner [eq]#(x,y)#.
     */
    y: number

    /**
     *
     */
    width: number

    /**
     * are the viewport's width and height, respectively.
     */
    height: number

    /**
     *
     */
    minDepth: number

    /**
     * are the depth range for the viewport. It is valid for 'minDepth' to be greater than or equal to 'maxDepth'.
     */
    maxDepth: number
  }

  declare interface VkViewportInitializer {
    /**
     *
     */
    x?: number

    /**
     * are the viewport's upper left corner [eq]#(x,y)#.
     */
    y?: number

    /**
     *
     */
    width?: number

    /**
     * are the viewport's width and height, respectively.
     */
    height?: number

    /**
     *
     */
    minDepth?: number

    /**
     * are the depth range for the viewport. It is valid for 'minDepth' to be greater than or equal to 'maxDepth'.
     */
    maxDepth?: number
  }

  declare interface VkViewportConstructor {
    readonly prototype: VkViewport
    new (param?: VkViewportInitializer | null): VkViewport

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkViewport: VkViewportConstructor

  /**
   * Structure specifying a three-dimensional extent
   */
  interface VkExtent3D {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the width of the extent.
     */
    width: number

    /**
     * is the height of the extent.
     */
    height: number

    /**
     * is the depth of the extent.
     */
    depth: number
  }

  declare interface VkExtent3DInitializer {
    /**
     * is the width of the extent.
     */
    width?: number

    /**
     * is the height of the extent.
     */
    height?: number

    /**
     * is the depth of the extent.
     */
    depth?: number
  }

  declare interface VkExtent3DConstructor {
    readonly prototype: VkExtent3D
    new (param?: VkExtent3DInitializer | null): VkExtent3D

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExtent3D: VkExtent3DConstructor

  /**
   * Structure specifying a two-dimensional extent
   */
  interface VkExtent2D {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the width of the extent.
     */
    width: number

    /**
     * is the height of the extent.
     */
    height: number
  }

  declare interface VkExtent2DInitializer {
    /**
     * is the width of the extent.
     */
    width?: number

    /**
     * is the height of the extent.
     */
    height?: number
  }

  declare interface VkExtent2DConstructor {
    readonly prototype: VkExtent2D
    new (param?: VkExtent2DInitializer | null): VkExtent2D

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkExtent2D: VkExtent2DConstructor

  /**
   * Structure specifying a three-dimensional offset
   */
  interface VkOffset3D {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the x offset.
     */
    x: number

    /**
     * is the y offset.
     */
    y: number

    /**
     * is the z offset.
     */
    z: number
  }

  declare interface VkOffset3DInitializer {
    /**
     * is the x offset.
     */
    x?: number

    /**
     * is the y offset.
     */
    y?: number

    /**
     * is the z offset.
     */
    z?: number
  }

  declare interface VkOffset3DConstructor {
    readonly prototype: VkOffset3D
    new (param?: VkOffset3DInitializer | null): VkOffset3D

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkOffset3D: VkOffset3DConstructor

  /**
   * Structure specifying a two-dimensional offset
   */
  interface VkOffset2D {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the x offset.
     */
    x: number

    /**
     * is the y offset.
     */
    y: number
  }

  declare interface VkOffset2DInitializer {
    /**
     * is the x offset.
     */
    x?: number

    /**
     * is the y offset.
     */
    y?: number
  }

  declare interface VkOffset2DConstructor {
    readonly prototype: VkOffset2D
    new (param?: VkOffset2DInitializer | null): VkOffset2D

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkOffset2D: VkOffset2DConstructor

  /**
   * Base structure for a read-only reference chain
   */
  interface VkBaseInStructure {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the structure type of the structure being iterated through.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext: VkBaseInStructure | null
  }

  declare interface VkBaseInStructureInitializer {
    /**
     * is the structure type of the structure being iterated through.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext?: VkBaseInStructure | null
  }

  declare interface VkBaseInStructureConstructor {
    readonly prototype: VkBaseInStructure
    new (param?: VkBaseInStructureInitializer | null): VkBaseInStructure

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBaseInStructure: VkBaseInStructureConstructor

  /**
   * Base structure for a read-only reference chain
   */
  interface VkBaseOutStructure {
    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object

    /**
     * Memory representation of the original vulkan structure instance.
     */
    memoryBuffer: ArrayBuffer

    /**
     * is the structure type of the structure being iterated through.
     */
    sType: VkStructureType

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext: VkBaseOutStructure | null
  }

  declare interface VkBaseOutStructureInitializer {
    /**
     * is the structure type of the structure being iterated through.
     */
    sType?: VkStructureType

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext?: VkBaseOutStructure | null
  }

  declare interface VkBaseOutStructureConstructor {
    readonly prototype: VkBaseOutStructure
    new (param?: VkBaseOutStructureInitializer | null): VkBaseOutStructure

    /**
     * Object describing the memory layout for this structure.
     */
    readonly memoryLayout: object
  }

  declare var VkBaseOutStructure: VkBaseOutStructureConstructor

  /**
   * Create a new Vulkan instance
   * @param pCreateInfo is a reference to a 'VkInstanceCreateInfo' structure controlling creation of the instance.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pInstance references a 'VkInstance' handle in which the resulting instance is returned.
   */
  export function vkCreateInstance(
    pCreateInfo: VkInstanceCreateInfo | null,
    pAllocator: null,
    pInstance: VkInstance | null
  ): VkResult

  /**
   * Destroy an instance of Vulkan
   * @param instance is the handle of the instance to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyInstance(
    instance: VkInstance | null,
    pAllocator: null
  ): void

  /**
   * Enumerates the physical devices accessible to a Vulkan instance
   * @param instance is a handle to a Vulkan instance previously created with 'vkCreateInstance'.
   * @param pPhysicalDeviceCount is a reference to a number related to the number of physical devices available or queried, as described below.
   * @param pPhysicalDevices is either <i>null</i> or a reference to an array of 'VkPhysicalDevice' handles.
   */
  export function vkEnumeratePhysicalDevices(
    instance: VkInstance | null,
    pPhysicalDeviceCount: VkInout | null,
    pPhysicalDevices: VkPhysicalDevice[] | null
  ): VkResult

  /**
   * Return a function reference for a command
   * @param device
   * @param pName
   */
  export function vkGetDeviceProcAddr(
    device: VkDevice | null,
    pName: string | null
  ): void

  /**
   * Return a function reference for a command
   * @param instance is the instance that the function reference will be compatible with, or <i>null</i> for commands not dependent on any instance.
   * @param pName is the name of the command to obtain.
   */
  export function vkGetInstanceProcAddr(
    instance: VkInstance | null,
    pName: string | null
  ): void

  /**
   * Returns properties of a physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pProperties is a reference to a 'VkPhysicalDeviceProperties' structure in which properties are returned.
   */
  export function vkGetPhysicalDeviceProperties(
    physicalDevice: VkPhysicalDevice | null,
    pProperties: VkPhysicalDeviceProperties | null
  ): void

  /**
   * Reports properties of the queues of the specified physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pQueueFamilyPropertyCount is a reference to a number related to the number of queue families available or queried, as described below.
   * @param pQueueFamilyProperties is either <i>null</i> or a reference to an array of 'VkQueueFamilyProperties' structures.
   */
  export function vkGetPhysicalDeviceQueueFamilyProperties(
    physicalDevice: VkPhysicalDevice | null,
    pQueueFamilyPropertyCount: VkInout | null,
    pQueueFamilyProperties: VkQueueFamilyProperties[] | null
  ): void

  /**
   * Reports memory information for the specified physical device
   * @param physicalDevice is the handle to the device to query.
   * @param pMemoryProperties is a reference to a 'VkPhysicalDeviceMemoryProperties' structure in which the properties are returned.
   */
  export function vkGetPhysicalDeviceMemoryProperties(
    physicalDevice: VkPhysicalDevice | null,
    pMemoryProperties: VkPhysicalDeviceMemoryProperties | null
  ): void

  /**
   * Reports capabilities of a physical device
   * @param physicalDevice is the physical device from which to query the supported features.
   * @param pFeatures is a reference to a 'VkPhysicalDeviceFeatures' structure in which the physical device features are returned. For each feature, a value of 'VK_TRUE' specifies that the feature is supported on this physical device, and 'VK_FALSE' specifies that the feature is not supported.
   */
  export function vkGetPhysicalDeviceFeatures(
    physicalDevice: VkPhysicalDevice | null,
    pFeatures: VkPhysicalDeviceFeatures | null
  ): void

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the format properties.
   * @param format is the format whose properties are queried.
   * @param pFormatProperties is a reference to a 'VkFormatProperties' structure in which physical device properties for 'format' are returned.
   */
  export function vkGetPhysicalDeviceFormatProperties(
    physicalDevice: VkPhysicalDevice | null,
    format: VkFormat,
    pFormatProperties: VkFormatProperties | null
  ): void

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the image capabilities.
   * @param format is a 'VkFormat' value specifying the image format, corresponding to 'VkImageCreateInfo'::'format'.
   * @param type is a 'VkImageType' value specifying the image type, corresponding to 'VkImageCreateInfo'::'imageType'.
   * @param tiling is a 'VkImageTiling' value specifying the image tiling, corresponding to 'VkImageCreateInfo'::'tiling'.
   * @param usage is a bitmask of 'VkImageUsageFlagBits' specifying the intended usage of the image, corresponding to 'VkImageCreateInfo'::'usage'.
   * @param flags is a bitmask of 'VkImageCreateFlagBits' specifying additional parameters of the image, corresponding to 'VkImageCreateInfo'::'flags'.
   * @param pImageFormatProperties is a reference to a 'VkImageFormatProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceImageFormatProperties(
    physicalDevice: VkPhysicalDevice | null,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlagBits,
    flags: VkImageCreateFlagBits,
    pImageFormatProperties: VkImageFormatProperties | null
  ): VkResult

  /**
   * Create a new device instance
   * @param physicalDevice 'must' be one of the device handles returned from a call to 'vkEnumeratePhysicalDevices' (see <<devsandqueues-physical-device-enumeration, Physical Device Enumeration>>).
   * @param pCreateInfo is a reference to a 'VkDeviceCreateInfo' structure containing information about how to create the device.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pDevice is a reference to a handle in which the created 'VkDevice' is returned.
   */
  export function vkCreateDevice(
    physicalDevice: VkPhysicalDevice | null,
    pCreateInfo: VkDeviceCreateInfo | null,
    pAllocator: null,
    pDevice: VkDevice | null
  ): VkResult

  /**
   * Destroy a logical device
   * @param device is the logical device to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDevice(
    device: VkDevice | null,
    pAllocator: null
  ): void

  /**
   * Query instance-level version before instance creation
   * @param pApiVersion is a reference to a 'uint32_t', which is the version of Vulkan supported by instance-level functionality, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
   */
  export function vkEnumerateInstanceVersion(
    pApiVersion: VkInout | null
  ): VkResult

  /**
   * Returns up to requested number of global layer properties
   * @param pPropertyCount is a reference to a number related to the number of layer properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkLayerProperties' structures.
   */
  export function vkEnumerateInstanceLayerProperties(
    pPropertyCount: VkInout | null,
    pProperties: VkLayerProperties[] | null
  ): VkResult

  /**
   * Returns up to requested number of global extension properties
   * @param pLayerName is either <i>null</i> or a reference to a string naming the layer to retrieve extensions from.
   * @param pPropertyCount is a reference to a number related to the number of extension properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkExtensionProperties' structures.
   */
  export function vkEnumerateInstanceExtensionProperties(
    pLayerName: string | null,
    pPropertyCount: VkInout | null,
    pProperties: VkExtensionProperties[] | null
  ): VkResult

  /**
   * Returns properties of available physical device layers
   * @param physicalDevice
   * @param pPropertyCount is a reference to a number related to the number of layer properties available or queried.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkLayerProperties' structures.
   */
  export function vkEnumerateDeviceLayerProperties(
    physicalDevice: VkPhysicalDevice | null,
    pPropertyCount: VkInout | null,
    pProperties: VkLayerProperties[] | null
  ): VkResult

  /**
   * Returns properties of available physical device extensions
   * @param physicalDevice is the physical device that will be queried.
   * @param pLayerName is either <i>null</i> or a reference to a string naming the layer to retrieve extensions from.
   * @param pPropertyCount is a reference to a number related to the number of extension properties available or queried, and is treated in the same fashion as the 'vkEnumerateInstanceExtensionProperties'::'pPropertyCount' parameter.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkExtensionProperties' structures.
   */
  export function vkEnumerateDeviceExtensionProperties(
    physicalDevice: VkPhysicalDevice | null,
    pLayerName: string | null,
    pPropertyCount: VkInout | null,
    pProperties: VkExtensionProperties[] | null
  ): VkResult

  /**
   * Get a queue handle from a device
   * @param device is the logical device that owns the queue.
   * @param queueFamilyIndex is the index of the queue family to which the queue belongs.
   * @param queueIndex is the index within this queue family of the queue to retrieve.
   * @param pQueue is a reference to a 'VkQueue' object that will be filled with the handle for the requested queue.
   */
  export function vkGetDeviceQueue(
    device: VkDevice | null,
    queueFamilyIndex: number,
    queueIndex: number,
    pQueue: VkQueue | null
  ): void

  /**
   * Submits a sequence of semaphores or command buffers to a queue
   * @param queue is the queue that the command buffers will be submitted to.
   * @param submitCount
   * @param pSubmits is an array of 'VkSubmitInfo' structures, each specifying a command buffer submission batch.
   * @param fence is an 'optional' handle to a fence to be signaled once all submitted command buffers have completed execution. If 'fence' is not 'VK_NULL_HANDLE', it defines a <<synchronization-fences-signaling, fence signal operation>>.
   */
  export function vkQueueSubmit(
    queue: VkQueue | null,
    submitCount: number,
    pSubmits: VkSubmitInfo[] | null,
    fence: VkFence | null
  ): VkResult

  /**
   * Wait for a queue to become idle
   * @param queue is the queue on which to wait.
   */
  export function vkQueueWaitIdle(queue: VkQueue | null): VkResult

  /**
   * Wait for a device to become idle
   * @param device is the logical device to idle.
   */
  export function vkDeviceWaitIdle(device: VkDevice | null): VkResult

  /**
   * Allocate device memory
   * @param device
   * @param pAllocateInfo
   * @param pAllocator
   * @param pMemory
   */
  export function vkAllocateMemory(
    device: VkDevice | null,
    pAllocateInfo: VkMemoryAllocateInfo | null,
    pAllocator: null,
    pMemory: VkDeviceMemory | null
  ): VkResult

  /**
   * Free device memory
   * @param device is the logical device that owns the memory.
   * @param memory is the 'VkDeviceMemory' object to be freed.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkFreeMemory(
    device: VkDevice | null,
    memory: VkDeviceMemory | null,
    pAllocator: null
  ): void

  /**
   * Map a memory object into application address space
   * @param device is the logical device that owns the memory.
   * @param memory is the 'VkDeviceMemory' object to be mapped.
   * @param offset is a zero-based byte offset from the beginning of the memory object.
   * @param size is the size of the memory range to map, or 'VK_WHOLE_SIZE' to map from 'offset' to the end of the allocation.
   * @param flags is reserved for future use.
   * @param ppData is a reference to a `void
   */
  export function vkMapMemory(
    device: VkDevice | null,
    memory: VkDeviceMemory | null,
    offset: bigint | number,
    size: bigint | number,
    flags: number,
    ppData: VkInoutAddress | null
  ): VkResult

  /**
   * Unmap a previously mapped memory object
   * @param device is the logical device that owns the memory.
   * @param memory is the memory object to be unmapped.
   */
  export function vkUnmapMemory(
    device: VkDevice | null,
    memory: VkDeviceMemory | null
  ): void

  /**
   * Flush mapped memory ranges
   * @param device is the logical device that owns the memory ranges.
   * @param memoryRangeCount
   * @param pMemoryRanges is an array of 'VkMappedMemoryRange' structures describing the memory ranges to flush.
   */
  export function vkFlushMappedMemoryRanges(
    device: VkDevice | null,
    memoryRangeCount: number,
    pMemoryRanges: VkMappedMemoryRange[] | null
  ): VkResult

  /**
   * Invalidate ranges of mapped memory objects
   * @param device is the logical device that owns the memory ranges.
   * @param memoryRangeCount
   * @param pMemoryRanges is an array of 'VkMappedMemoryRange' structures describing the memory ranges to invalidate.
   */
  export function vkInvalidateMappedMemoryRanges(
    device: VkDevice | null,
    memoryRangeCount: number,
    pMemoryRanges: VkMappedMemoryRange[] | null
  ): VkResult

  /**
   * Query the current commitment for a VkDeviceMemory
   * @param device is the logical device that owns the memory.
   * @param memory is the memory object being queried.
   * @param pCommittedMemoryInBytes is a reference to a 'VkDeviceSize' value in which the number of bytes currently committed is returned, on success.
   */
  export function vkGetDeviceMemoryCommitment(
    device: VkDevice | null,
    memory: VkDeviceMemory | null,
    pCommittedMemoryInBytes: VkInoutAddress | null
  ): void

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the buffer.
   * @param buffer is the buffer to query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements' structure in which the memory requirements of the buffer object are returned.
   */
  export function vkGetBufferMemoryRequirements(
    device: VkDevice | null,
    buffer: VkBuffer | null,
    pMemoryRequirements: VkMemoryRequirements | null
  ): void

  /**
   * Bind device memory to a buffer object
   * @param device is the logical device that owns the buffer and memory.
   * @param buffer is the buffer to be attached to memory.
   * @param memory which is to be bound to the buffer. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified buffer.
   * @param memoryOffset
   */
  export function vkBindBufferMemory(
    device: VkDevice | null,
    buffer: VkBuffer | null,
    memory: VkDeviceMemory | null,
    memoryOffset: bigint | number
  ): VkResult

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the image.
   * @param image is the image to query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements' structure in which the memory requirements of the image object are returned.
   */
  export function vkGetImageMemoryRequirements(
    device: VkDevice | null,
    image: VkImage | null,
    pMemoryRequirements: VkMemoryRequirements | null
  ): void

  /**
   * Bind device memory to an image object
   * @param device is the logical device that owns the image and memory.
   * @param image is the image.
   * @param memory which is to be bound to the image. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified image.
   * @param memoryOffset
   */
  export function vkBindImageMemory(
    device: VkDevice | null,
    image: VkImage | null,
    memory: VkDeviceMemory | null,
    memoryOffset: bigint | number
  ): VkResult

  /**
   * Query the memory requirements for a sparse image
   * @param device is the logical device that owns the image.
   * @param image is the 'VkImage' object to get the memory requirements for.
   * @param pSparseMemoryRequirementCount is a reference to a number related to the number of sparse memory requirements available or queried, as described below.
   * @param pSparseMemoryRequirements is either <i>null</i> or a reference to an array of 'VkSparseImageMemoryRequirements' structures.
   */
  export function vkGetImageSparseMemoryRequirements(
    device: VkDevice | null,
    image: VkImage | null,
    pSparseMemoryRequirementCount: VkInout | null,
    pSparseMemoryRequirements: VkSparseImageMemoryRequirements[] | null
  ): void

  /**
   * Retrieve properties of an image format applied to sparse images
   * @param physicalDevice is the physical device from which to query the sparse image capabilities.
   * @param format is the image format.
   * @param type is the dimensionality of image.
   * @param samples is the number of samples per texel as defined in 'VkSampleCountFlagBits'.
   * @param usage is a bitmask describing the intended usage of the image.
   * @param tiling is the tiling arrangement of the texel blocks in memory.
   * @param pPropertyCount is a reference to a number related to the number of sparse format properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkSparseImageFormatProperties' structures.
   */
  export function vkGetPhysicalDeviceSparseImageFormatProperties(
    physicalDevice: VkPhysicalDevice | null,
    format: VkFormat,
    type: VkImageType,
    samples: VkSampleCountFlagBits,
    usage: VkImageUsageFlagBits,
    tiling: VkImageTiling,
    pPropertyCount: VkInout | null,
    pProperties: VkSparseImageFormatProperties[] | null
  ): void

  /**
   * Bind device memory to a sparse resource object
   * @param queue is the queue that the sparse binding operations will be submitted to.
   * @param bindInfoCount
   * @param pBindInfo is an array of 'VkBindSparseInfo' structures, each specifying a sparse binding submission batch.
   * @param fence is an 'optional' handle to a fence to be signaled. If 'fence' is not 'VK_NULL_HANDLE', it defines a <<synchronization-fences-signaling, fence signal operation>>.
   */
  export function vkQueueBindSparse(
    queue: VkQueue | null,
    bindInfoCount: number,
    pBindInfo: VkBindSparseInfo[] | null,
    fence: VkFence | null
  ): VkResult

  /**
   * Create a new fence object
   * @param device is the logical device that creates the fence.
   * @param pCreateInfo is a reference to a 'VkFenceCreateInfo' structure containing information about how the fence is to be created.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFence is a reference to a handle in which the resulting fence object is returned.
   */
  export function vkCreateFence(
    device: VkDevice | null,
    pCreateInfo: VkFenceCreateInfo | null,
    pAllocator: null,
    pFence: VkFence | null
  ): VkResult

  /**
   * Destroy a fence object
   * @param device is the logical device that destroys the fence.
   * @param fence is the handle of the fence to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyFence(
    device: VkDevice | null,
    fence: VkFence | null,
    pAllocator: null
  ): void

  /**
   * Resets one or more fence objects
   * @param device is the logical device that owns the fences.
   * @param fenceCount is the number of fences to reset.
   * @param pFences is an array of fence handles to reset.
   */
  export function vkResetFences(
    device: VkDevice | null,
    fenceCount: number,
    pFences: VkFence[] | null
  ): VkResult

  /**
   * Return the status of a fence
   * @param device is the logical device that owns the fence.
   * @param fence is the handle of the fence to query.
   */
  export function vkGetFenceStatus(
    device: VkDevice | null,
    fence: VkFence | null
  ): VkResult

  /**
   * Wait for one or more fences to become signaled
   * @param device is the logical device that owns the fences.
   * @param fenceCount fence handles.
   * @param pFences
   * @param waitAll is the condition that 'must' be satisfied to successfully unblock the wait. If 'waitAll' is 'VK_TRUE', then the condition is that all fences in 'pFences' are signaled. Otherwise, the condition is that at least one fence in 'pFences' is signaled.
   * @param timeout is the timeout period in units of nanoseconds. 'timeout' is adjusted to the closest value allowed by the implementation-dependent timeout accuracy, which 'may' be substantially longer than one nanosecond, and 'may' be longer than the requested period.
   */
  export function vkWaitForFences(
    device: VkDevice | null,
    fenceCount: number,
    pFences: VkFence[] | null,
    waitAll: boolean,
    timeout: bigint | number
  ): VkResult

  /**
   * Create a new queue semaphore object
   * @param device is the logical device that creates the semaphore.
   * @param pCreateInfo is a reference to a 'VkSemaphoreCreateInfo' structure containing information about how the semaphore is to be created.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pSemaphore is a reference to a handle in which the resulting semaphore object is returned.
   */
  export function vkCreateSemaphore(
    device: VkDevice | null,
    pCreateInfo: VkSemaphoreCreateInfo | null,
    pAllocator: null,
    pSemaphore: VkSemaphore | null
  ): VkResult

  /**
   * Destroy a semaphore object
   * @param device is the logical device that destroys the semaphore.
   * @param semaphore is the handle of the semaphore to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroySemaphore(
    device: VkDevice | null,
    semaphore: VkSemaphore | null,
    pAllocator: null
  ): void

  /**
   * Create a new event object
   * @param device is the logical device that creates the event.
   * @param pCreateInfo is a reference to a 'VkEventCreateInfo' structure containing information about how the event is to be created.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pEvent is a reference to a handle in which the resulting event object is returned.
   */
  export function vkCreateEvent(
    device: VkDevice | null,
    pCreateInfo: VkEventCreateInfo | null,
    pAllocator: null,
    pEvent: VkEvent | null
  ): VkResult

  /**
   * Destroy an event object
   * @param device is the logical device that destroys the event.
   * @param event is the handle of the event to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyEvent(
    device: VkDevice | null,
    event: VkEvent | null,
    pAllocator: null
  ): void

  /**
   * Retrieve the status of an event object
   * @param device is the logical device that owns the event.
   * @param event is the handle of the event to query.
   */
  export function vkGetEventStatus(
    device: VkDevice | null,
    event: VkEvent | null
  ): VkResult

  /**
   * Set an event to signaled state
   * @param device is the logical device that owns the event.
   * @param event is the event to set.
   */
  export function vkSetEvent(
    device: VkDevice | null,
    event: VkEvent | null
  ): VkResult

  /**
   * Reset an event to non-signaled state
   * @param device is the logical device that owns the event.
   * @param event is the event to reset.
   */
  export function vkResetEvent(
    device: VkDevice | null,
    event: VkEvent | null
  ): VkResult

  /**
   * Create a new query pool object
   * @param device is the logical device that creates the query pool.
   * @param pCreateInfo is a reference to a 'VkQueryPoolCreateInfo' structure containing the number and type of queries to be managed by the pool.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pQueryPool is a reference to a 'VkQueryPool' handle in which the resulting query pool object is returned.
   */
  export function vkCreateQueryPool(
    device: VkDevice | null,
    pCreateInfo: VkQueryPoolCreateInfo | null,
    pAllocator: null,
    pQueryPool: VkQueryPool | null
  ): VkResult

  /**
   * Destroy a query pool object
   * @param device is the logical device that destroys the query pool.
   * @param queryPool is the query pool to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyQueryPool(
    device: VkDevice | null,
    queryPool: VkQueryPool | null,
    pAllocator: null
  ): void

  /**
   * Copy results of queries in a query pool to a host memory region
   * @param device is the logical device that owns the query pool.
   * @param queryPool is the query pool managing the queries containing the desired results.
   * @param firstQuery is the initial query index.
   * @param queryCount is the number of queries to read.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written
   * @param stride is the stride in bytes between results for individual queries within 'pData'.
   * @param flags is a bitmask of 'VkQueryResultFlagBits' specifying how and when results are returned.
   */
  export function vkGetQueryPoolResults(
    device: VkDevice | null,
    queryPool: VkQueryPool | null,
    firstQuery: number,
    queryCount: number,
    dataSize: bigint | number,
    pData: ArrayBuffer | null,
    stride: bigint | number,
    flags: VkQueryResultFlagBits
  ): VkResult

  /**
   * Reset queries in a query pool
   * @param device is the logical device that owns the query pool.
   * @param queryPool is the handle of the query pool managing the queries being reset.
   * @param firstQuery is the initial query index to reset.
   * @param queryCount is the number of queries to reset.
   */
  export function vkResetQueryPoolEXT(
    device: VkDevice | null,
    queryPool: VkQueryPool | null,
    firstQuery: number,
    queryCount: number
  ): void

  /**
   * Create a new buffer object
   * @param device is the logical device that creates the buffer object.
   * @param pCreateInfo is a reference to a 'VkBufferCreateInfo' structure containing parameters affecting creation of the buffer.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pBuffer is a reference to a 'VkBuffer' handle in which the resulting buffer object is returned.
   */
  export function vkCreateBuffer(
    device: VkDevice | null,
    pCreateInfo: VkBufferCreateInfo | null,
    pAllocator: null,
    pBuffer: VkBuffer | null
  ): VkResult

  /**
   * Destroy a buffer object
   * @param device is the logical device that destroys the buffer.
   * @param buffer is the buffer to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyBuffer(
    device: VkDevice | null,
    buffer: VkBuffer | null,
    pAllocator: null
  ): void

  /**
   * Create a new buffer view object
   * @param device is the logical device that creates the buffer view.
   * @param pCreateInfo is a reference to a 'VkBufferViewCreateInfo' structure containing parameters to be used to create the buffer.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pView is a reference to a 'VkBufferView' handle in which the resulting buffer view object is returned.
   */
  export function vkCreateBufferView(
    device: VkDevice | null,
    pCreateInfo: VkBufferViewCreateInfo | null,
    pAllocator: null,
    pView: VkBufferView | null
  ): VkResult

  /**
   * Destroy a buffer view object
   * @param device is the logical device that destroys the buffer view.
   * @param bufferView is the buffer view to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyBufferView(
    device: VkDevice | null,
    bufferView: VkBufferView | null,
    pAllocator: null
  ): void

  /**
   * Create a new image object
   * @param device is the logical device that creates the image.
   * @param pCreateInfo is a reference to a 'VkImageCreateInfo' structure containing parameters to be used to create the image.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pImage is a reference to a 'VkImage' handle in which the resulting image object is returned.
   */
  export function vkCreateImage(
    device: VkDevice | null,
    pCreateInfo: VkImageCreateInfo | null,
    pAllocator: null,
    pImage: VkImage | null
  ): VkResult

  /**
   * Destroy an image object
   * @param device is the logical device that destroys the image.
   * @param image is the image to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyImage(
    device: VkDevice | null,
    image: VkImage | null,
    pAllocator: null
  ): void

  /**
   * Retrieve information about an image subresource
   * @param device is the logical device that owns the image.
   * @param image is the image whose layout is being queried.
   * @param pSubresource is a reference to a 'VkImageSubresource' structure selecting a specific image for the image subresource.
   * @param pLayout is a reference to a 'VkSubresourceLayout' structure in which the layout is returned.
   */
  export function vkGetImageSubresourceLayout(
    device: VkDevice | null,
    image: VkImage | null,
    pSubresource: VkImageSubresource | null,
    pLayout: VkSubresourceLayout | null
  ): void

  /**
   * Create an image view from an existing image
   * @param device is the logical device that creates the image view.
   * @param pCreateInfo is a reference to a 'VkImageViewCreateInfo' structure containing parameters to be used to create the image view.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pView is a reference to a 'VkImageView' handle in which the resulting image view object is returned.
   */
  export function vkCreateImageView(
    device: VkDevice | null,
    pCreateInfo: VkImageViewCreateInfo | null,
    pAllocator: null,
    pView: VkImageView | null
  ): VkResult

  /**
   * Destroy an image view object
   * @param device is the logical device that destroys the image view.
   * @param imageView is the image view to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyImageView(
    device: VkDevice | null,
    imageView: VkImageView | null,
    pAllocator: null
  ): void

  /**
   * Creates a new shader module object
   * @param device is the logical device that creates the shader module.
   * @param pCreateInfo is a reference to a 'VkShaderModuleCreateInfo' structure.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pShaderModule is a reference to a 'VkShaderModule' handle in which the resulting shader module object is returned.
   */
  export function vkCreateShaderModule(
    device: VkDevice | null,
    pCreateInfo: VkShaderModuleCreateInfo | null,
    pAllocator: null,
    pShaderModule: VkShaderModule | null
  ): VkResult

  /**
   * Destroy a shader module
   * @param device is the logical device that destroys the shader module.
   * @param shaderModule is the handle of the shader module to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyShaderModule(
    device: VkDevice | null,
    shaderModule: VkShaderModule | null,
    pAllocator: null
  ): void

  /**
   * Creates a new pipeline cache
   * @param device is the logical device that creates the pipeline cache object.
   * @param pCreateInfo is a reference to a 'VkPipelineCacheCreateInfo' structure containing initial parameters for the pipeline cache object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelineCache is a reference to a 'VkPipelineCache' handle in which the resulting pipeline cache object is returned.
   */
  export function vkCreatePipelineCache(
    device: VkDevice | null,
    pCreateInfo: VkPipelineCacheCreateInfo | null,
    pAllocator: null,
    pPipelineCache: VkPipelineCache | null
  ): VkResult

  /**
   * Destroy a pipeline cache object
   * @param device is the logical device that destroys the pipeline cache object.
   * @param pipelineCache is the handle of the pipeline cache to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPipelineCache(
    device: VkDevice | null,
    pipelineCache: VkPipelineCache | null,
    pAllocator: null
  ): void

  /**
   * Get the data store from a pipeline cache
   * @param device is the logical device that owns the pipeline cache.
   * @param pipelineCache is the pipeline cache to retrieve data from.
   * @param pDataSize is a reference to a 'size_t' value related to the amount of data in the pipeline cache, as described below.
   * @param pData is either <i>null</i> or a reference to a buffer.
   */
  export function vkGetPipelineCacheData(
    device: VkDevice | null,
    pipelineCache: VkPipelineCache | null,
    pDataSize: VkInoutAddress | null,
    pData: ArrayBuffer | null
  ): VkResult

  /**
   * Combine the data stores of pipeline caches
   * @param device is the logical device that owns the pipeline cache objects.
   * @param dstCache is the handle of the pipeline cache to merge results into.
   * @param srcCacheCount
   * @param pSrcCaches is an array of pipeline cache handles, which will be merged into 'dstCache'. The previous contents of 'dstCache' are included after the merge.
   */
  export function vkMergePipelineCaches(
    device: VkDevice | null,
    dstCache: VkPipelineCache | null,
    srcCacheCount: number,
    pSrcCaches: VkPipelineCache[] | null
  ): VkResult

  /**
   * Create graphics pipelines
   * @param device is the logical device that creates the graphics pipelines.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled; or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkGraphicsPipelineCreateInfo' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array of 'VkPipeline' handles in which the resulting graphics pipeline objects are returned.
   */
  export function vkCreateGraphicsPipelines(
    device: VkDevice | null,
    pipelineCache: VkPipelineCache | null,
    createInfoCount: number,
    pCreateInfos: VkGraphicsPipelineCreateInfo[] | null,
    pAllocator: null,
    pPipelines: VkPipeline[] | null
  ): VkResult

  /**
   * Creates a new compute pipeline object
   * @param device is the logical device that creates the compute pipelines.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled; or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkComputePipelineCreateInfo' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array of 'VkPipeline' handles in which the resulting compute pipeline objects are returned.+[NOTE].editing-note====TODO (Jon) - Should we say something like "`the i'th element of the'pPipelines' array is created based on the corresponding element of the'pCreateInfos' array`"? Also for 'vkCreateGraphicsPipelines' below.====
   */
  export function vkCreateComputePipelines(
    device: VkDevice | null,
    pipelineCache: VkPipelineCache | null,
    createInfoCount: number,
    pCreateInfos: VkComputePipelineCreateInfo[] | null,
    pAllocator: null,
    pPipelines: VkPipeline[] | null
  ): VkResult

  /**
   * Destroy a pipeline object
   * @param device is the logical device that destroys the pipeline.
   * @param pipeline is the handle of the pipeline to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPipeline(
    device: VkDevice | null,
    pipeline: VkPipeline | null,
    pAllocator: null
  ): void

  /**
   * Creates a new pipeline layout object
   * @param device is the logical device that creates the pipeline layout.
   * @param pCreateInfo is a reference to a 'VkPipelineLayoutCreateInfo' structure specifying the state of the pipeline layout object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelineLayout is a reference to a 'VkPipelineLayout' handle in which the resulting pipeline layout object is returned.
   */
  export function vkCreatePipelineLayout(
    device: VkDevice | null,
    pCreateInfo: VkPipelineLayoutCreateInfo | null,
    pAllocator: null,
    pPipelineLayout: VkPipelineLayout | null
  ): VkResult

  /**
   * Destroy a pipeline layout object
   * @param device is the logical device that destroys the pipeline layout.
   * @param pipelineLayout is the pipeline layout to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPipelineLayout(
    device: VkDevice | null,
    pipelineLayout: VkPipelineLayout | null,
    pAllocator: null
  ): void

  /**
   * Create a new sampler object
   * @param device is the logical device that creates the sampler.
   * @param pCreateInfo is a reference to a 'VkSamplerCreateInfo' structure specifying the state of the sampler object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pSampler is a reference to a 'VkSampler' handle in which the resulting sampler object is returned.
   */
  export function vkCreateSampler(
    device: VkDevice | null,
    pCreateInfo: VkSamplerCreateInfo | null,
    pAllocator: null,
    pSampler: VkSampler | null
  ): VkResult

  /**
   * Destroy a sampler object
   * @param device is the logical device that destroys the sampler.
   * @param sampler is the sampler to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroySampler(
    device: VkDevice | null,
    sampler: VkSampler | null,
    pAllocator: null
  ): void

  /**
   * Create a new descriptor set layout
   * @param device is the logical device that creates the descriptor set layout.
   * @param pCreateInfo is a reference to a 'VkDescriptorSetLayoutCreateInfo' structure specifying the state of the descriptor set layout object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pSetLayout is a reference to a 'VkDescriptorSetLayout' handle in which the resulting descriptor set layout object is returned.
   */
  export function vkCreateDescriptorSetLayout(
    device: VkDevice | null,
    pCreateInfo: VkDescriptorSetLayoutCreateInfo | null,
    pAllocator: null,
    pSetLayout: VkDescriptorSetLayout | null
  ): VkResult

  /**
   * Destroy a descriptor set layout object
   * @param device is the logical device that destroys the descriptor set layout.
   * @param descriptorSetLayout is the descriptor set layout to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDescriptorSetLayout(
    device: VkDevice | null,
    descriptorSetLayout: VkDescriptorSetLayout | null,
    pAllocator: null
  ): void

  /**
   * Creates a descriptor pool object
   * @param device is the logical device that creates the descriptor pool.
   * @param pCreateInfo is a reference to a 'VkDescriptorPoolCreateInfo' structure specifying the state of the descriptor pool object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pDescriptorPool is a reference to a 'VkDescriptorPool' handle in which the resulting descriptor pool object is returned.
   */
  export function vkCreateDescriptorPool(
    device: VkDevice | null,
    pCreateInfo: VkDescriptorPoolCreateInfo | null,
    pAllocator: null,
    pDescriptorPool: VkDescriptorPool | null
  ): VkResult

  /**
   * Destroy a descriptor pool object
   * @param device is the logical device that destroys the descriptor pool.
   * @param descriptorPool is the descriptor pool to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDescriptorPool(
    device: VkDevice | null,
    descriptorPool: VkDescriptorPool | null,
    pAllocator: null
  ): void

  /**
   * Resets a descriptor pool object
   * @param device is the logical device that owns the descriptor pool.
   * @param descriptorPool is the descriptor pool to be reset.
   * @param flags is reserved for future use.
   */
  export function vkResetDescriptorPool(
    device: VkDevice | null,
    descriptorPool: VkDescriptorPool | null,
    flags: number
  ): VkResult

  /**
   * Allocate one or more descriptor sets
   * @param device is the logical device that owns the descriptor pool.
   * @param pAllocateInfo is a reference to a 'VkDescriptorSetAllocateInfo' structure describing parameters of the allocation.
   * @param pDescriptorSets is an array of 'VkDescriptorSet' handles in which the resulting descriptor set objects are returned.
   */
  export function vkAllocateDescriptorSets(
    device: VkDevice | null,
    pAllocateInfo: VkDescriptorSetAllocateInfo | null,
    pDescriptorSets: VkDescriptorSet[] | null
  ): VkResult

  /**
   * Free one or more descriptor sets
   * @param device is the logical device that owns the descriptor pool.
   * @param descriptorPool is the descriptor pool from which the descriptor sets were allocated.
   * @param descriptorSetCount is the number of elements in the 'pDescriptorSets' array.
   * @param pDescriptorSets is an array of handles to 'VkDescriptorSet' objects.
   */
  export function vkFreeDescriptorSets(
    device: VkDevice | null,
    descriptorPool: VkDescriptorPool | null,
    descriptorSetCount: number,
    pDescriptorSets: VkDescriptorSet[] | null
  ): VkResult

  /**
   * Update the contents of a descriptor set object
   * @param device is the logical device that updates the descriptor sets.
   * @param descriptorWriteCount is the number of elements in the 'pDescriptorWrites' array.
   * @param pDescriptorWrites is an array of 'VkWriteDescriptorSet' structures describing the descriptor sets to write to.
   * @param descriptorCopyCount is the number of elements in the 'pDescriptorCopies' array.
   * @param pDescriptorCopies is an array of 'VkCopyDescriptorSet' structures describing the descriptor sets to copy between.
   */
  export function vkUpdateDescriptorSets(
    device: VkDevice | null,
    descriptorWriteCount: number,
    pDescriptorWrites: VkWriteDescriptorSet[] | null,
    descriptorCopyCount: number,
    pDescriptorCopies: VkCopyDescriptorSet[] | null
  ): void

  /**
   * Create a new framebuffer object
   * @param device is the logical device that creates the framebuffer.
   * @param pCreateInfo is a reference to a 'VkFramebufferCreateInfo' structure describing additional information about framebuffer creation.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFramebuffer is a reference to a 'VkFramebuffer' handle in which the resulting framebuffer object is returned.
   */
  export function vkCreateFramebuffer(
    device: VkDevice | null,
    pCreateInfo: VkFramebufferCreateInfo | null,
    pAllocator: null,
    pFramebuffer: VkFramebuffer | null
  ): VkResult

  /**
   * Destroy a framebuffer object
   * @param device is the logical device that destroys the framebuffer.
   * @param framebuffer is the handle of the framebuffer to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyFramebuffer(
    device: VkDevice | null,
    framebuffer: VkFramebuffer | null,
    pAllocator: null
  ): void

  /**
   * Create a new render pass object
   * @param device is the logical device that creates the render pass.
   * @param pCreateInfo is a reference to a 'VkRenderPassCreateInfo' structure describing the parameters of the render pass.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pRenderPass is a reference to a 'VkRenderPass' handle in which the resulting render pass object is returned.
   */
  export function vkCreateRenderPass(
    device: VkDevice | null,
    pCreateInfo: VkRenderPassCreateInfo | null,
    pAllocator: null,
    pRenderPass: VkRenderPass | null
  ): VkResult

  /**
   * Destroy a render pass object
   * @param device is the logical device that destroys the render pass.
   * @param renderPass is the handle of the render pass to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyRenderPass(
    device: VkDevice | null,
    renderPass: VkRenderPass | null,
    pAllocator: null
  ): void

  /**
   * Returns the granularity for optimal render area
   * @param device is the logical device that owns the render pass.
   * @param renderPass is a handle to a render pass.
   * @param pGranularity is a reference to a 'VkExtent2D' structure in which the granularity is returned.
   */
  export function vkGetRenderAreaGranularity(
    device: VkDevice | null,
    renderPass: VkRenderPass | null,
    pGranularity: VkExtent2D | null
  ): void

  /**
   * Create a new command pool object
   * @param device is the logical device that creates the command pool.
   * @param pCreateInfo is a reference to a 'VkCommandPoolCreateInfo' structure specifying the state of the command pool object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pCommandPool is a reference to a 'VkCommandPool' handle in which the created pool is returned.
   */
  export function vkCreateCommandPool(
    device: VkDevice | null,
    pCreateInfo: VkCommandPoolCreateInfo | null,
    pAllocator: null,
    pCommandPool: VkCommandPool | null
  ): VkResult

  /**
   * Destroy a command pool object
   * @param device is the logical device that destroys the command pool.
   * @param commandPool is the handle of the command pool to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyCommandPool(
    device: VkDevice | null,
    commandPool: VkCommandPool | null,
    pAllocator: null
  ): void

  /**
   * Reset a command pool
   * @param device is the logical device that owns the command pool.
   * @param commandPool is the command pool to reset.
   * @param flags is a bitmask of 'VkCommandPoolResetFlagBits' controlling the reset operation.
   */
  export function vkResetCommandPool(
    device: VkDevice | null,
    commandPool: VkCommandPool | null,
    flags: VkCommandPoolResetFlagBits
  ): VkResult

  /**
   * Allocate command buffers from an existing command pool
   * @param device is the logical device that owns the command pool.
   * @param pAllocateInfo is a reference to a 'VkCommandBufferAllocateInfo' structure describing parameters of the allocation.
   * @param pCommandBuffers is an array of 'VkCommandBuffer' handles in which the resulting command buffer objects are returned. The array 'must' be at least the length specified by the 'commandBufferCount' member of 'pAllocateInfo'. Each allocated command buffer begins in the initial state.
   */
  export function vkAllocateCommandBuffers(
    device: VkDevice | null,
    pAllocateInfo: VkCommandBufferAllocateInfo | null,
    pCommandBuffers: VkCommandBuffer[] | null
  ): VkResult

  /**
   * Free command buffers
   * @param device is the logical device that owns the command pool.
   * @param commandPool is the command pool from which the command buffers were allocated.
   * @param commandBufferCount
   * @param pCommandBuffers is an array of handles of command buffers to free.
   */
  export function vkFreeCommandBuffers(
    device: VkDevice | null,
    commandPool: VkCommandPool | null,
    commandBufferCount: number,
    pCommandBuffers: VkCommandBuffer[] | null
  ): void

  /**
   * Start recording a command buffer
   * @param commandBuffer is the handle of the command buffer which is to be put in the recording state.
   * @param pBeginInfo reference to a 'VkCommandBufferBeginInfo' structure defining additional information about how the command buffer begins recording.
   */
  export function vkBeginCommandBuffer(
    commandBuffer: VkCommandBuffer | null,
    pBeginInfo: VkCommandBufferBeginInfo | null
  ): VkResult

  /**
   * Finish recording a command buffer
   * @param commandBuffer is the command buffer to complete recording.
   */
  export function vkEndCommandBuffer(
    commandBuffer: VkCommandBuffer | null
  ): VkResult

  /**
   * Reset a command buffer to the initial state
   * @param commandBuffer is the command buffer to reset. The command buffer 'can' be in any state other than <<commandbuffers-lifecycle, pending>>, and is moved into the <<commandbuffers-lifecycle, initial state>>.
   * @param flags is a bitmask of 'VkCommandBufferResetFlagBits' controlling the reset operation.
   */
  export function vkResetCommandBuffer(
    commandBuffer: VkCommandBuffer | null,
    flags: VkCommandBufferResetFlagBits
  ): VkResult

  /**
   * Bind a pipeline object to a command buffer
   * @param commandBuffer is the command buffer that the pipeline will be bound to.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' value specifying whether to bind to the compute or graphics bind point. Binding one does not disturb the other.
   * @param pipeline is the pipeline to be bound.
   */
  export function vkCmdBindPipeline(
    commandBuffer: VkCommandBuffer | null,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline | null
  ): void

  /**
   * Set the viewport on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstViewport is the index of the first viewport whose parameters are updated by the command.
   * @param viewportCount is the number of viewports whose parameters are updated by the command.
   * @param pViewports is an array of 'VkViewport' structures specifying viewport parameters.
   */
  export function vkCmdSetViewport(
    commandBuffer: VkCommandBuffer | null,
    firstViewport: number,
    viewportCount: number,
    pViewports: VkViewport[] | null
  ): void

  /**
   * Set the dynamic scissor rectangles on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstScissor is the index of the first scissor whose state is updated by the command.
   * @param scissorCount is the number of scissors whose rectangles are updated by the command.
   * @param pScissors is an array of 'VkRect2D' structures defining scissor rectangles.
   */
  export function vkCmdSetScissor(
    commandBuffer: VkCommandBuffer | null,
    firstScissor: number,
    scissorCount: number,
    pScissors: VkRect2D[] | null
  ): void

  /**
   * Set the dynamic line width state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param lineWidth is the width of rasterized line segments.
   */
  export function vkCmdSetLineWidth(
    commandBuffer: VkCommandBuffer | null,
    lineWidth: number
  ): void

  /**
   * Set the depth bias dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.
   * @param depthBiasClamp is the maximum (or minimum) depth bias of a fragment.
   * @param depthBiasSlopeFactor is a scalar factor applied to a fragment's slope in depth bias calculations.
   */
  export function vkCmdSetDepthBias(
    commandBuffer: VkCommandBuffer | null,
    depthBiasConstantFactor: number,
    depthBiasClamp: number,
    depthBiasSlopeFactor: number
  ): void

  /**
   * Set the values of blend constants
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param blendConstants is an array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.
   */
  export function vkCmdSetBlendConstants(
    commandBuffer: VkCommandBuffer | null,
    blendConstants: number[] | null
  ): void

  /**
   * Set the depth bounds test values for a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param minDepthBounds is the lower bound of the range of depth values used in the depth bounds test.
   * @param maxDepthBounds is the upper bound of the range.
   */
  export function vkCmdSetDepthBounds(
    commandBuffer: VkCommandBuffer | null,
    minDepthBounds: number,
    maxDepthBounds: number
  ): void

  /**
   * Set the stencil compare mask dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of 'VkStencilFaceFlagBits' specifying the set of stencil state for which to update the compare mask.
   * @param compareMask is the new value to use as the stencil compare mask.
   */
  export function vkCmdSetStencilCompareMask(
    commandBuffer: VkCommandBuffer | null,
    faceMask: VkStencilFaceFlagBits,
    compareMask: number
  ): void

  /**
   * Set the stencil write mask dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of 'VkStencilFaceFlagBits' specifying the set of stencil state for which to update the write mask, as described above for 'vkCmdSetStencilCompareMask'.
   * @param writeMask is the new value to use as the stencil write mask.
   */
  export function vkCmdSetStencilWriteMask(
    commandBuffer: VkCommandBuffer | null,
    faceMask: VkStencilFaceFlagBits,
    writeMask: number
  ): void

  /**
   * Set the stencil reference dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of 'VkStencilFaceFlagBits' specifying the set of stencil state for which to update the reference value, as described above for 'vkCmdSetStencilCompareMask'.
   * @param reference is the new value to use as the stencil reference value.
   */
  export function vkCmdSetStencilReference(
    commandBuffer: VkCommandBuffer | null,
    faceMask: VkStencilFaceFlagBits,
    reference: number
  ): void

  /**
   * Binds descriptor sets to a command buffer
   * @param commandBuffer is the command buffer that the descriptor sets will be bound to.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' indicating whether the descriptors will be used by graphics pipelines or compute pipelines. There is a separate set of bind reference for each of graphics and compute, so binding one does not disturb the other.
   * @param layout is a 'VkPipelineLayout' object used to program the bindings.
   * @param firstSet is the set number of the first descriptor set to be bound.
   * @param descriptorSetCount is the number of elements in the 'pDescriptorSets' array.
   * @param pDescriptorSets is an array of handles to 'VkDescriptorSet' objects describing the descriptor sets to write to.
   * @param dynamicOffsetCount is the number of dynamic offsets in the 'pDynamicOffsets' array.
   * @param pDynamicOffsets is an array of 'uint32_t' values specifying dynamic offsets.
   */
  export function vkCmdBindDescriptorSets(
    commandBuffer: VkCommandBuffer | null,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout | null,
    firstSet: number,
    descriptorSetCount: number,
    pDescriptorSets: VkDescriptorSet[] | null,
    dynamicOffsetCount: number,
    pDynamicOffsets: Uint32Array | null
  ): void

  /**
   * Bind an index buffer to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer used in index buffer address calculations.
   * @param offset
   * @param indexType is a 'VkIndexType' value specifying whether indices are treated as 16 bits or 32 bits.
   */
  export function vkCmdBindIndexBuffer(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    indexType: VkIndexType
  ): void

  /**
   * Bind vertex buffers to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstBinding is the index of the first vertex input binding whose state is updated by the command.
   * @param bindingCount is the number of vertex input bindings whose state is updated by the command.
   * @param pBuffers is an array of buffer handles.
   * @param pOffsets is an array of buffer offsets.
   */
  export function vkCmdBindVertexBuffers(
    commandBuffer: VkCommandBuffer | null,
    firstBinding: number,
    bindingCount: number,
    pBuffers: VkBuffer[] | null,
    pOffsets: BigUint64Array | null
  ): void

  /**
   * Draw primitives
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param vertexCount is the number of vertices to draw.
   * @param instanceCount is the number of instances to draw.
   * @param firstVertex is the index of the first vertex to draw.
   * @param firstInstance is the instance ID of the first instance to draw.
   */
  export function vkCmdDraw(
    commandBuffer: VkCommandBuffer | null,
    vertexCount: number,
    instanceCount: number,
    firstVertex: number,
    firstInstance: number
  ): void

  /**
   * Issue an indexed draw into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param indexCount is the number of vertices to draw.
   * @param instanceCount is the number of instances to draw.
   * @param firstIndex is the base index within the index buffer.
   * @param vertexOffset is the value added to the vertex index before indexing into the vertex buffer.
   * @param firstInstance is the instance ID of the first instance to draw.
   */
  export function vkCmdDrawIndexed(
    commandBuffer: VkCommandBuffer | null,
    indexCount: number,
    instanceCount: number,
    firstIndex: number,
    vertexOffset: number,
    firstInstance: number
  ): void

  /**
   * Issue an indirect draw into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param drawCount is the number of draws to execute, and 'can' be zero.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndirect(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    drawCount: number,
    stride: number
  ): void

  /**
   * Perform an indexed indirect draw
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param drawCount is the number of draws to execute, and 'can' be zero.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndexedIndirect(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    drawCount: number,
    stride: number
  ): void

  /**
   * Dispatch compute work items
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param groupCountX is the number of local workgroups to dispatch in the X dimension.
   * @param groupCountY is the number of local workgroups to dispatch in the Y dimension.
   * @param groupCountZ is the number of local workgroups to dispatch in the Z dimension.
   */
  export function vkCmdDispatch(
    commandBuffer: VkCommandBuffer | null,
    groupCountX: number,
    groupCountY: number,
    groupCountZ: number
  ): void

  /**
   * Dispatch compute work items using indirect parameters
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param buffer where parameters begin.
   * @param offset
   */
  export function vkCmdDispatchIndirect(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number
  ): void

  /**
   * Copy data between buffer regions
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcBuffer is the source buffer.
   * @param dstBuffer is the destination buffer.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkBufferCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyBuffer(
    commandBuffer: VkCommandBuffer | null,
    srcBuffer: VkBuffer | null,
    dstBuffer: VkBuffer | null,
    regionCount: number,
    pRegions: VkBufferCopy[] | null
  ): void

  /**
   * Copy data between images
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the current layout of the source image subresource.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the current layout of the destination image subresource.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkImageCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyImage(
    commandBuffer: VkCommandBuffer | null,
    srcImage: VkImage | null,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage | null,
    dstImageLayout: VkImageLayout,
    regionCount: number,
    pRegions: VkImageCopy[] | null
  ): void

  /**
   * Copy regions of an image, potentially performing format conversion,
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the layout of the source image subresources for the blit.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the layout of the destination image subresources for the blit.
   * @param regionCount is the number of regions to blit.
   * @param pRegions is an array of 'VkImageBlit' structures specifying the regions to blit.
   * @param filter is a 'VkFilter' specifying the filter to apply if the blits require scaling.
   */
  export function vkCmdBlitImage(
    commandBuffer: VkCommandBuffer | null,
    srcImage: VkImage | null,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage | null,
    dstImageLayout: VkImageLayout,
    regionCount: number,
    pRegions: VkImageBlit[] | null,
    filter: VkFilter
  ): void

  /**
   * Copy data from a buffer into an image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcBuffer is the source buffer.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the layout of the destination image subresources for the copy.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkBufferImageCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyBufferToImage(
    commandBuffer: VkCommandBuffer | null,
    srcBuffer: VkBuffer | null,
    dstImage: VkImage | null,
    dstImageLayout: VkImageLayout,
    regionCount: number,
    pRegions: VkBufferImageCopy[] | null
  ): void

  /**
   * Copy image data into a buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the layout of the source image subresources for the copy.
   * @param dstBuffer is the destination buffer.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkBufferImageCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyImageToBuffer(
    commandBuffer: VkCommandBuffer | null,
    srcImage: VkImage | null,
    srcImageLayout: VkImageLayout,
    dstBuffer: VkBuffer | null,
    regionCount: number,
    pRegions: VkBufferImageCopy[] | null
  ): void

  /**
   * Update a buffer\
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param dstBuffer is a handle to the buffer to be updated.
   * @param dstOffset is the byte offset into the buffer to start updating, and 'must' be a multiple of 4.
   * @param dataSize is the number of bytes to update, and 'must' be a multiple of 4.
   * @param pData is a reference to the source data for the buffer update, and 'must' be at least 'dataSize' bytes in size.
   */
  export function vkCmdUpdateBuffer(
    commandBuffer: VkCommandBuffer | null,
    dstBuffer: VkBuffer | null,
    dstOffset: bigint | number,
    dataSize: bigint | number,
    pData: ArrayBuffer | null
  ): void

  /**
   * Fill a region of a buffer with a fixed value
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param dstBuffer is the buffer to be filled.
   * @param dstOffset is the byte offset into the buffer at which to start filling, and 'must' be a multiple of 4.
   * @param size is the number of bytes to fill, and 'must' be either a multiple of 4, or 'VK_WHOLE_SIZE' to fill the range from 'offset' to the end of the buffer. If 'VK_WHOLE_SIZE' is used and the remaining size of the buffer is not a multiple of 4, then the nearest smaller multiple is used.
   * @param data is the 4-byte word written repeatedly to the buffer to fill 'size' bytes of data. The data word is written to memory according to the host endianness.
   */
  export function vkCmdFillBuffer(
    commandBuffer: VkCommandBuffer | null,
    dstBuffer: VkBuffer | null,
    dstOffset: bigint | number,
    size: bigint | number,
    data: number
  ): void

  /**
   * Clear regions of a color image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param image is the image to be cleared.
   * @param imageLayout specifies the current layout of the image subresource ranges to be cleared, and 'must' be 'VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR',
   * @param pColor
   * @param rangeCount
   * @param pRanges
   */
  export function vkCmdClearColorImage(
    commandBuffer: VkCommandBuffer | null,
    image: VkImage | null,
    imageLayout: VkImageLayout,
    pColor: VkClearColorValue | null,
    rangeCount: number,
    pRanges: VkImageSubresourceRange[] | null
  ): void

  /**
   * Fill regions of a combined depth/stencil image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param image is the image to be cleared.
   * @param imageLayout specifies the current layout of the image subresource ranges to be cleared, and 'must' be 'VK_IMAGE_LAYOUT_GENERAL' or 'VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL'.
   * @param pDepthStencil is a reference to a 'VkClearDepthStencilValue' structure containing the values that the depth and stencil image subresource ranges will be cleared to (see <<clears-values>> below).
   * @param rangeCount is the number of image subresource range structures in 'pRanges'.
   * @param pRanges is an array of 'VkImageSubresourceRange' structures describing a range of mipmap levels, array layers, and aspects to be cleared, as described in <<resources-image-views,Image Views>>.
   */
  export function vkCmdClearDepthStencilImage(
    commandBuffer: VkCommandBuffer | null,
    image: VkImage | null,
    imageLayout: VkImageLayout,
    pDepthStencil: VkClearDepthStencilValue | null,
    rangeCount: number,
    pRanges: VkImageSubresourceRange[] | null
  ): void

  /**
   * Clear regions within bound framebuffer attachments
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param attachmentCount
   * @param pAttachments is an array of 'VkClearAttachment' structures defining the attachments to clear and the clear values to use. If any attachment to be cleared in the current subpass is 'VK_ATTACHMENT_UNUSED', then the clear has no effect on that attachment.
   * @param rectCount
   * @param pRects is an array of 'VkClearRect' structures defining regions within each selected attachment to clear.
   */
  export function vkCmdClearAttachments(
    commandBuffer: VkCommandBuffer | null,
    attachmentCount: number,
    pAttachments: VkClearAttachment[] | null,
    rectCount: number,
    pRects: VkClearRect[] | null
  ): void

  /**
   * Resolve regions of an image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the layout of the source image subresources for the resolve.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the layout of the destination image subresources for the resolve.
   * @param regionCount is the number of regions to resolve.
   * @param pRegions is an array of 'VkImageResolve' structures specifying the regions to resolve.
   */
  export function vkCmdResolveImage(
    commandBuffer: VkCommandBuffer | null,
    srcImage: VkImage | null,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage | null,
    dstImageLayout: VkImageLayout,
    regionCount: number,
    pRegions: VkImageResolve[] | null
  ): void

  /**
   * Set an event object to signaled state
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param event is the event that will be signaled.
   * @param stageMask specifies the <<synchronization-pipeline-stages,source stage mask>> used to determine when the 'event' is signaled.
   */
  export function vkCmdSetEvent(
    commandBuffer: VkCommandBuffer | null,
    event: VkEvent | null,
    stageMask: VkPipelineStageFlagBits
  ): void

  /**
   * Reset an event object to non-signaled state
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param event is the event that will be unsignaled.
   * @param stageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages, source stage mask>> used to determine when the 'event' is unsignaled.
   */
  export function vkCmdResetEvent(
    commandBuffer: VkCommandBuffer | null,
    event: VkEvent | null,
    stageMask: VkPipelineStageFlagBits
  ): void

  /**
   * Wait for one or more events and insert a set of memory
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param eventCount
   * @param pEvents is an array of event object handles to wait on.
   * @param srcStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages, source stage mask>>.
   * @param dstStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages, destination stage mask>>.
   * @param memoryBarrierCount
   * @param pMemoryBarriers is an array of 'VkMemoryBarrier' structures.
   * @param bufferMemoryBarrierCount is the length of the 'pBufferMemoryBarriers' array.
   * @param pBufferMemoryBarriers is an array of 'VkBufferMemoryBarrier' structures.
   * @param imageMemoryBarrierCount is the length of the 'pImageMemoryBarriers' array.
   * @param pImageMemoryBarriers is an array of 'VkImageMemoryBarrier' structures.
   */
  export function vkCmdWaitEvents(
    commandBuffer: VkCommandBuffer | null,
    eventCount: number,
    pEvents: VkEvent[] | null,
    srcStageMask: VkPipelineStageFlagBits,
    dstStageMask: VkPipelineStageFlagBits,
    memoryBarrierCount: number,
    pMemoryBarriers: VkMemoryBarrier[] | null,
    bufferMemoryBarrierCount: number,
    pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null,
    imageMemoryBarrierCount: number,
    pImageMemoryBarriers: VkImageMemoryBarrier[] | null
  ): void

  /**
   * Insert a memory dependency
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param srcStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
   * @param dstStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>.
   * @param dependencyFlags is a bitmask of 'VkDependencyFlagBits' specifying how execution and memory dependencies are formed.
   * @param memoryBarrierCount
   * @param pMemoryBarriers is an array of 'VkMemoryBarrier' structures.
   * @param bufferMemoryBarrierCount is the length of the 'pBufferMemoryBarriers' array.
   * @param pBufferMemoryBarriers is an array of 'VkBufferMemoryBarrier' structures.
   * @param imageMemoryBarrierCount is the length of the 'pImageMemoryBarriers' array.
   * @param pImageMemoryBarriers is an array of 'VkImageMemoryBarrier' structures.
   */
  export function vkCmdPipelineBarrier(
    commandBuffer: VkCommandBuffer | null,
    srcStageMask: VkPipelineStageFlagBits,
    dstStageMask: VkPipelineStageFlagBits,
    dependencyFlags: VkDependencyFlagBits,
    memoryBarrierCount: number,
    pMemoryBarriers: VkMemoryBarrier[] | null,
    bufferMemoryBarrierCount: number,
    pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null,
    imageMemoryBarrierCount: number,
    pImageMemoryBarriers: VkImageMemoryBarrier[] | null
  ): void

  /**
   * Begin a query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param query is the query index within the query pool that will contain the results.
   * @param flags is a bitmask of 'VkQueryControlFlagBits' specifying constraints on the types of queries that 'can' be performed.
   */
  export function vkCmdBeginQuery(
    commandBuffer: VkCommandBuffer | null,
    queryPool: VkQueryPool | null,
    query: number,
    flags: VkQueryControlFlagBits
  ): void

  /**
   * Ends a query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that is managing the results of the query.
   * @param query is the query index within the query pool where the result is stored.
   */
  export function vkCmdEndQuery(
    commandBuffer: VkCommandBuffer | null,
    queryPool: VkQueryPool | null,
    query: number
  ): void

  /**
   * Define the beginning of a conditional rendering block
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param pConditionalRenderingBegin is a reference to a 'VkConditionalRenderingBeginInfoEXT' structure specifying parameters of conditional rendering.
   */
  export function vkCmdBeginConditionalRenderingEXT(
    commandBuffer: VkCommandBuffer | null,
    pConditionalRenderingBegin: VkConditionalRenderingBeginInfoEXT | null
  ): void

  /**
   * Define the end of a conditional rendering block
   * @param commandBuffer is the command buffer into which this command will be recorded.
   */
  export function vkCmdEndConditionalRenderingEXT(
    commandBuffer: VkCommandBuffer | null
  ): void

  /**
   * Reset queries in a query pool
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the handle of the query pool managing the queries being reset.
   * @param firstQuery is the initial query index to reset.
   * @param queryCount is the number of queries to reset.
   */
  export function vkCmdResetQueryPool(
    commandBuffer: VkCommandBuffer | null,
    queryPool: VkQueryPool | null,
    firstQuery: number,
    queryCount: number
  ): void

  /**
   * Write a device timestamp into a query object
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pipelineStage is one of the 'VkPipelineStageFlagBits', specifying a stage of the pipeline.
   * @param queryPool is the query pool that will manage the timestamp.
   * @param query is the query within the query pool that will contain the timestamp.
   */
  export function vkCmdWriteTimestamp(
    commandBuffer: VkCommandBuffer | null,
    pipelineStage: VkPipelineStageFlagBits,
    queryPool: VkQueryPool | null,
    query: number
  ): void

  /**
   * Copy the results of queries in a query pool to a buffer object
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool managing the queries containing the desired results.
   * @param firstQuery is the initial query index.
   * @param queryCount is the number of queries. 'firstQuery' and 'queryCount' together define a range of queries.
   * @param dstBuffer is a 'VkBuffer' object that will receive the results of the copy command.
   * @param dstOffset
   * @param stride is the stride in bytes between results for individual queries within 'dstBuffer'. The required size of the backing memory for 'dstBuffer' is determined as described above for 'vkGetQueryPoolResults'.
   * @param flags is a bitmask of 'VkQueryResultFlagBits' specifying how and when results are returned.
   */
  export function vkCmdCopyQueryPoolResults(
    commandBuffer: VkCommandBuffer | null,
    queryPool: VkQueryPool | null,
    firstQuery: number,
    queryCount: number,
    dstBuffer: VkBuffer | null,
    dstOffset: bigint | number,
    stride: bigint | number,
    flags: VkQueryResultFlagBits
  ): void

  /**
   * Update the values of push constants
   * @param commandBuffer is the command buffer in which the push constant update will be recorded.
   * @param layout is the pipeline layout used to program the push constant updates.
   * @param stageFlags is a bitmask of 'VkShaderStageFlagBits' specifying the shader stages that will use the push constants in the updated range.
   * @param offset is the start offset of the push constant range to update, in units of bytes.
   * @param size bytes containing the new push constant values.
   * @param pValues
   */
  export function vkCmdPushConstants(
    commandBuffer: VkCommandBuffer | null,
    layout: VkPipelineLayout | null,
    stageFlags: VkShaderStageFlagBits,
    offset: number,
    size: number,
    pValues: ArrayBuffer | null
  ): void

  /**
   * Begin a new render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param pRenderPassBegin is a reference to a 'VkRenderPassBeginInfo' structure specifying the render pass to begin an instance of, and the framebuffer the instance uses.
   * @param contents is a 'VkSubpassContents' value specifying how the commands in the first subpass will be provided.
   */
  export function vkCmdBeginRenderPass(
    commandBuffer: VkCommandBuffer | null,
    pRenderPassBegin: VkRenderPassBeginInfo | null,
    contents: VkSubpassContents
  ): void

  /**
   * Transition to the next subpass of a render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param contents specifies how the commands in the next subpass will be provided, in the same fashion as the corresponding parameter of 'vkCmdBeginRenderPass'.
   */
  export function vkCmdNextSubpass(
    commandBuffer: VkCommandBuffer | null,
    contents: VkSubpassContents
  ): void

  /**
   * End the current render pass
   * @param commandBuffer is the command buffer in which to end the current render pass instance.
   */
  export function vkCmdEndRenderPass(
    commandBuffer: VkCommandBuffer | null
  ): void

  /**
   * Execute a secondary command buffer from a primary command buffer
   * @param commandBuffer is a handle to a primary command buffer that the secondary command buffers are executed in.
   * @param commandBufferCount
   * @param pCommandBuffers is an array of 'commandBufferCount' secondary command buffer handles, which are recorded to execute in the primary command buffer in the order they are listed in the array.
   */
  export function vkCmdExecuteCommands(
    commandBuffer: VkCommandBuffer | null,
    commandBufferCount: number,
    pCommandBuffers: VkCommandBuffer[] | null
  ): void

  /**
   * Query information about the available displays
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display devices available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayPropertiesKHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayPropertiesKHR(
    physicalDevice: VkPhysicalDevice | null,
    pPropertyCount: VkInout | null,
    pProperties: VkDisplayPropertiesKHR[] | null
  ): VkResult

  /**
   * Query the plane properties
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display planes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayPlanePropertiesKHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    physicalDevice: VkPhysicalDevice | null,
    pPropertyCount: VkInout | null,
    pProperties: VkDisplayPlanePropertiesKHR[] | null
  ): VkResult

  /**
   * Query the list of displays a plane supports
   * @param physicalDevice is a physical device.
   * @param planeIndex is the plane which the application wishes to use, and 'must' be in the range [eq]#[0, physical device plane count - 1]#.
   * @param pDisplayCount is a reference to a number related to the number of displays available or queried, as described below.
   * @param pDisplays is either <i>null</i> or a reference to an array of 'VkDisplayKHR' handles.
   */
  export function vkGetDisplayPlaneSupportedDisplaysKHR(
    physicalDevice: VkPhysicalDevice | null,
    planeIndex: number,
    pDisplayCount: VkInout | null,
    pDisplays: VkDisplayKHR[] | null
  ): VkResult

  /**
   * Query the set of mode properties supported by the display
   * @param physicalDevice is the physical device associated with 'display'.
   * @param display is the display to query.
   * @param pPropertyCount is a reference to a number related to the number of display modes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayModePropertiesKHR' structures.
   */
  export function vkGetDisplayModePropertiesKHR(
    physicalDevice: VkPhysicalDevice | null,
    display: VkDisplayKHR | null,
    pPropertyCount: VkInout | null,
    pProperties: VkDisplayModePropertiesKHR[] | null
  ): VkResult

  /**
   * Create a display mode
   * @param physicalDevice is the physical device associated with 'display'.
   * @param display is the display to create an additional mode for.
   * @param pCreateInfo is a 'VkDisplayModeCreateInfoKHR' structure describing the new mode to create.
   * @param pAllocator is the allocator used for host memory allocated for the display mode object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pMode returns the handle of the mode created.
   */
  export function vkCreateDisplayModeKHR(
    physicalDevice: VkPhysicalDevice | null,
    display: VkDisplayKHR | null,
    pCreateInfo: VkDisplayModeCreateInfoKHR | null,
    pAllocator: null,
    pMode: VkDisplayModeKHR | null
  ): VkResult

  /**
   * Query capabilities of a mode and plane combination
   * @param physicalDevice is the physical device associated with 'display'
   * @param mode is the display mode the application intends to program when using the specified plane. Note this parameter also implicitly specifies a display.
   * @param planeIndex is the plane which the application intends to use with the display, and is less than the number of display planes supported by the device.
   * @param pCapabilities is a reference to a 'VkDisplayPlaneCapabilitiesKHR' structure in which the capabilities are returned.
   */
  export function vkGetDisplayPlaneCapabilitiesKHR(
    physicalDevice: VkPhysicalDevice | null,
    mode: VkDisplayModeKHR | null,
    planeIndex: number,
    pCapabilities: VkDisplayPlaneCapabilitiesKHR | null
  ): VkResult

  /**
   * Create a {#0#} structure representing a display plane and mode
   * @param instance is the instance corresponding to the physical device the targeted display is on.
   * @param pCreateInfo is a reference to a 'VkDisplaySurfaceCreateInfoKHR' structure specifying which mode, plane, and other parameters to use, as described below.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSurface is a reference to a 'VkSurfaceKHR' handle in which the created surface is returned.
   */
  export function vkCreateDisplayPlaneSurfaceKHR(
    instance: VkInstance | null,
    pCreateInfo: VkDisplaySurfaceCreateInfoKHR | null,
    pAllocator: null,
    pSurface: VkSurfaceKHR | null
  ): VkResult

  /**
   * Create multiple swapchains that share presentable images
   * @param device is the device to create the swapchains for.
   * @param swapchainCount is the number of swapchains to create.
   * @param pCreateInfos is an array of 'VkSwapchainCreateInfoKHR' structures specifying the parameters of the created swapchains.
   * @param pAllocator is the allocator used for host memory allocated for the swapchain objects when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSwapchains is an array of 'VkSwapchainKHR' handles in which the created swapchain objects will be returned.
   */
  export function vkCreateSharedSwapchainsKHR(
    device: VkDevice | null,
    swapchainCount: number,
    pCreateInfos: VkSwapchainCreateInfoKHR[] | null,
    pAllocator: null,
    pSwapchains: VkSwapchainKHR[] | null
  ): VkResult

  /**
   * Destroy a VkSurfaceKHR object
   * @param instance is the instance used to create the surface.
   * @param surface is the surface to destroy.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   */
  export function vkDestroySurfaceKHR(
    instance: VkInstance | null,
    surface: VkSurfaceKHR | null,
    pAllocator: null
  ): void

  /**
   * Query if presentation is supported
   * @param physicalDevice is the physical device.
   * @param queueFamilyIndex is the queue family.
   * @param surface is the surface.
   * @param pSupported is a reference to a 'VkInout', which is set to 'VK_TRUE' to indicate support, and 'VK_FALSE' otherwise.
   */
  export function vkGetPhysicalDeviceSurfaceSupportKHR(
    physicalDevice: VkPhysicalDevice | null,
    queueFamilyIndex: number,
    surface: VkSurfaceKHR | null,
    pSupported: VkInout | null
  ): VkResult

  /**
   * Query surface capabilities
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pSurfaceCapabilities is a reference to a 'VkSurfaceCapabilitiesKHR' structure in which the capabilities are returned.
   */
  export function vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    physicalDevice: VkPhysicalDevice | null,
    surface: VkSurfaceKHR | null,
    pSurfaceCapabilities: VkSurfaceCapabilitiesKHR | null
  ): VkResult

  /**
   * Query color formats supported by surface
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pSurfaceFormatCount is a reference to a number related to the number of format pairs available or queried, as described below.
   * @param pSurfaceFormats is either <i>null</i> or a reference to an array of 'VkSurfaceFormatKHR' structures.
   */
  export function vkGetPhysicalDeviceSurfaceFormatsKHR(
    physicalDevice: VkPhysicalDevice | null,
    surface: VkSurfaceKHR | null,
    pSurfaceFormatCount: VkInout | null,
    pSurfaceFormats: VkSurfaceFormatKHR[] | null
  ): VkResult

  /**
   * Query supported presentation modes
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pPresentModeCount is a reference to a number related to the number of presentation modes available or queried, as described below.
   * @param pPresentModes is either <i>null</i> or a reference to an array of 'VkPresentModeKHR' values, indicating the supported presentation modes.
   */
  export function vkGetPhysicalDeviceSurfacePresentModesKHR(
    physicalDevice: VkPhysicalDevice | null,
    surface: VkSurfaceKHR | null,
    pPresentModeCount: VkInout | null,
    pPresentModes: Int32Array | null
  ): VkResult

  /**
   * Create a swapchain
   * @param device is the device to create the swapchain for.
   * @param pCreateInfo is a reference to a 'VkSwapchainCreateInfoKHR' structure specifying the parameters of the created swapchain.
   * @param pAllocator is the allocator used for host memory allocated for the swapchain object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSwapchain is a reference to a 'VkSwapchainKHR' handle in which the created swapchain object will be returned.
   */
  export function vkCreateSwapchainKHR(
    device: VkDevice | null,
    pCreateInfo: VkSwapchainCreateInfoKHR | null,
    pAllocator: null,
    pSwapchain: VkSwapchainKHR | null
  ): VkResult

  /**
   * Destroy a swapchain object
   * @param device
   * @param swapchain is the swapchain to destroy.
   * @param pAllocator is the allocator used for host memory allocated for the swapchain object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   */
  export function vkDestroySwapchainKHR(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null,
    pAllocator: null
  ): void

  /**
   * Obtain the array of presentable images associated with a swapchain
   * @param device
   * @param swapchain is the swapchain to query.
   * @param pSwapchainImageCount is a reference to a number related to the number of presentable images available or queried, as described below.
   * @param pSwapchainImages is either <i>null</i> or a reference to an array of 'VkImage' handles.
   */
  export function vkGetSwapchainImagesKHR(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null,
    pSwapchainImageCount: VkInout | null,
    pSwapchainImages: VkImage[] | null
  ): VkResult

  /**
   * Retrieve the index of the next available presentable image
   * @param device
   * @param swapchain is the non-retired swapchain from which an image is being acquired.
   * @param timeout specifies how long the function waits, in nanoseconds, if no image is available.
   * @param semaphore is 'VK_NULL_HANDLE' or a semaphore to signal.
   * @param fence is 'VK_NULL_HANDLE' or a fence to signal.
   * @param pImageIndex is a reference to a 'uint32_t' in which the index of the next image to use (i.e. an index into the array of images returned by 'vkGetSwapchainImagesKHR') is returned.
   */
  export function vkAcquireNextImageKHR(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null,
    timeout: bigint | number,
    semaphore: VkSemaphore | null,
    fence: VkFence | null,
    pImageIndex: VkInout | null
  ): VkResult

  /**
   * Queue an image for presentation
   * @param queue is a queue that is capable of presentation to the target surface's platform on the same device as the image's swapchain.
   * @param pPresentInfo is a reference to a 'VkPresentInfoKHR' structure specifying parameters of the presentation.
   */
  export function vkQueuePresentKHR(
    queue: VkQueue | null,
    pPresentInfo: VkPresentInfoKHR | null
  ): VkResult

  /**
   * Create a {#0#} object for an Win32 native window
   * @param instance is the instance to associate the surface with.
   * @param pCreateInfo is a reference to a 'VkWin32SurfaceCreateInfoKHR' structure containing parameters affecting the creation of the surface object.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSurface is a reference to a 'VkSurfaceKHR' handle in which the created surface object is returned.
   */
  export function vkCreateWin32SurfaceKHR(
    instance: VkInstance | null,
    pCreateInfo: VkWin32SurfaceCreateInfoKHR | null,
    pAllocator: null,
    pSurface: VkSurfaceKHR | null
  ): VkResult

  /**
   * query queue family support for presentation on a Win32 display
   * @param physicalDevice is the physical device.
   * @param queueFamilyIndex is the queue family index.
   */
  export function vkGetPhysicalDeviceWin32PresentationSupportKHR(
    physicalDevice: VkPhysicalDevice | null,
    queueFamilyIndex: number
  ): number

  /**
   * Create a debug report callback object
   * @param instance the instance the callback will be logged on.
   * @param pCreateInfo is a reference to a 'VkDebugReportCallbackCreateInfoEXT' structure defining the conditions under which this callback will be called.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pCallback is a reference to a 'VkDebugReportCallbackEXT' handle in which the created object is returned.
   */
  export function vkCreateDebugReportCallbackEXT(
    instance: VkInstance | null,
    pCreateInfo: VkDebugReportCallbackCreateInfoEXT | null,
    pAllocator: null,
    pCallback: VkDebugReportCallbackEXT | null
  ): VkResult

  /**
   * Destroy a debug report callback object
   * @param instance the instance where the callback was created.
   * @param callback the 'VkDebugReportCallbackEXT' object to destroy. 'callback' is an externally synchronized object and 'must' not be used on more than one thread at a time. This means that 'vkDestroyDebugReportCallbackEXT' 'must' not be called when a callback is active.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDebugReportCallbackEXT(
    instance: VkInstance | null,
    callback: VkDebugReportCallbackEXT | null,
    pAllocator: null
  ): void

  /**
   * Inject a message into a debug stream
   * @param instance is the debug stream's 'VkInstance'.
   * @param flags specifies the 'VkDebugReportFlagBitsEXT' classification of this event/message.
   * @param objectType is a 'VkDebugReportObjectTypeEXT' specifying the type of object being used or created at the time the event was triggered.
   * @param object this is the object where the issue was detected. 'object' 'can' be 'VK_NULL_HANDLE' if there is no object associated with the event.
   * @param location is an application defined value.
   * @param messageCode is an application defined value.
   * @param pLayerPrefix is the abbreviation of the component making this event/message.
   * @param pMessage is a string detailing the trigger conditions.
   */
  export function vkDebugReportMessageEXT(
    instance: VkInstance | null,
    flags: VkDebugReportFlagBitsEXT,
    objectType: VkDebugReportObjectTypeEXT,
    object: bigint | number,
    location: bigint | number,
    messageCode: number,
    pLayerPrefix: string | null,
    pMessage: string | null
  ): void

  /**
   * Give a user-friendly name to an object
   * @param device is the device that created the object.
   * @param pNameInfo is a reference to a 'VkDebugMarkerObjectNameInfoEXT' structure specifying the parameters of the name to set on the object.
   */
  export function vkDebugMarkerSetObjectNameEXT(
    device: VkDevice | null,
    pNameInfo: VkDebugMarkerObjectNameInfoEXT | null
  ): VkResult

  /**
   * Attach arbitrary data to an object
   * @param device is the device that created the object.
   * @param pTagInfo is a reference to a 'VkDebugMarkerObjectTagInfoEXT' structure specifying the parameters of the tag to attach to the object.
   */
  export function vkDebugMarkerSetObjectTagEXT(
    device: VkDevice | null,
    pTagInfo: VkDebugMarkerObjectTagInfoEXT | null
  ): VkResult

  /**
   * Open a command buffer marker region
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pMarkerInfo is a reference to a 'VkDebugMarkerMarkerInfoEXT' structure specifying the parameters of the marker region to open.
   */
  export function vkCmdDebugMarkerBeginEXT(
    commandBuffer: VkCommandBuffer | null,
    pMarkerInfo: VkDebugMarkerMarkerInfoEXT | null
  ): void

  /**
   * Close a command buffer marker region
   * @param commandBuffer is the command buffer into which the command is recorded.
   */
  export function vkCmdDebugMarkerEndEXT(
    commandBuffer: VkCommandBuffer | null
  ): void

  /**
   * Insert a marker label into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pMarkerInfo is a reference to a 'VkDebugMarkerMarkerInfoEXT' structure specifying the parameters of the marker to insert.
   */
  export function vkCmdDebugMarkerInsertEXT(
    commandBuffer: VkCommandBuffer | null,
    pMarkerInfo: VkDebugMarkerMarkerInfoEXT | null
  ): void

  /**
   * determine image capabilities compatible with external memory handle types
   * @param physicalDevice is the physical device from which to query the image capabilities
   * @param format is the image format, corresponding to 'VkImageCreateInfo'::'format'.
   * @param type is the image type, corresponding to 'VkImageCreateInfo'::'imageType'.
   * @param tiling is the image tiling, corresponding to 'VkImageCreateInfo'::'tiling'.
   * @param usage is the intended usage of the image, corresponding to 'VkImageCreateInfo'::'usage'.
   * @param flags is a bitmask describing additional parameters of the image, corresponding to 'VkImageCreateInfo'::'flags'.
   * @param externalHandleType is either one of the bits from 'VkExternalMemoryHandleTypeFlagBitsNV', or 0.
   * @param pExternalImageFormatProperties is a reference to a 'VkExternalImageFormatPropertiesNV' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    physicalDevice: VkPhysicalDevice | null,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlagBits,
    flags: VkImageCreateFlagBits,
    externalHandleType: VkExternalMemoryHandleTypeFlagBitsNV,
    pExternalImageFormatProperties: VkExternalImageFormatPropertiesNV | null
  ): VkResult

  /**
   * retrieve Win32 handle to a device memory object
   * @param device is the logical device that owns the memory.
   * @param memory is the 'VkDeviceMemory' object.
   * @param handleType is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a single bit specifying the type of handle requested.
   * @param pHandle
   */
  export function vkGetMemoryWin32HandleNV(
    device: VkDevice | null,
    memory: VkDeviceMemory | null,
    handleType: VkExternalMemoryHandleTypeFlagBitsNV,
    pHandle: VkInoutAddress | null
  ): VkResult

  /**
   * Performs the generation of commands on the device
   * @param commandBuffer is the primary command buffer in which the generation process takes space.
   * @param pProcessCommandsInfo is a reference to a 'VkCmdProcessCommandsInfoNVX' structure containing parameters affecting the processing of commands.
   */
  export function vkCmdProcessCommandsNVX(
    commandBuffer: VkCommandBuffer | null,
    pProcessCommandsInfo: VkCmdProcessCommandsInfoNVX | null
  ): void

  /**
   * Perform a reservation of command buffer space
   * @param commandBuffer is the secondary command buffer in which the space for device-generated commands is reserved.
   * @param pReserveSpaceInfo
   */
  export function vkCmdReserveSpaceForCommandsNVX(
    commandBuffer: VkCommandBuffer | null,
    pReserveSpaceInfo: VkCmdReserveSpaceForCommandsInfoNVX | null
  ): void

  /**
   * Create an indirect command layout object
   * @param device is the logical device that creates the indirect command layout.
   * @param pCreateInfo is a reference to a 'VkIndirectCommandsLayoutCreateInfoNVX' structure containing parameters affecting creation of the indirect command layout.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pIndirectCommandsLayout is a reference to a 'VkIndirectCommandsLayoutNVX' handle in which the resulting indirect command layout is returned.
   */
  export function vkCreateIndirectCommandsLayoutNVX(
    device: VkDevice | null,
    pCreateInfo: VkIndirectCommandsLayoutCreateInfoNVX | null,
    pAllocator: null,
    pIndirectCommandsLayout: VkIndirectCommandsLayoutNVX | null
  ): VkResult

  /**
   * Destroy an object table
   * @param device is the logical device that destroys the layout.
   * @param indirectCommandsLayout is the table to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyIndirectCommandsLayoutNVX(
    device: VkDevice | null,
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX | null,
    pAllocator: null
  ): void

  /**
   * Create an object table
   * @param device is the logical device that creates the object table.
   * @param pCreateInfo is a reference to a 'VkObjectTableCreateInfoNVX' structure containing parameters affecting creation of the table.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pObjectTable is a reference to a 'VkObjectTableNVX' handle in which the resulting object table is returned.
   */
  export function vkCreateObjectTableNVX(
    device: VkDevice | null,
    pCreateInfo: VkObjectTableCreateInfoNVX | null,
    pAllocator: null,
    pObjectTable: VkObjectTableNVX | null
  ): VkResult

  /**
   * Destroy an object table
   * @param device is the logical device that destroys the table.
   * @param objectTable is the table to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyObjectTableNVX(
    device: VkDevice | null,
    objectTable: VkObjectTableNVX | null,
    pAllocator: null
  ): void

  /**
   * Register resource bindings in an object table
   * @param device is the logical device that creates the object table.
   * @param objectTable is the table for which the resources are registered.
   * @param objectCount is the number of resources to register.
   * @param ppObjectTableEntries provides an array for detailed binding informations. Each array element is a reference to a structure of type 'VkObjectTablePipelineEntryNVX', 'VkObjectTableDescriptorSetEntryNVX', 'VkObjectTableVertexBufferEntryNVX', 'VkObjectTableIndexBufferEntryNVX' or 'VkObjectTablePushConstantEntryNVX' (see below for details).
   * @param pObjectIndices are the indices at which each resource is registered.
   */
  export function vkRegisterObjectsNVX(
    device: VkDevice | null,
    objectTable: VkObjectTableNVX | null,
    objectCount: number,
    ppObjectTableEntries: VkObjectTableEntryNVX[] | null,
    pObjectIndices: Uint32Array | null
  ): VkResult

  /**
   * Unregister resource bindings in an object table
   * @param device is the logical device that creates the object table.
   * @param objectTable is the table from which the resources are unregistered.
   * @param objectCount is the number of resources being removed from the object table.
   * @param pObjectEntryTypes
   * @param pObjectIndices provides the array of object indices to be removed.
   */
  export function vkUnregisterObjectsNVX(
    device: VkDevice | null,
    objectTable: VkObjectTableNVX | null,
    objectCount: number,
    pObjectEntryTypes: Int32Array | null,
    pObjectIndices: Uint32Array | null
  ): VkResult

  /**
   * Returns device-generated commands related properties of a physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pFeatures is a reference to a 'VkDeviceGeneratedCommandsFeaturesNVX' structure in which features are returned.
   * @param pLimits is a reference to a 'VkDeviceGeneratedCommandsLimitsNVX' structure in which limitations are returned.
   */
  export function vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    physicalDevice: VkPhysicalDevice | null,
    pFeatures: VkDeviceGeneratedCommandsFeaturesNVX | null,
    pLimits: VkDeviceGeneratedCommandsLimitsNVX | null
  ): void

  /**
   * Reports capabilities of a physical device
   * @param physicalDevice is the physical device from which to query the supported features.
   * @param pFeatures is a reference to a 'VkPhysicalDeviceFeatures2' structure in which the physical device features are returned.
   */
  export function vkGetPhysicalDeviceFeatures2(
    physicalDevice: VkPhysicalDevice | null,
    pFeatures: VkPhysicalDeviceFeatures2 | null
  ): void

  /**
   * Returns properties of a physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pProperties is a reference to a 'VkPhysicalDeviceProperties2' structure in which properties are returned.
   */
  export function vkGetPhysicalDeviceProperties2(
    physicalDevice: VkPhysicalDevice | null,
    pProperties: VkPhysicalDeviceProperties2 | null
  ): void

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the format properties.
   * @param format is the format whose properties are queried.
   * @param pFormatProperties is a reference to a 'VkFormatProperties2' structure in which physical device properties for 'format' are returned.
   */
  export function vkGetPhysicalDeviceFormatProperties2(
    physicalDevice: VkPhysicalDevice | null,
    format: VkFormat,
    pFormatProperties: VkFormatProperties2 | null
  ): void

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the image capabilities.
   * @param pImageFormatInfo is a reference to a 'VkPhysicalDeviceImageFormatInfo2' structure describing the parameters that would be consumed by 'vkCreateImage'.
   * @param pImageFormatProperties is a reference to a 'VkImageFormatProperties2' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceImageFormatProperties2(
    physicalDevice: VkPhysicalDevice | null,
    pImageFormatInfo: VkPhysicalDeviceImageFormatInfo2 | null,
    pImageFormatProperties: VkImageFormatProperties2 | null
  ): VkResult

  /**
   * Reports properties of the queues of the specified physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pQueueFamilyPropertyCount is a reference to a number related to the number of queue families available or queried, as described in 'vkGetPhysicalDeviceQueueFamilyProperties'.
   * @param pQueueFamilyProperties is either <i>null</i> or a reference to an array of 'VkQueueFamilyProperties2' structures.
   */
  export function vkGetPhysicalDeviceQueueFamilyProperties2(
    physicalDevice: VkPhysicalDevice | null,
    pQueueFamilyPropertyCount: VkInout | null,
    pQueueFamilyProperties: VkQueueFamilyProperties2[] | null
  ): void

  /**
   * Reports memory information for the specified physical device
   * @param physicalDevice is the handle to the device to query.
   * @param pMemoryProperties is a reference to a 'VkPhysicalDeviceMemoryProperties2' structure in which the properties are returned.
   */
  export function vkGetPhysicalDeviceMemoryProperties2(
    physicalDevice: VkPhysicalDevice | null,
    pMemoryProperties: VkPhysicalDeviceMemoryProperties2 | null
  ): void

  /**
   * Retrieve properties of an image format applied to sparse images
   * @param physicalDevice is the physical device from which to query the sparse image capabilities.
   * @param pFormatInfo is a reference to a 'VkPhysicalDeviceSparseImageFormatInfo2' structure containing input parameters to the command.
   * @param pPropertyCount is a reference to a number related to the number of sparse format properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkSparseImageFormatProperties2' structures.
   */
  export function vkGetPhysicalDeviceSparseImageFormatProperties2(
    physicalDevice: VkPhysicalDevice | null,
    pFormatInfo: VkPhysicalDeviceSparseImageFormatInfo2 | null,
    pPropertyCount: VkInout | null,
    pProperties: VkSparseImageFormatProperties2[] | null
  ): void

  /**
   * Pushes descriptor updates into a command buffer
   * @param commandBuffer is the command buffer that the descriptors will be recorded in.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' indicating whether the descriptors will be used by graphics pipelines or compute pipelines. There is a separate set of push descriptor bindings for each of graphics and compute, so binding one does not disturb the other.
   * @param layout is a 'VkPipelineLayout' object used to program the bindings.
   * @param set is the set number of the descriptor set in the pipeline layout that will be updated.
   * @param descriptorWriteCount is the number of elements in the 'pDescriptorWrites' array.
   * @param pDescriptorWrites is an array of 'VkWriteDescriptorSet' structures describing the descriptors to be updated.
   */
  export function vkCmdPushDescriptorSetKHR(
    commandBuffer: VkCommandBuffer | null,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout | null,
    set: number,
    descriptorWriteCount: number,
    pDescriptorWrites: VkWriteDescriptorSet[] | null
  ): void

  /**
   * Trim a command pool
   * @param device is the logical device that owns the command pool.
   * @param commandPool is the command pool to trim.
   * @param flags is reserved for future use.
   */
  export function vkTrimCommandPool(
    device: VkDevice | null,
    commandPool: VkCommandPool | null,
    flags: number
  ): void

  /**
   * Query external handle types supported by buffers
   * @param physicalDevice is the physical device from which to query the buffer capabilities.
   * @param pExternalBufferInfo is a reference to a 'VkPhysicalDeviceExternalBufferInfo' structure describing the parameters that would be consumed by 'vkCreateBuffer'.
   * @param pExternalBufferProperties is a reference to a 'VkExternalBufferProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalBufferProperties(
    physicalDevice: VkPhysicalDevice | null,
    pExternalBufferInfo: VkPhysicalDeviceExternalBufferInfo | null,
    pExternalBufferProperties: VkExternalBufferProperties | null
  ): void

  /**
   * Get a Windows HANDLE for a memory object
   * @param device is the logical device that created the device memory being exported.
   * @param pGetWin32HandleInfo is a reference to a 'VkMemoryGetWin32HandleInfoKHR' structure containing parameters of the export operation.
   * @param pHandle will return the Windows handle representing the underlying resources of the device memory object.
   */
  export function vkGetMemoryWin32HandleKHR(
    device: VkDevice | null,
    pGetWin32HandleInfo: VkMemoryGetWin32HandleInfoKHR | null,
    pHandle: VkInoutAddress | null
  ): VkResult

  /**
   * Get Properties of External Memory Win32 Handles
   * @param device
   * @param handleType
   * @param handle is the handle which will be imported.
   * @param pMemoryWin32HandleProperties will return properties of 'handle'.
   */
  export function vkGetMemoryWin32HandlePropertiesKHR(
    device: VkDevice | null,
    handleType: VkExternalMemoryHandleTypeFlagBits,
    handle: bigint | number,
    pMemoryWin32HandleProperties: VkMemoryWin32HandlePropertiesKHR | null
  ): VkResult

  /**
   * Get a POSIX file descriptor for a memory object
   * @param device is the logical device that created the device memory being exported.
   * @param pGetFdInfo is a reference to a 'VkMemoryGetFdInfoKHR' structure containing parameters of the export operation.
   * @param pFd will return a file descriptor representing the underlying resources of the device memory object.
   */
  export function vkGetMemoryFdKHR(
    device: VkDevice | null,
    pGetFdInfo: VkMemoryGetFdInfoKHR | null,
    pFd: VkInout | null
  ): VkResult

  /**
   * Get Properties of External Memory File Descriptors
   * @param device
   * @param handleType
   * @param fd is the handle which will be imported.
   * @param pMemoryFdProperties is a reference to a 'VkMemoryFdPropertiesKHR' structure in which the properties of the handle 'fd' are returned.
   */
  export function vkGetMemoryFdPropertiesKHR(
    device: VkDevice | null,
    handleType: VkExternalMemoryHandleTypeFlagBits,
    fd: number,
    pMemoryFdProperties: VkMemoryFdPropertiesKHR | null
  ): VkResult

  /**
   * Function for querying external semaphore handle capabilities.
   * @param physicalDevice is the physical device from which to query the semaphore capabilities.
   * @param pExternalSemaphoreInfo is a reference to a 'VkPhysicalDeviceExternalSemaphoreInfo' structure describing the parameters that would be consumed by 'vkCreateSemaphore'.
   * @param pExternalSemaphoreProperties is a reference to a 'VkExternalSemaphoreProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalSemaphoreProperties(
    physicalDevice: VkPhysicalDevice | null,
    pExternalSemaphoreInfo: VkPhysicalDeviceExternalSemaphoreInfo | null,
    pExternalSemaphoreProperties: VkExternalSemaphoreProperties | null
  ): void

  /**
   * Get a Windows HANDLE for a semaphore
   * @param device is the logical device that created the semaphore being exported.
   * @param pGetWin32HandleInfo is a reference to a 'VkSemaphoreGetWin32HandleInfoKHR' structure containing parameters of the export operation.
   * @param pHandle will return the Windows handle representing the semaphore state.
   */
  export function vkGetSemaphoreWin32HandleKHR(
    device: VkDevice | null,
    pGetWin32HandleInfo: VkSemaphoreGetWin32HandleInfoKHR | null,
    pHandle: VkInoutAddress | null
  ): VkResult

  /**
   * Import a semaphore from a Windows HANDLE
   * @param device is the logical device that created the semaphore.
   * @param pImportSemaphoreWin32HandleInfo is a reference to a 'VkImportSemaphoreWin32HandleInfoKHR' structure specifying the semaphore and import parameters.
   */
  export function vkImportSemaphoreWin32HandleKHR(
    device: VkDevice | null,
    pImportSemaphoreWin32HandleInfo: VkImportSemaphoreWin32HandleInfoKHR | null
  ): VkResult

  /**
   * Get a POSIX file descriptor handle for a semaphore
   * @param device is the logical device that created the semaphore being exported.
   * @param pGetFdInfo is a reference to a 'VkSemaphoreGetFdInfoKHR' structure containing parameters of the export operation.
   * @param pFd will return the file descriptor representing the semaphore payload.
   */
  export function vkGetSemaphoreFdKHR(
    device: VkDevice | null,
    pGetFdInfo: VkSemaphoreGetFdInfoKHR | null,
    pFd: VkInout | null
  ): VkResult

  /**
   * Import a semaphore from a POSIX file descriptor
   * @param device is the logical device that created the semaphore.
   * @param pImportSemaphoreFdInfo is a reference to a 'VkImportSemaphoreFdInfoKHR' structure specifying the semaphore and import parameters.
   */
  export function vkImportSemaphoreFdKHR(
    device: VkDevice | null,
    pImportSemaphoreFdInfo: VkImportSemaphoreFdInfoKHR | null
  ): VkResult

  /**
   * Function for querying external fence handle capabilities.
   * @param physicalDevice is the physical device from which to query the fence capabilities.
   * @param pExternalFenceInfo is a reference to a 'VkPhysicalDeviceExternalFenceInfo' structure describing the parameters that would be consumed by 'vkCreateFence'.
   * @param pExternalFenceProperties is a reference to a 'VkExternalFenceProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalFenceProperties(
    physicalDevice: VkPhysicalDevice | null,
    pExternalFenceInfo: VkPhysicalDeviceExternalFenceInfo | null,
    pExternalFenceProperties: VkExternalFenceProperties | null
  ): void

  /**
   * Get a Windows HANDLE for a fence
   * @param device is the logical device that created the fence being exported.
   * @param pGetWin32HandleInfo is a reference to a 'VkFenceGetWin32HandleInfoKHR' structure containing parameters of the export operation.
   * @param pHandle will return the Windows handle representing the fence state.
   */
  export function vkGetFenceWin32HandleKHR(
    device: VkDevice | null,
    pGetWin32HandleInfo: VkFenceGetWin32HandleInfoKHR | null,
    pHandle: VkInoutAddress | null
  ): VkResult

  /**
   * Import a fence from a Windows HANDLE
   * @param device is the logical device that created the fence.
   * @param pImportFenceWin32HandleInfo is a reference to a 'VkImportFenceWin32HandleInfoKHR' structure specifying the fence and import parameters.
   */
  export function vkImportFenceWin32HandleKHR(
    device: VkDevice | null,
    pImportFenceWin32HandleInfo: VkImportFenceWin32HandleInfoKHR | null
  ): VkResult

  /**
   * Get a POSIX file descriptor handle for a fence
   * @param device is the logical device that created the fence being exported.
   * @param pGetFdInfo is a reference to a 'VkFenceGetFdInfoKHR' structure containing parameters of the export operation.
   * @param pFd will return the file descriptor representing the fence payload.
   */
  export function vkGetFenceFdKHR(
    device: VkDevice | null,
    pGetFdInfo: VkFenceGetFdInfoKHR | null,
    pFd: VkInout | null
  ): VkResult

  /**
   * Import a fence from a POSIX file descriptor
   * @param device is the logical device that created the fence.
   * @param pImportFenceFdInfo is a reference to a 'VkImportFenceFdInfoKHR' structure specifying the fence and import parameters.
   */
  export function vkImportFenceFdKHR(
    device: VkDevice | null,
    pImportFenceFdInfo: VkImportFenceFdInfoKHR | null
  ): VkResult

  /**
   * Release access to an acquired VkDisplayKHR
   * @param physicalDevice The physical device the display is on.
   * @param display The display to release control of.
   */
  export function vkReleaseDisplayEXT(
    physicalDevice: VkPhysicalDevice | null,
    display: VkDisplayKHR | null
  ): VkResult

  /**
   * Set the power state of a display
   * @param device
   * @param display is the display whose power state is modified.
   * @param pDisplayPowerInfo is an instance of 'VkDisplayPowerInfoEXT' specifying the new power state of 'display'.
   */
  export function vkDisplayPowerControlEXT(
    device: VkDevice | null,
    display: VkDisplayKHR | null,
    pDisplayPowerInfo: VkDisplayPowerInfoEXT | null
  ): VkResult

  /**
   * Signal a fence when a device event occurs
   * @param device is a logical device on which the event 'may' occur.
   * @param pDeviceEventInfo is a reference to a 'VkDeviceEventInfoEXT' structure describing the event of interest to the application.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFence is a reference to a handle in which the resulting fence object is returned.
   */
  export function vkRegisterDeviceEventEXT(
    device: VkDevice | null,
    pDeviceEventInfo: VkDeviceEventInfoEXT | null,
    pAllocator: null,
    pFence: VkFence | null
  ): VkResult

  /**
   * Signal a fence when a display event occurs
   * @param device
   * @param display is the display on which the event 'may' occur.
   * @param pDisplayEventInfo is a reference to a 'VkDisplayEventInfoEXT' structure describing the event of interest to the application.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFence is a reference to a handle in which the resulting fence object is returned.
   */
  export function vkRegisterDisplayEventEXT(
    device: VkDevice | null,
    display: VkDisplayKHR | null,
    pDisplayEventInfo: VkDisplayEventInfoEXT | null,
    pAllocator: null,
    pFence: VkFence | null
  ): VkResult

  /**
   * Query the current value of a surface counter
   * @param device
   * @param swapchain is the swapchain from which to query the counter value.
   * @param counter is the counter to query.
   * @param pCounterValue will return the current value of the counter.
   */
  export function vkGetSwapchainCounterEXT(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null,
    counter: VkSurfaceCounterFlagBitsEXT,
    pCounterValue: VkInoutAddress | null
  ): VkResult

  /**
   * Query surface capabilities
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pSurfaceCapabilities is a reference to a 'VkSurfaceCapabilities2EXT' structure in which the capabilities are returned.
   */
  export function vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    physicalDevice: VkPhysicalDevice | null,
    surface: VkSurfaceKHR | null,
    pSurfaceCapabilities: VkSurfaceCapabilities2EXT | null
  ): VkResult

  /**
   * Enumerates groups of physical devices that can be used to create a single logical device
   * @param instance is a handle to a Vulkan instance previously created with 'vkCreateInstance'.
   * @param pPhysicalDeviceGroupCount is a reference to a number related to the number of device groups available or queried, as described below.
   * @param pPhysicalDeviceGroupProperties is either <i>null</i> or a reference to an array of 'VkPhysicalDeviceGroupProperties' structures.
   */
  export function vkEnumeratePhysicalDeviceGroups(
    instance: VkInstance | null,
    pPhysicalDeviceGroupCount: VkInout | null,
    pPhysicalDeviceGroupProperties: VkPhysicalDeviceGroupProperties[] | null
  ): VkResult

  /**
   * Query supported peer memory features of a device
   * @param device is the logical device that owns the memory.
   * @param heapIndex is the index of the memory heap from which the memory is allocated.
   * @param localDeviceIndex is the device index of the physical device that performs the memory access.
   * @param remoteDeviceIndex is the device index of the physical device that the memory is allocated for.
   * @param pPeerMemoryFeatures is a reference to a 'VkPeerMemoryFeatureFlags' bitmask indicating which types of memory accesses are supported for the combination of heap, local, and remote devices.
   */
  export function vkGetDeviceGroupPeerMemoryFeatures(
    device: VkDevice | null,
    heapIndex: number,
    localDeviceIndex: number,
    remoteDeviceIndex: number,
    pPeerMemoryFeatures: VkInout | null
  ): void

  /**
   * Bind device memory to buffer objects
   * @param device is the logical device that owns the buffers and memory.
   * @param bindInfoCount 'VkBindBufferMemoryInfo' structures describing buffers and memory to bind.
   * @param pBindInfos
   */
  export function vkBindBufferMemory2(
    device: VkDevice | null,
    bindInfoCount: number,
    pBindInfos: VkBindBufferMemoryInfo[] | null
  ): VkResult

  /**
   * Bind device memory to image objects
   * @param device is the logical device that owns the images and memory.
   * @param bindInfoCount
   * @param pBindInfos is an array of 'VkBindImageMemoryInfo' structures, describing images and memory to bind.
   */
  export function vkBindImageMemory2(
    device: VkDevice | null,
    bindInfoCount: number,
    pBindInfos: VkBindImageMemoryInfo[] | null
  ): VkResult

  /**
   * Modify device mask of a command buffer
   * @param commandBuffer is command buffer whose current device mask is modified.
   * @param deviceMask is the new value of the current device mask.
   */
  export function vkCmdSetDeviceMask(
    commandBuffer: VkCommandBuffer | null,
    deviceMask: number
  ): void

  /**
   * Query present capabilities from other physical devices
   * @param device is the logical device.
   * @param pDeviceGroupPresentCapabilities is a reference to a 'VkDeviceGroupPresentCapabilitiesKHR' structure in which the device's capabilities are returned.
   */
  export function vkGetDeviceGroupPresentCapabilitiesKHR(
    device: VkDevice | null,
    pDeviceGroupPresentCapabilities: VkDeviceGroupPresentCapabilitiesKHR | null
  ): VkResult

  /**
   * Query present capabilities for a surface
   * @param device is the logical device.
   * @param surface is the surface.
   * @param pModes is a reference to a 'VkDeviceGroupPresentModeFlagsKHR' in which the supported device group present modes for the surface are returned.
   */
  export function vkGetDeviceGroupSurfacePresentModesKHR(
    device: VkDevice | null,
    surface: VkSurfaceKHR | null,
    pModes: VkInout | null
  ): VkResult

  /**
   * Retrieve the index of the next available presentable image
   * @param device
   * @param pAcquireInfo is a reference to a 'VkAcquireNextImageInfoKHR' structure containing parameters of the acquire.
   * @param pImageIndex is a reference to a 'uint32_t' that is set to the index of the next image to use.
   */
  export function vkAcquireNextImage2KHR(
    device: VkDevice | null,
    pAcquireInfo: VkAcquireNextImageInfoKHR | null,
    pImageIndex: VkInout | null
  ): VkResult

  /**
   * Dispatch compute work items
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param baseGroupX is the start value for the X component of 'WorkgroupId'.
   * @param baseGroupY is the start value for the Y component of 'WorkgroupId'.
   * @param baseGroupZ is the start value for the Z component of 'WorkgroupId'.
   * @param groupCountX is the number of local workgroups to dispatch in the X dimension.
   * @param groupCountY is the number of local workgroups to dispatch in the Y dimension.
   * @param groupCountZ is the number of local workgroups to dispatch in the Z dimension.
   */
  export function vkCmdDispatchBase(
    commandBuffer: VkCommandBuffer | null,
    baseGroupX: number,
    baseGroupY: number,
    baseGroupZ: number,
    groupCountX: number,
    groupCountY: number,
    groupCountZ: number
  ): void

  /**
   * Query present rectangles for a surface on a physical device
   * @param physicalDevice is the physical device.
   * @param surface is the surface.
   * @param pRectCount is a reference to a number related to the number of rectangles available or queried, as described below.
   * @param pRects is either <i>null</i> or a reference to an array of 'VkRect2D' structures.
   */
  export function vkGetPhysicalDevicePresentRectanglesKHR(
    physicalDevice: VkPhysicalDevice | null,
    surface: VkSurfaceKHR | null,
    pRectCount: VkInout | null,
    pRects: VkRect2D[] | null
  ): VkResult

  /**
   * Create a new descriptor update template
   * @param device is the logical device that creates the descriptor update template.
   * @param pCreateInfo is a reference to a 'VkDescriptorUpdateTemplateCreateInfo' structure specifying the set of descriptors to update with a single call to 'vkCmdPushDescriptorSetWithTemplateKHR' or
   * @param pAllocator
   * @param pDescriptorUpdateTemplate
   */
  export function vkCreateDescriptorUpdateTemplate(
    device: VkDevice | null,
    pCreateInfo: VkDescriptorUpdateTemplateCreateInfo | null,
    pAllocator: null,
    pDescriptorUpdateTemplate: VkDescriptorUpdateTemplate | null
  ): VkResult

  /**
   * Destroy a descriptor update template object
   * @param device is the logical device that has been used to create the descriptor update template
   * @param descriptorUpdateTemplate is the descriptor update template to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDescriptorUpdateTemplate(
    device: VkDevice | null,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate | null,
    pAllocator: null
  ): void

  /**
   * Update the contents of a descriptor set object using an update template
   * @param device is the logical device that updates the descriptor sets.
   * @param descriptorSet is the descriptor set to update
   * @param descriptorUpdateTemplate is a 'VkDescriptorUpdateTemplate' object specifying the update mapping between 'pData' and the descriptor set to update.
   * @param pData is a reference to memory containing one or more 'VkDescriptorImageInfo', 'VkDescriptorBufferInfo', or 'VkBufferView' structures used to write the descriptors.
   */
  export function vkUpdateDescriptorSetWithTemplate(
    device: VkDevice | null,
    descriptorSet: VkDescriptorSet | null,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate | null,
    pData: ArrayBuffer | null
  ): void

  /**
   * Pushes descriptor updates into a command buffer using a descriptor update template
   * @param commandBuffer is the command buffer that the descriptors will be recorded in.
   * @param descriptorUpdateTemplate is a descriptor update template defining how to interpret the descriptor information in 'pData'.
   * @param layout is a 'VkPipelineLayout' object used to program the bindings. It 'must' be compatible with the layout used to create the 'descriptorUpdateTemplate' handle.
   * @param set is the set number of the descriptor set in the pipeline layout that will be updated. This 'must' be the same number used to create the 'descriptorUpdateTemplate' handle.
   * @param pData is a reference to memory containing descriptors for the templated update.
   */
  export function vkCmdPushDescriptorSetWithTemplateKHR(
    commandBuffer: VkCommandBuffer | null,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate | null,
    layout: VkPipelineLayout | null,
    set: number,
    pData: ArrayBuffer | null
  ): void

  /**
   * function to set Hdr metadata
   * @param device is the logical device where the swapchain(s) were created.
   * @param swapchainCount 'VkHdrMetadataEXT' structures.
   * @param pSwapchains
   * @param pMetadata
   */
  export function vkSetHdrMetadataEXT(
    device: VkDevice | null,
    swapchainCount: number,
    pSwapchains: VkSwapchainKHR[] | null,
    pMetadata: VkHdrMetadataEXT[] | null
  ): void

  /**
   * Get a swapchain\
   * @param device
   * @param swapchain is the swapchain to query.
   */
  export function vkGetSwapchainStatusKHR(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null
  ): VkResult

  /**
   * Obtain the RC duration of the PE\
   * @param device
   * @param swapchain is the swapchain to obtain the refresh duration for.
   * @param pDisplayTimingProperties is a reference to a 'VkRefreshCycleDurationGOOGLE' structure.
   */
  export function vkGetRefreshCycleDurationGOOGLE(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null,
    pDisplayTimingProperties: VkRefreshCycleDurationGOOGLE | null
  ): VkResult

  /**
   * Obtain timing of a previously-presented image
   * @param device
   * @param swapchain is the swapchain to obtain presentation timing information duration for.
   * @param pPresentationTimingCount is a reference to a number related to the number of 'VkPastPresentationTimingGOOGLE' structures to query, as described below.
   * @param pPresentationTimings is either <i>null</i> or a reference to an array of 'VkPastPresentationTimingGOOGLE' structures.
   */
  export function vkGetPastPresentationTimingGOOGLE(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null,
    pPresentationTimingCount: VkInout | null,
    pPresentationTimings: VkPastPresentationTimingGOOGLE[] | null
  ): VkResult

  /**
   * Set the viewport W scaling on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstViewport is the index of the first viewport whose parameters are updated by the command.
   * @param viewportCount is the number of viewports whose parameters are updated by the command.
   * @param pViewportWScalings is an array of 'VkViewportWScalingNV' structures specifying viewport parameters.
   */
  export function vkCmdSetViewportWScalingNV(
    commandBuffer: VkCommandBuffer | null,
    firstViewport: number,
    viewportCount: number,
    pViewportWScalings: VkViewportWScalingNV[] | null
  ): void

  /**
   * Set discard rectangles dynamically
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstDiscardRectangle is the index of the first discard rectangle whose state is updated by the command.
   * @param discardRectangleCount is the number of discard rectangles whose state are updated by the command.
   * @param pDiscardRectangles is an array of 'VkRect2D' structures specifying discard rectangles.
   */
  export function vkCmdSetDiscardRectangleEXT(
    commandBuffer: VkCommandBuffer | null,
    firstDiscardRectangle: number,
    discardRectangleCount: number,
    pDiscardRectangles: VkRect2D[] | null
  ): void

  /**
   * Set the dynamic sample locations state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pSampleLocationsInfo is the sample locations state to set.
   */
  export function vkCmdSetSampleLocationsEXT(
    commandBuffer: VkCommandBuffer | null,
    pSampleLocationsInfo: VkSampleLocationsInfoEXT | null
  ): void

  /**
   * Report sample count specific multisampling capabilities of a physical device
   * @param physicalDevice is the physical device from which to query the additional multisampling capabilities.
   * @param samples is the sample count to query the capabilities for.
   * @param pMultisampleProperties is a reference to a 'VkMultisamplePropertiesEXT' structure in which information about the additional multisampling capabilities specific to the sample count is returned.
   */
  export function vkGetPhysicalDeviceMultisamplePropertiesEXT(
    physicalDevice: VkPhysicalDevice | null,
    samples: VkSampleCountFlagBits,
    pMultisampleProperties: VkMultisamplePropertiesEXT | null
  ): void

  /**
   * Reports capabilities of a surface on a physical device
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pSurfaceCapabilities is a reference to a 'VkSurfaceCapabilities2KHR' structure in which the capabilities are returned.
   */
  export function vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    physicalDevice: VkPhysicalDevice | null,
    pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null,
    pSurfaceCapabilities: VkSurfaceCapabilities2KHR | null
  ): VkResult

  /**
   * Query color formats supported by surface
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pSurfaceFormatCount is a reference to a number related to the number of format tuples available or queried, as described below.
   * @param pSurfaceFormats is either <i>null</i> or a reference to an array of 'VkSurfaceFormat2KHR' structures.
   */
  export function vkGetPhysicalDeviceSurfaceFormats2KHR(
    physicalDevice: VkPhysicalDevice | null,
    pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null,
    pSurfaceFormatCount: VkInout | null,
    pSurfaceFormats: VkSurfaceFormat2KHR[] | null
  ): VkResult

  /**
   * Query information about the available displays
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display devices available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayProperties2KHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayProperties2KHR(
    physicalDevice: VkPhysicalDevice | null,
    pPropertyCount: VkInout | null,
    pProperties: VkDisplayProperties2KHR[] | null
  ): VkResult

  /**
   * Query information about the available display planes.
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display planes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayPlaneProperties2KHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    physicalDevice: VkPhysicalDevice | null,
    pPropertyCount: VkInout | null,
    pProperties: VkDisplayPlaneProperties2KHR[] | null
  ): VkResult

  /**
   * Query information about the available display modes.
   * @param physicalDevice is the physical device associated with 'display'.
   * @param display is the display to query.
   * @param pPropertyCount is a reference to a number related to the number of display modes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayModeProperties2KHR' structures.
   */
  export function vkGetDisplayModeProperties2KHR(
    physicalDevice: VkPhysicalDevice | null,
    display: VkDisplayKHR | null,
    pPropertyCount: VkInout | null,
    pProperties: VkDisplayModeProperties2KHR[] | null
  ): VkResult

  /**
   * Query capabilities of a mode and plane combination
   * @param physicalDevice is the physical device associated with 'pDisplayPlaneInfo'.
   * @param pDisplayPlaneInfo is a reference to a 'VkDisplayPlaneInfo2KHR' structure describing the plane and mode.
   * @param pCapabilities is a reference to a 'VkDisplayPlaneCapabilities2KHR' structure in which the capabilities are returned.
   */
  export function vkGetDisplayPlaneCapabilities2KHR(
    physicalDevice: VkPhysicalDevice | null,
    pDisplayPlaneInfo: VkDisplayPlaneInfo2KHR | null,
    pCapabilities: VkDisplayPlaneCapabilities2KHR | null
  ): VkResult

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the buffer.
   * @param pInfo is a reference to a 'VkBufferMemoryRequirementsInfo2' structure containing parameters required for the memory requirements query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements2' structure in which the memory requirements of the buffer object are returned.
   */
  export function vkGetBufferMemoryRequirements2(
    device: VkDevice | null,
    pInfo: VkBufferMemoryRequirementsInfo2 | null,
    pMemoryRequirements: VkMemoryRequirements2 | null
  ): void

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the image.
   * @param pInfo is a reference to a 'VkImageMemoryRequirementsInfo2' structure containing parameters required for the memory requirements query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements2' structure in which the memory requirements of the image object are returned.
   */
  export function vkGetImageMemoryRequirements2(
    device: VkDevice | null,
    pInfo: VkImageMemoryRequirementsInfo2 | null,
    pMemoryRequirements: VkMemoryRequirements2 | null
  ): void

  /**
   * Query the memory requirements for a sparse image
   * @param device is the logical device that owns the image.
   * @param pInfo is a reference to a 'VkImageSparseMemoryRequirementsInfo2' structure containing parameters required for the memory requirements query.
   * @param pSparseMemoryRequirementCount is a reference to a number related to the number of sparse memory requirements available or queried, as described below.
   * @param pSparseMemoryRequirements is either <i>null</i> or a reference to an array of 'VkSparseImageMemoryRequirements2' structures.
   */
  export function vkGetImageSparseMemoryRequirements2(
    device: VkDevice | null,
    pInfo: VkImageSparseMemoryRequirementsInfo2 | null,
    pSparseMemoryRequirementCount: VkInout | null,
    pSparseMemoryRequirements: VkSparseImageMemoryRequirements2[] | null
  ): void

  /**
   * Create a new Ycbcr conversion
   * @param device is the logical device that creates the sampler Y'C~B~C~R~ conversion.
   * @param pCreateInfo is a reference to a 'VkSamplerYcbcrConversionCreateInfo' structure specifying the requested sampler Y'C~B~C~R~ conversion.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pYcbcrConversion is a reference to a 'VkSamplerYcbcrConversion' handle in which the resulting sampler Y'C~B~C~R~ conversion is returned.
   */
  export function vkCreateSamplerYcbcrConversion(
    device: VkDevice | null,
    pCreateInfo: VkSamplerYcbcrConversionCreateInfo | null,
    pAllocator: null,
    pYcbcrConversion: VkSamplerYcbcrConversion | null
  ): VkResult

  /**
   * Destroy a created Y\
   * @param device is the logical device that destroys the Y'C~B~C~R~ conversion.
   * @param ycbcrConversion is the conversion to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroySamplerYcbcrConversion(
    device: VkDevice | null,
    ycbcrConversion: VkSamplerYcbcrConversion | null,
    pAllocator: null
  ): void

  /**
   * Get a queue handle from a device
   * @param device is the logical device that owns the queue.
   * @param pQueueInfo is a reference to a 'VkDeviceQueueInfo2' structure, describing the parameters used to create the device queue.
   * @param pQueue is a reference to a 'VkQueue' object that will be filled with the handle for the requested queue.
   */
  export function vkGetDeviceQueue2(
    device: VkDevice | null,
    pQueueInfo: VkDeviceQueueInfo2 | null,
    pQueue: VkQueue | null
  ): void

  /**
   * Creates a new validation cache
   * @param device is the logical device that creates the validation cache object.
   * @param pCreateInfo is a reference to a 'VkValidationCacheCreateInfoEXT' structure containing the initial parameters for the validation cache object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pValidationCache is a reference to a 'VkValidationCacheEXT' handle in which the resulting validation cache object is returned.
   */
  export function vkCreateValidationCacheEXT(
    device: VkDevice | null,
    pCreateInfo: VkValidationCacheCreateInfoEXT | null,
    pAllocator: null,
    pValidationCache: VkValidationCacheEXT | null
  ): VkResult

  /**
   * Destroy a validation cache object
   * @param device is the logical device that destroys the validation cache object.
   * @param validationCache is the handle of the validation cache to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyValidationCacheEXT(
    device: VkDevice | null,
    validationCache: VkValidationCacheEXT | null,
    pAllocator: null
  ): void

  /**
   * Get the data store from a validation cache
   * @param device is the logical device that owns the validation cache.
   * @param validationCache is the validation cache to retrieve data from.
   * @param pDataSize is a reference to a value related to the amount of data in the validation cache, as described below.
   * @param pData is either <i>null</i> or a reference to a buffer.
   */
  export function vkGetValidationCacheDataEXT(
    device: VkDevice | null,
    validationCache: VkValidationCacheEXT | null,
    pDataSize: VkInoutAddress | null,
    pData: ArrayBuffer | null
  ): VkResult

  /**
   * Combine the data stores of validation caches
   * @param device is the logical device that owns the validation cache objects.
   * @param dstCache is the handle of the validation cache to merge results into.
   * @param srcCacheCount
   * @param pSrcCaches is an array of validation cache handles, which will be merged into 'dstCache'. The previous contents of 'dstCache' are included after the merge.
   */
  export function vkMergeValidationCachesEXT(
    device: VkDevice | null,
    dstCache: VkValidationCacheEXT | null,
    srcCacheCount: number,
    pSrcCaches: VkValidationCacheEXT[] | null
  ): VkResult

  /**
   * Query whether a descriptor set layout can be created
   * @param device is the logical device that would create the descriptor set layout.
   * @param pCreateInfo is a reference to a 'VkDescriptorSetLayoutCreateInfo' structure specifying the state of the descriptor set layout object.
   * @param pSupport is a reference to a 'VkDescriptorSetLayoutSupport' structure, in which information about support for the descriptor set layout object is returned.
   */
  export function vkGetDescriptorSetLayoutSupport(
    device: VkDevice | null,
    pCreateInfo: VkDescriptorSetLayoutCreateInfo | null,
    pSupport: VkDescriptorSetLayoutSupport | null
  ): void

  /**
   * Get information about a shader in a pipeline
   * @param device
   * @param pipeline is the target of the query.
   * @param shaderStage identifies the particular shader within the pipeline about which information is being queried.
   * @param infoType describes what kind of information is being queried.
   * @param pInfoSize is a reference to a value related to the amount of data the query returns, as described below.
   * @param pInfo is either <i>null</i> or a reference to a buffer.
   */
  export function vkGetShaderInfoAMD(
    device: VkDevice | null,
    pipeline: VkPipeline | null,
    shaderStage: VkShaderStageFlagBits,
    infoType: VkShaderInfoTypeAMD,
    pInfoSize: VkInoutAddress | null,
    pInfo: ArrayBuffer | null
  ): VkResult

  /**
   * Set Local Dimming
   * @param device
   * @param swapChain handle to enable local dimming.
   * @param localDimmingEnable specifies whether local dimming is enabled for the swapchain.
   */
  export function vkSetLocalDimmingAMD(
    device: VkDevice | null,
    swapChain: VkSwapchainKHR | null,
    localDimmingEnable: boolean
  ): void

  /**
   * Query calibrateable time domains
   * @param physicalDevice is the physical device from which to query the set of calibrateable time domains.
   * @param pTimeDomainCount is a reference to a number related to the number of calibrateable time domains available or queried, as described below.
   * @param pTimeDomains is either <i>null</i> or a reference to an array of 'VkTimeDomainEXT' values, indicating the supported calibrateable time domains.
   */
  export function vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    physicalDevice: VkPhysicalDevice | null,
    pTimeDomainCount: VkInout | null,
    pTimeDomains: Int32Array | null
  ): VkResult

  /**
   * Query calibrated timestamps
   * @param device is the logical device used to perform the query.
   * @param timestampCount 64-bit unsigned integer values in which the requested calibrated timestamp values are returned.
   * @param pTimestampInfos
   * @param pTimestamps
   * @param pMaxDeviation is a reference to a 64-bit unsigned integer value in which the strictly positive maximum deviation, in nanoseconds, of the calibrated timestamp values is returned.
   */
  export function vkGetCalibratedTimestampsEXT(
    device: VkDevice | null,
    timestampCount: number,
    pTimestampInfos: VkCalibratedTimestampInfoEXT[] | null,
    pTimestamps: BigUint64Array | null,
    pMaxDeviation: VkInoutAddress | null
  ): VkResult

  /**
   * Give a user-friendly name to an object
   * @param device is the device that created the object.
   * @param pNameInfo is a reference to a 'VkDebugUtilsObjectNameInfoEXT' structure specifying parameters of the name to set on the object.
   */
  export function vkSetDebugUtilsObjectNameEXT(
    device: VkDevice | null,
    pNameInfo: VkDebugUtilsObjectNameInfoEXT | null
  ): VkResult

  /**
   * Attach arbitrary data to an object
   * @param device is the device that created the object.
   * @param pTagInfo is a reference to a 'VkDebugUtilsObjectTagInfoEXT' structure specifying parameters of the tag to attach to the object.
   */
  export function vkSetDebugUtilsObjectTagEXT(
    device: VkDevice | null,
    pTagInfo: VkDebugUtilsObjectTagInfoEXT | null
  ): VkResult

  /**
   * Open a queue debug label region
   * @param queue is the queue in which to start a debug label region.
   * @param pLabelInfo is a reference to a 'VkDebugUtilsLabelEXT' structure specifying parameters of the label region to open.
   */
  export function vkQueueBeginDebugUtilsLabelEXT(
    queue: VkQueue | null,
    pLabelInfo: VkDebugUtilsLabelEXT | null
  ): void

  /**
   * Close a queue debug label region
   * @param queue is the queue in which a debug label region should be closed.
   */
  export function vkQueueEndDebugUtilsLabelEXT(queue: VkQueue | null): void

  /**
   * Insert a label into a queue
   * @param queue is the queue into which a debug label will be inserted.
   * @param pLabelInfo is a reference to a 'VkDebugUtilsLabelEXT' structure specifying parameters of the label to insert.
   */
  export function vkQueueInsertDebugUtilsLabelEXT(
    queue: VkQueue | null,
    pLabelInfo: VkDebugUtilsLabelEXT | null
  ): void

  /**
   * Open a command buffer debug label region
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pLabelInfo is a reference to a 'VkDebugUtilsLabelEXT' structure specifying parameters of the label region to open.
   */
  export function vkCmdBeginDebugUtilsLabelEXT(
    commandBuffer: VkCommandBuffer | null,
    pLabelInfo: VkDebugUtilsLabelEXT | null
  ): void

  /**
   * Close a command buffer label region
   * @param commandBuffer is the command buffer into which the command is recorded.
   */
  export function vkCmdEndDebugUtilsLabelEXT(
    commandBuffer: VkCommandBuffer | null
  ): void

  /**
   * Insert a label into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pLabelInfo
   */
  export function vkCmdInsertDebugUtilsLabelEXT(
    commandBuffer: VkCommandBuffer | null,
    pLabelInfo: VkDebugUtilsLabelEXT | null
  ): void

  /**
   * Create a debug messenger object
   * @param instance the instance the messenger will be used with.
   * @param pCreateInfo is a reference to a 'VkDebugUtilsMessengerCreateInfoEXT' structure containing the callback reference, as well as defining conditions under which this messenger will trigger the callback.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pMessenger is a reference to a 'VkDebugUtilsMessengerEXT' handle in which the created object is returned.
   */
  export function vkCreateDebugUtilsMessengerEXT(
    instance: VkInstance | null,
    pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT | null,
    pAllocator: null,
    pMessenger: VkDebugUtilsMessengerEXT | null
  ): VkResult

  /**
   * Destroy a debug messenger object
   * @param instance the instance where the callback was created.
   * @param messenger the 'VkDebugUtilsMessengerEXT' object to destroy. 'messenger' is an externally synchronized object and 'must' not be used on more than one thread at a time. This means that 'vkDestroyDebugUtilsMessengerEXT' 'must' not be called when a callback is active.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDebugUtilsMessengerEXT(
    instance: VkInstance | null,
    messenger: VkDebugUtilsMessengerEXT | null,
    pAllocator: null
  ): void

  /**
   * Inject a message into a debug stream
   * @param instance is the debug stream's 'VkInstance'.
   * @param messageSeverity is the 'VkDebugUtilsMessageSeverityFlagBitsEXT' severity of this event/message.
   * @param messageTypes is a bitmask of 'VkDebugUtilsMessageTypeFlagBitsEXT' specifying which type of event(s) to identify with this message.
   * @param pCallbackData contains all the callback related data in the 'VkDebugUtilsMessengerCallbackDataEXT' structure.
   */
  export function vkSubmitDebugUtilsMessageEXT(
    instance: VkInstance | null,
    messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
    messageTypes: VkDebugUtilsMessageTypeFlagBitsEXT,
    pCallbackData: VkDebugUtilsMessengerCallbackDataEXT | null
  ): void

  /**
   * Get properties of external memory host reference
   * @param device is the logical device that will be importing 'pHostPointer'.
   * @param handleType
   * @param pHostPointer is the host reference to import from.
   * @param pMemoryHostPointerProperties is a reference to a 'VkMemoryHostPointerPropertiesEXT' structure in which the host reference properties are returned.
   */
  export function vkGetMemoryHostPointerPropertiesEXT(
    device: VkDevice | null,
    handleType: VkExternalMemoryHandleTypeFlagBits,
    pHostPointer: ArrayBuffer | null,
    pMemoryHostPointerProperties: VkMemoryHostPointerPropertiesEXT | null
  ): VkResult

  /**
   * Execute a pipelined write of a marker value into a buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pipelineStage is one of the 'VkPipelineStageFlagBits' values, specifying the pipeline stage whose completion triggers the marker write.
   * @param dstBuffer is the buffer where the marker will be written to.
   * @param dstOffset is the byte offset into the buffer where the marker will be written to.
   * @param marker is the 32-bit value of the marker.
   */
  export function vkCmdWriteBufferMarkerAMD(
    commandBuffer: VkCommandBuffer | null,
    pipelineStage: VkPipelineStageFlagBits,
    dstBuffer: VkBuffer | null,
    dstOffset: bigint | number,
    marker: number
  ): void

  /**
   * Create a new render pass object
   * @param device is the logical device that creates the render pass.
   * @param pCreateInfo is a reference to a 'VkRenderPassCreateInfo2KHR' structure describing the parameters of the render pass.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pRenderPass is a reference to a 'VkRenderPass' handle in which the resulting render pass object is returned.
   */
  export function vkCreateRenderPass2KHR(
    device: VkDevice | null,
    pCreateInfo: VkRenderPassCreateInfo2KHR | null,
    pAllocator: null,
    pRenderPass: VkRenderPass | null
  ): VkResult

  /**
   * Begin a new render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param pRenderPassBegin is a reference to a 'VkRenderPassBeginInfo' structure specifying the render pass to begin an instance of, and the framebuffer the instance uses.
   * @param pSubpassBeginInfo is a reference to a 'VkSubpassBeginInfoKHR' structure containing information about the subpass which is about to begin rendering.
   */
  export function vkCmdBeginRenderPass2KHR(
    commandBuffer: VkCommandBuffer | null,
    pRenderPassBegin: VkRenderPassBeginInfo | null,
    pSubpassBeginInfo: VkSubpassBeginInfoKHR | null
  ): void

  /**
   * Transition to the next subpass of a render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param pSubpassBeginInfo is a reference to a 'VkSubpassBeginInfoKHR' structure containing information about the subpass which is about to begin rendering.
   * @param pSubpassEndInfo is a reference to a 'VkSubpassEndInfoKHR' structure containing information about how the previous subpass will be ended.
   */
  export function vkCmdNextSubpass2KHR(
    commandBuffer: VkCommandBuffer | null,
    pSubpassBeginInfo: VkSubpassBeginInfoKHR | null,
    pSubpassEndInfo: VkSubpassEndInfoKHR | null
  ): void

  /**
   * End the current render pass
   * @param commandBuffer is the command buffer in which to end the current render pass instance.
   * @param pSubpassEndInfo is a reference to a 'VkSubpassEndInfoKHR' structure containing information about how the previous subpass will be ended.
   */
  export function vkCmdEndRenderPass2KHR(
    commandBuffer: VkCommandBuffer | null,
    pSubpassEndInfo: VkSubpassEndInfoKHR | null
  ): void

  /**
   * Query the current state of a timeline semaphore
   * @param device is the logical device that owns the semaphore.
   * @param semaphore is the handle of the semaphore to query.
   * @param pValue is a reference to a 64-bit integer value in which the current counter value of the semaphore is returned.
   */
  export function vkGetSemaphoreCounterValueKHR(
    device: VkDevice | null,
    semaphore: VkSemaphore | null,
    pValue: VkInoutAddress | null
  ): VkResult

  /**
   * Wait for timeline semaphores on the host
   * @param device is the logical device that owns the semaphore.
   * @param pWaitInfo is a reference to an instance of the 'VkSemaphoreWaitInfoKHR' structure containing information about the wait condition.
   * @param timeout is the timeout period in units of nanoseconds. 'timeout' is adjusted to the closest value allowed by the implementation-dependent timeout accuracy, which 'may' be substantially longer than one nanosecond, and 'may' be longer than the requested period.
   */
  export function vkWaitSemaphoresKHR(
    device: VkDevice | null,
    pWaitInfo: VkSemaphoreWaitInfoKHR | null,
    timeout: bigint | number
  ): VkResult

  /**
   * Signal a timeline semaphore on the host
   * @param device is the logical device that owns the semaphore.
   * @param pSignalInfo is a reference to an instance of the 'VkSemaphoreSignalInfoKHR' structure containing information about the signal operation.
   */
  export function vkSignalSemaphoreKHR(
    device: VkDevice | null,
    pSignalInfo: VkSemaphoreSignalInfoKHR | null
  ): VkResult

  /**
   * Perform an indirect draw with the draw count sourced from a buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param countBuffer where the draw count begins.
   * @param countBufferOffset
   * @param maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in 'countBuffer' and 'maxDrawCount'.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndirectCountKHR(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    countBuffer: VkBuffer | null,
    countBufferOffset: bigint | number,
    maxDrawCount: number,
    stride: number
  ): void

  /**
   * Perform an indexed indirect draw with the draw count sourced from a buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param countBuffer where the draw count begins.
   * @param countBufferOffset
   * @param maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in 'countBuffer' and 'maxDrawCount'.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndexedIndirectCountKHR(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    countBuffer: VkBuffer | null,
    countBufferOffset: bigint | number,
    maxDrawCount: number,
    stride: number
  ): void

  /**
   * insert diagnostic checkpoint in command stream
   * @param commandBuffer is the command buffer that will receive the marker
   * @param pCheckpointMarker is an opaque application-provided value that will be associated with the checkpoint.
   */
  export function vkCmdSetCheckpointNV(
    commandBuffer: VkCommandBuffer | null,
    pCheckpointMarker: ArrayBuffer | null
  ): void

  /**
   * retrieve diagnostic checkpoint data
   * @param queue is the 'VkQueue' object the caller would like to retrieve checkpoint data for
   * @param pCheckpointDataCount is a reference to a number related to the number of checkpoint markers available or queried, as described below.
   * @param pCheckpointData is either <i>null</i> or a reference to an array of 'VkCheckpointDataNV' structures.
   */
  export function vkGetQueueCheckpointDataNV(
    queue: VkQueue | null,
    pCheckpointDataCount: VkInout | null,
    pCheckpointData: VkCheckpointDataNV[] | null
  ): void

  /**
   * Bind transform feedback buffers to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstBinding is the index of the first transform feedback binding whose state is updated by the command.
   * @param bindingCount is the number of transform feedback bindings whose state is updated by the command.
   * @param pBuffers is an array of buffer handles.
   * @param pOffsets is an array of buffer offsets.
   * @param pSizes is an optional array of buffer sizes, specifying the maximum number of bytes to capture to the corresponding transform feedback buffer. If 'pSizes' is <i>null</i>, or the value of the 'pSizes' array element is 'VK_WHOLE_SIZE', then the maximum bytes captured will be the size of the corresponding buffer minus the buffer offset.
   */
  export function vkCmdBindTransformFeedbackBuffersEXT(
    commandBuffer: VkCommandBuffer | null,
    firstBinding: number,
    bindingCount: number,
    pBuffers: VkBuffer[] | null,
    pOffsets: BigUint64Array | null,
    pSizes: BigUint64Array | null
  ): void

  /**
   * Make transform feedback active in the command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstCounterBuffer is the index of the first transform feedback buffer corresponding to 'pCounterBuffers'[0] and 'pCounterBufferOffsets'[0].
   * @param counterBufferCount
   * @param pCounterBuffers is an optional array of buffer handles to the counter buffers which contain a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data. If the byte offset stored to the counter buffer location was done using 'vkCmdEndTransformFeedbackEXT' it can be used to resume transform feedback from the previous location. If 'pCounterBuffers' is <i>null</i>, then transform feedback will start capturing vertex data to byte offset zero in all bound transform feedback buffers. For each element of 'pCounterBuffers' that is 'VK_NULL_HANDLE', transform feedback will start capturing vertex data to byte zero in the corresponding bound transform feedback buffer.
   * @param pCounterBufferOffsets is an optional array of offsets within each of the 'pCounterBuffers' where the counter values were previously written. The location in each counter buffer at these offsets 'must' be large enough to contain 4 bytes of data. This data is the number of bytes captured by the previous transform feedback to this buffer. If 'pCounterBufferOffsets' is <i>null</i>, then it is assumed the offsets are zero.
   */
  export function vkCmdBeginTransformFeedbackEXT(
    commandBuffer: VkCommandBuffer | null,
    firstCounterBuffer: number,
    counterBufferCount: number,
    pCounterBuffers: VkBuffer[] | null,
    pCounterBufferOffsets: BigUint64Array | null
  ): void

  /**
   * Make transform feedback inactive in the command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstCounterBuffer is the index of the first transform feedback buffer corresponding to 'pCounterBuffers'[0] and 'pCounterBufferOffsets'[0].
   * @param counterBufferCount
   * @param pCounterBuffers is an optional array of buffer handles to the counter buffers used to record the current byte positions of each transform feedback buffer where the next vertex output data would be captured. This 'can' be used by a subsequent 'vkCmdBeginTransformFeedbackEXT' call to resume transform feedback capture from this position. It can also be used by 'vkCmdDrawIndirectByteCountEXT' to determine the vertex count of the draw call.
   * @param pCounterBufferOffsets is an optional array of offsets within each of the 'pCounterBuffers' where the counter values can be written. The location in each counter buffer at these offsets 'must' be large enough to contain 4 bytes of data. The data stored at this location is the byte offset from the start of the transform feedback buffer binding where the next vertex data would be written. If 'pCounterBufferOffsets' is <i>null</i>, then it is assumed the offsets are zero.
   */
  export function vkCmdEndTransformFeedbackEXT(
    commandBuffer: VkCommandBuffer | null,
    firstCounterBuffer: number,
    counterBufferCount: number,
    pCounterBuffers: VkBuffer[] | null,
    pCounterBufferOffsets: BigUint64Array | null
  ): void

  /**
   * Begin an indexed query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param query is the query index within the query pool that will contain the results.
   * @param flags is a bitmask of 'VkQueryControlFlagBits' specifying constraints on the types of queries that 'can' be performed.
   * @param index is the query type specific index. When the query type is 'VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT' the index represents the vertex stream.
   */
  export function vkCmdBeginQueryIndexedEXT(
    commandBuffer: VkCommandBuffer | null,
    queryPool: VkQueryPool | null,
    query: number,
    flags: VkQueryControlFlagBits,
    index: number
  ): void

  /**
   * Ends a query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that is managing the results of the query.
   * @param query is the query index within the query pool where the result is stored.
   * @param index is the query type specific index.
   */
  export function vkCmdEndQueryIndexedEXT(
    commandBuffer: VkCommandBuffer | null,
    queryPool: VkQueryPool | null,
    query: number,
    index: number
  ): void

  /**
   * Draw primitives where the vertex count is derived from the counter byte value in the counter buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param instanceCount is the number of instances to draw.
   * @param firstInstance is the instance ID of the first instance to draw.
   * @param counterBuffer is the buffer handle from where the byte count is read.
   * @param counterBufferOffset is the offset into the buffer used to read the byte count, which is used to calculate the vertex count for this draw call.
   * @param counterOffset is subtracted from the byte count read from the 'counterBuffer' at the 'counterBufferOffset'
   * @param vertexStride is the stride in bytes between each element of the vertex data that is used to calculate the vertex count from the counter value. This value is typically the same value that was used in the graphics pipeline state when the transform feedback was captured as the 'XfbStride'.
   */
  export function vkCmdDrawIndirectByteCountEXT(
    commandBuffer: VkCommandBuffer | null,
    instanceCount: number,
    firstInstance: number,
    counterBuffer: VkBuffer | null,
    counterBufferOffset: bigint | number,
    counterOffset: number,
    vertexStride: number
  ): void

  /**
   * Set the dynamic exclusive scissor rectangles on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstExclusiveScissor is the index of the first exclusive scissor rectangle whose state is updated by the command.
   * @param exclusiveScissorCount is the number of exclusive scissor rectangles updated by the command.
   * @param pExclusiveScissors is an array of 'VkRect2D' structures defining exclusive scissor rectangles.
   */
  export function vkCmdSetExclusiveScissorNV(
    commandBuffer: VkCommandBuffer | null,
    firstExclusiveScissor: number,
    exclusiveScissorCount: number,
    pExclusiveScissors: VkRect2D[] | null
  ): void

  /**
   * Bind a shading rate image on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param imageView is an image view handle specifying the shading rate image. 'imageView' 'may' be set to 'VK_NULL_HANDLE', which is equivalent to specifying a view of an image filled with zero values.
   * @param imageLayout is the layout that the image subresources accessible from 'imageView' will be in when the shading rate image is accessed.
   */
  export function vkCmdBindShadingRateImageNV(
    commandBuffer: VkCommandBuffer | null,
    imageView: VkImageView | null,
    imageLayout: VkImageLayout
  ): void

  /**
   * Set shading rate image palettes on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstViewport is the index of the first viewport whose shading rate palette is updated by the command.
   * @param viewportCount is the number of viewports whose shading rate palettes are updated by the command.
   * @param pShadingRatePalettes is an array of 'VkShadingRatePaletteNV' structures defining the palette for each viewport.
   */
  export function vkCmdSetViewportShadingRatePaletteNV(
    commandBuffer: VkCommandBuffer | null,
    firstViewport: number,
    viewportCount: number,
    pShadingRatePalettes: VkShadingRatePaletteNV[] | null
  ): void

  /**
   * Set sample order for coarse fragments on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param sampleOrderType specifies the mechanism used to order coverage samples in fragments larger than one pixel.
   * @param customSampleOrderCount specifies the number of custom sample orderings to use when ordering coverage samples.
   * @param pCustomSampleOrders is an array of 'VkCoarseSampleOrderCustomNV' structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
   */
  export function vkCmdSetCoarseSampleOrderNV(
    commandBuffer: VkCommandBuffer | null,
    sampleOrderType: VkCoarseSampleOrderTypeNV,
    customSampleOrderCount: number,
    pCustomSampleOrders: VkCoarseSampleOrderCustomNV[] | null
  ): void

  /**
   * Draw mesh task work items
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param taskCount is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
   * @param firstTask is the X component of the first workgroup ID.
   */
  export function vkCmdDrawMeshTasksNV(
    commandBuffer: VkCommandBuffer | null,
    taskCount: number,
    firstTask: number
  ): void

  /**
   * Issue an indirect mesh tasks draw into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param drawCount is the number of draws to execute, and 'can' be zero.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawMeshTasksIndirectNV(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    drawCount: number,
    stride: number
  ): void

  /**
   * Perform an indirect mesh tasks draw with the draw count sourced from a buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param countBuffer where the draw count begins.
   * @param countBufferOffset
   * @param maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in 'countBuffer' and 'maxDrawCount'.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawMeshTasksIndirectCountNV(
    commandBuffer: VkCommandBuffer | null,
    buffer: VkBuffer | null,
    offset: bigint | number,
    countBuffer: VkBuffer | null,
    countBufferOffset: bigint | number,
    maxDrawCount: number,
    stride: number
  ): void

  /**
   * Deferred compilation of shaders
   * @param device is the logical device containing the ray tracing pipeline.
   * @param pipeline is the ray tracing pipeline object containing the shaders.
   * @param shader is the index of the shader to compile.
   */
  export function vkCompileDeferredNV(
    device: VkDevice | null,
    pipeline: VkPipeline | null,
    shader: number
  ): VkResult

  /**
   * Create a new acceleration structure object
   * @param device is the logical device that creates the buffer object.
   * @param pCreateInfo is a reference to a 'VkAccelerationStructureCreateInfoNV' structure containing parameters affecting creation of the acceleration structure.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pAccelerationStructure is a reference to a 'VkAccelerationStructureNV' handle in which the resulting acceleration structure object is returned.
   */
  export function vkCreateAccelerationStructureNV(
    device: VkDevice | null,
    pCreateInfo: VkAccelerationStructureCreateInfoNV | null,
    pAllocator: null,
    pAccelerationStructure: VkAccelerationStructureNV | null
  ): VkResult

  /**
   * Destroy an acceleration structure object
   * @param device is the logical device that destroys the buffer.
   * @param accelerationStructure is the acceleration structure to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyAccelerationStructureNV(
    device: VkDevice | null,
    accelerationStructure: VkAccelerationStructureNV | null,
    pAllocator: null
  ): void

  /**
   * Get acceleration structure memory requirements
   * @param device is the logical device on which the acceleration structure was created.
   * @param pInfo specifies the acceleration structure to get memory requirements for.
   * @param pMemoryRequirements returns the requested acceleration structure memory requirements.
   */
  export function vkGetAccelerationStructureMemoryRequirementsNV(
    device: VkDevice | null,
    pInfo: VkAccelerationStructureMemoryRequirementsInfoNV | null,
    pMemoryRequirements: VkMemoryRequirements2KHR | null
  ): void

  /**
   * Bind acceleration structure memory
   * @param device is the logical device that owns the acceleration structures and memory.
   * @param bindInfoCount
   * @param pBindInfos is an array of 'VkBindAccelerationStructureMemoryInfoNV' structures describing images and memory to bind.
   */
  export function vkBindAccelerationStructureMemoryNV(
    device: VkDevice | null,
    bindInfoCount: number,
    pBindInfos: VkBindAccelerationStructureMemoryInfoNV[] | null
  ): VkResult

  /**
   * Copy an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param dst is a reference to the target acceleration structure for the copy.
   * @param src is a reference to the source acceleration structure for the copy.
   * @param mode is a 'VkCopyAccelerationStructureModeNV' value specifying additional operations to perform during the copy.
   */
  export function vkCmdCopyAccelerationStructureNV(
    commandBuffer: VkCommandBuffer | null,
    dst: VkAccelerationStructureNV | null,
    src: VkAccelerationStructureNV | null,
    mode: VkCopyAccelerationStructureModeNV
  ): void

  /**
   * Write acceleration structure result parameters to query results.
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param accelerationStructureCount is the count of acceleration structures for which to query the property.
   * @param pAccelerationStructures is an array of existing previously built acceleration structures.
   * @param queryType is a 'VkQueryType' value specifying the type of queries managed by the pool.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param firstQuery is the first query index within the query pool that will contain the 'accelerationStructureCount' number of results.
   */
  export function vkCmdWriteAccelerationStructuresPropertiesNV(
    commandBuffer: VkCommandBuffer | null,
    accelerationStructureCount: number,
    pAccelerationStructures: VkAccelerationStructureNV[] | null,
    queryType: VkQueryType,
    queryPool: VkQueryPool | null,
    firstQuery: number
  ): void

  /**
   * Build an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pInfo contains the shared information for the acceleration structure's structure.
   * @param instanceData is the buffer containing instance data that will be used to build the acceleration structure as described in <<acceleration-structure-instance, Accelerator structure instances.>> This parameter 'must' be <i>null</i> for bottom level acceleration structures.
   * @param instanceOffset is the offset in bytes (relative to the start of 'instanceData') at which the instance data is located.
   * @param update
   * @param dst is a reference to the target acceleration structure for the build.
   * @param src is a reference to an existing acceleration structure that is to be used to update the 'dst' acceleration structure.
   * @param scratch is the 'VkBuffer' that will be used as scratch memory for the build.
   * @param scratchOffset is the offset in bytes relative to the start of 'scratch' that will be used as a scratch memory.
   */
  export function vkCmdBuildAccelerationStructureNV(
    commandBuffer: VkCommandBuffer | null,
    pInfo: VkAccelerationStructureInfoNV | null,
    instanceData: VkBuffer | null,
    instanceOffset: bigint | number,
    update: boolean,
    dst: VkAccelerationStructureNV | null,
    src: VkAccelerationStructureNV | null,
    scratch: VkBuffer | null,
    scratchOffset: bigint | number
  ): void

  /**
   * Initialize a ray tracing dispatch
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param raygenShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the ray generation shader stage.
   * @param raygenShaderBindingOffset is the offset in bytes (relative to 'raygenShaderBindingTableBuffer') of the ray generation shader being used for the trace.
   * @param missShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the miss shader stage.
   * @param missShaderBindingOffset is the offset in bytes (relative to 'missShaderBindingTableBuffer') of the miss shader being used for the trace.
   * @param missShaderBindingStride is the size in bytes of each shader binding table record in 'missShaderBindingTableBuffer'.
   * @param hitShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the hit shader stages.
   * @param hitShaderBindingOffset is the offset in bytes (relative to 'hitShaderBindingTableBuffer') of the hit shader group being used for the trace.
   * @param hitShaderBindingStride is the size in bytes of each shader binding table record in 'hitShaderBindingTableBuffer'.
   * @param callableShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the callable shader stage.
   * @param callableShaderBindingOffset is the offset in bytes (relative to 'callableShaderBindingTableBuffer') of the callable shader being used for the trace.
   * @param callableShaderBindingStride is the size in bytes of each shader binding table record in 'callableShaderBindingTableBuffer'.
   * @param width is the width of the ray trace query dimensions.
   * @param height is height of the ray trace query dimensions.
   * @param depth is depth of the ray trace query dimensions.
   */
  export function vkCmdTraceRaysNV(
    commandBuffer: VkCommandBuffer | null,
    raygenShaderBindingTableBuffer: VkBuffer | null,
    raygenShaderBindingOffset: bigint | number,
    missShaderBindingTableBuffer: VkBuffer | null,
    missShaderBindingOffset: bigint | number,
    missShaderBindingStride: bigint | number,
    hitShaderBindingTableBuffer: VkBuffer | null,
    hitShaderBindingOffset: bigint | number,
    hitShaderBindingStride: bigint | number,
    callableShaderBindingTableBuffer: VkBuffer | null,
    callableShaderBindingOffset: bigint | number,
    callableShaderBindingStride: bigint | number,
    width: number,
    height: number,
    depth: number
  ): void

  /**
   * Query ray tracing pipeline shader group handles
   * @param device is the logical device containing the ray tracing pipeline.
   * @param pipeline is the ray tracing pipeline object containing the shaders.
   * @param firstGroup is the index of the first group to retrieve a handle for from the 'VkRayTracingShaderGroupCreateInfoNV'::'pGroups' array.
   * @param groupCount is the number of shader handles to retrieve.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written.
   */
  export function vkGetRayTracingShaderGroupHandlesNV(
    device: VkDevice | null,
    pipeline: VkPipeline | null,
    firstGroup: number,
    groupCount: number,
    dataSize: bigint | number,
    pData: ArrayBuffer | null
  ): VkResult

  /**
   * Get opaque acceleration structure handle
   * @param device is the logical device that owns the acceleration structures.
   * @param accelerationStructure is the acceleration structure.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written.
   */
  export function vkGetAccelerationStructureHandleNV(
    device: VkDevice | null,
    accelerationStructure: VkAccelerationStructureNV | null,
    dataSize: bigint | number,
    pData: ArrayBuffer | null
  ): VkResult

  /**
   * Creates a new ray tracing pipeline object
   * @param device is the logical device that creates the ray tracing pipelines.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled, or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkRayTracingPipelineCreateInfoNV' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array in which the resulting ray tracing pipeline objects are returned.
   */
  export function vkCreateRayTracingPipelinesNV(
    device: VkDevice | null,
    pipelineCache: VkPipelineCache | null,
    createInfoCount: number,
    pCreateInfos: VkRayTracingPipelineCreateInfoNV[] | null,
    pAllocator: null,
    pPipelines: VkPipeline[] | null
  ): VkResult

  /**
   * Returns an image\
   * @param device is the logical device that owns the image.
   * @param image is the queried image.
   * @param pProperties will return properties of the image's _DRM format modifier_.
   */
  export function vkGetImageDrmFormatModifierPropertiesEXT(
    device: VkDevice | null,
    image: VkImage | null,
    pProperties: VkImageDrmFormatModifierPropertiesEXT | null
  ): VkResult

  /**
   * Query an address of a buffer
   * @param device is the logical device that the buffer was created on.
   * @param pInfo is a reference to a 'VkBufferDeviceAddressInfoEXT' structure specifying the buffer to retrieve an address for.
   */
  export function vkGetBufferDeviceAddressEXT(
    device: VkDevice | null,
    pInfo: VkBufferDeviceAddressInfoEXT | null
  ): bigint

  /**
   * Returns properties describing what cooperative matrix types are supported
   * @param physicalDevice is the physical device.
   * @param pPropertyCount is a reference to a number related to the number of cooperative matrix properties available or queried.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkCooperativeMatrixPropertiesNV' structures.
   */
  export function vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    physicalDevice: VkPhysicalDevice | null,
    pPropertyCount: VkInout | null,
    pProperties: VkCooperativeMatrixPropertiesNV[] | null
  ): VkResult

  /**
   * Get the handle for an image view for a specific descriptor type
   * @param device is the logical device that owns the image view.
   * @param pInfo describes the image view to query and type of handle.
   */
  export function vkGetImageViewHandleNVX(
    device: VkDevice | null,
    pInfo: VkImageViewHandleInfoNVX | null
  ): number

  /**
   * Query supported presentation modes
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pPresentModeCount is a reference to a number related to the number of presentation modes available or queried, as described below.
   * @param pPresentModes is either <i>null</i> or a reference to an array of 'VkPresentModeKHR' values, indicating the supported presentation modes.
   */
  export function vkGetPhysicalDeviceSurfacePresentModes2EXT(
    physicalDevice: VkPhysicalDevice | null,
    pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null,
    pPresentModeCount: VkInout | null,
    pPresentModes: Int32Array | null
  ): VkResult

  /**
   * Query device group present capabilities for a surface
   * @param device is the logical device.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pModes is a reference to a 'VkDeviceGroupPresentModeFlagsKHR' in which the supported device group present modes for the surface are returned.
   */
  export function vkGetDeviceGroupSurfacePresentModes2EXT(
    device: VkDevice | null,
    pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null,
    pModes: VkInout | null
  ): VkResult

  /**
   * Acquire full-screen exclusive mode for a swapchain
   * @param device
   * @param swapchain is the swapchain to acquire exclusive full-screen access for.
   */
  export function vkAcquireFullScreenExclusiveModeEXT(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null
  ): VkResult

  /**
   * Release full-screen exclusive mode from a swapchain
   * @param device
   * @param swapchain is the swapchain to release exclusive full-screen access from.
   */
  export function vkReleaseFullScreenExclusiveModeEXT(
    device: VkDevice | null,
    swapchain: VkSwapchainKHR | null
  ): VkResult

  /**
   * Create a headless {#0#} object
   * @param instance is the instance to associate the surface with.
   * @param pCreateInfo is a reference to a 'VkHeadlessSurfaceCreateInfoEXT' structure containing parameters affecting the creation of the surface object.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSurface is a reference to a 'VkSurfaceKHR' handle in which the created surface object is returned.
   */
  export function vkCreateHeadlessSurfaceEXT(
    instance: VkInstance | null,
    pCreateInfo: VkHeadlessSurfaceCreateInfoEXT | null,
    pAllocator: null,
    pSurface: VkSurfaceKHR | null
  ): VkResult

  /**
   * Query supported sample count combinations
   * @param physicalDevice is the physical device from which to query the set of combinations.
   * @param pCombinationCount is a reference to a number related to the number of combinations available or queried, as described below.
   * @param pCombinations is either <i>null</i> or a reference to an array of 'VkFramebufferMixedSamplesCombinationNV' values, indicating the supported combinations of coverage reduction mode, rasterization samples, and color, depth, stencil attachment sample counts.
   */
  export function vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    physicalDevice: VkPhysicalDevice | null,
    pCombinationCount: VkInout | null,
    pCombinations: VkFramebufferMixedSamplesCombinationNV[] | null
  ): VkResult

  /**
   * Initialize a device for performance queries
   * @param device is the logical device used for the queries.
   * @param pInitializeInfo is a reference to a 'VkInitializePerformanceApiInfoINTEL' structure specifying initialization parameters.
   */
  export function vkInitializePerformanceApiINTEL(
    device: VkDevice | null,
    pInitializeInfo: VkInitializePerformanceApiInfoINTEL | null
  ): VkResult

  /**
   * Uninitialize a device for performance queries
   * @param device is the logical device used for the queries.
   */
  export function vkUninitializePerformanceApiINTEL(
    device: VkDevice | null
  ): void

  /**
   * Markers
   * @param commandBuffer
   * @param pMarkerInfo
   */
  export function vkCmdSetPerformanceMarkerINTEL(
    commandBuffer: VkCommandBuffer | null,
    pMarkerInfo: VkPerformanceMarkerInfoINTEL | null
  ): VkResult

  /**
   * Markers
   * @param commandBuffer
   * @param pMarkerInfo
   */
  export function vkCmdSetPerformanceStreamMarkerINTEL(
    commandBuffer: VkCommandBuffer | null,
    pMarkerInfo: VkPerformanceStreamMarkerInfoINTEL | null
  ): VkResult

  /**
   * Performance override settings
   * @param commandBuffer is the command buffer where the override takes place.
   * @param pOverrideInfo is a reference to a 'VkPerformanceOverrideInfoINTEL' structure selecting the parameter to override.
   */
  export function vkCmdSetPerformanceOverrideINTEL(
    commandBuffer: VkCommandBuffer | null,
    pOverrideInfo: VkPerformanceOverrideInfoINTEL | null
  ): VkResult

  /**
   * Acquire the performance query capability
   * @param device is the logical device that the performance query commands will be submitted to.
   * @param pAcquireInfo is a reference to a 'VkPerformanceConfigurationAcquireInfoINTEL' structure, specifying the performance configuration to acquire.
   * @param pConfiguration is a reference to a 'VkPerformanceConfigurationINTEL' handle in which the resulting configuration object is returned.
   */
  export function vkAcquirePerformanceConfigurationINTEL(
    device: VkDevice | null,
    pAcquireInfo: VkPerformanceConfigurationAcquireInfoINTEL | null,
    pConfiguration: VkPerformanceConfigurationINTEL | null
  ): VkResult

  /**
   * Release a configuration to capture performance data
   * @param device is the device associated to the configuration object to release.
   * @param configuration is the configuration object to release.
   */
  export function vkReleasePerformanceConfigurationINTEL(
    device: VkDevice | null,
    configuration: VkPerformanceConfigurationINTEL | null
  ): VkResult

  /**
   * Set a performance query
   * @param queue is the queue on which the configuration will be used.
   * @param configuration is the configuration to use.
   */
  export function vkQueueSetPerformanceConfigurationINTEL(
    queue: VkQueue | null,
    configuration: VkPerformanceConfigurationINTEL | null
  ): VkResult

  /**
   * Query performance capabilities of the device
   * @param device is the logical device to query.
   * @param parameter is the parameter to query.
   * @param pValue is a reference to a 'VkPerformanceValueINTEL' structure in which the type and value of the parameter are returned.
   */
  export function vkGetPerformanceParameterINTEL(
    device: VkDevice | null,
    parameter: VkPerformanceParameterTypeINTEL,
    pValue: VkPerformanceValueINTEL | null
  ): VkResult

  /**
   * Get the executables associated with a pipeline
   * @param device is the device that created the pipeline.
   * @param pPipelineInfo describes the pipeline being queried.
   * @param pExecutableCount is a reference to a number related to the number of pipeline executables available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkPipelineExecutablePropertiesKHR' structures.
   */
  export function vkGetPipelineExecutablePropertiesKHR(
    device: VkDevice | null,
    pPipelineInfo: VkPipelineInfoKHR | null,
    pExecutableCount: VkInout | null,
    pProperties: VkPipelineExecutablePropertiesKHR[] | null
  ): VkResult

  /**
   * Get compile time statistics associated with a pipeline executable
   * @param device is the device that created the pipeline.
   * @param pExecutableInfo describes the pipeline executable being queried.
   * @param pStatisticCount is a reference to a number related to the number of statistics available or queried, as described below.
   * @param pStatistics is either <i>null</i> or a reference to an array of 'VkPipelineExecutableStatisticKHR' structures.
   */
  export function vkGetPipelineExecutableStatisticsKHR(
    device: VkDevice | null,
    pExecutableInfo: VkPipelineExecutableInfoKHR | null,
    pStatisticCount: VkInout | null,
    pStatistics: VkPipelineExecutableStatisticKHR[] | null
  ): VkResult

  /**
   * Get internal representations of the pipeline executable
   * @param device is the device that created the pipeline.
   * @param pExecutableInfo describes the pipeline executable being queried.
   * @param pInternalRepresentationCount is a reference to a number related to the number of internal representations available or queried, as described below.
   * @param pInternalRepresentations is either <i>null</i> or a reference to an array of 'VkPipelineExecutableInternalRepresentationKHR' structures.
   */
  export function vkGetPipelineExecutableInternalRepresentationsKHR(
    device: VkDevice | null,
    pExecutableInfo: VkPipelineExecutableInfoKHR | null,
    pInternalRepresentationCount: VkInout | null,
    pInternalRepresentations:
      | VkPipelineExecutableInternalRepresentationKHR[]
      | null
  ): VkResult

  /**
   * Set the dynamic line width state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param lineStippleFactor is the repeat factor used in stippled line rasterization.
   * @param lineStipplePattern is the bit pattern used in stippled line rasterization.
   */
  export function vkCmdSetLineStippleEXT(
    commandBuffer: VkCommandBuffer | null,
    lineStippleFactor: number,
    lineStipplePattern: number
  ): void

  /**
   *
   * @param pUserData
   * @param size
   * @param allocationType
   * @param allocationScope
   */
  export interface vkInternalAllocationNotification {
    (
      pUserData: null,
      size: bigint | number,
      allocationType: VkInternalAllocationType,
      allocationScope: VkSystemAllocationScope
    ): void
  }

  /**
   *
   * @param pUserData
   * @param size
   * @param allocationType
   * @param allocationScope
   */
  export interface vkInternalFreeNotification {
    (
      pUserData: null,
      size: bigint | number,
      allocationType: VkInternalAllocationType,
      allocationScope: VkSystemAllocationScope
    ): void
  }

  /**
   *
   * @param pUserData
   * @param pOriginal
   * @param size
   * @param alignment
   * @param allocationScope
   */
  export interface vkReallocationFunction {
    (
      pUserData: null,
      pOriginal: ArrayBuffer | null,
      size: bigint | number,
      alignment: bigint | number,
      allocationScope: VkSystemAllocationScope
    ): void
  }

  /**
   *
   * @param pUserData
   * @param size
   * @param alignment
   * @param allocationScope
   */
  export interface vkAllocationFunction {
    (
      pUserData: null,
      size: bigint | number,
      alignment: bigint | number,
      allocationScope: VkSystemAllocationScope
    ): void
  }

  /**
   *
   * @param pUserData
   * @param pMemory
   */
  export interface vkFreeFunction {
    (pUserData: null, pMemory: ArrayBuffer | null): void
  }

  /**
   *
   * @param flags
   * @param objectType
   * @param object
   * @param location
   * @param messageCodeconst
   * @param pLayerPrefixconst
   * @param pMessage
   * @param pUserData
   */
  export interface vkDebugReportCallbackEXT {
    (
      flags: VkDebugReportFlagBitsEXT,
      objectType: VkDebugReportObjectTypeEXT,
      object: bigint | number,
      location: bigint | number,
      messageCodeconst: number,
      pLayerPrefixconst: string | null,
      pMessage: string | null,
      pUserData: null
    ): boolean
  }

  /**
   *
   * @param messageSeverity
   * @param messageTypesconst
   * @param pCallbackData
   * @param pUserData
   */
  export interface vkDebugUtilsMessengerCallbackEXT {
    (
      messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
      messageTypesconst: VkDebugUtilsMessageTypeFlagBitsEXT,
      pCallbackData: VkDebugUtilsMessengerCallbackDataEXT | null,
      pUserData: null
    ): boolean
  }

  export function createV8ArrayBufferFromMemory(
    addr: bigint,
    size: number
  ): ArrayBuffer

  export function VK_MAKE_VERSION(
    major: number,
    minor: number,
    patch: number
  ): number

  export function VK_VERSION_MAJOR(major: number): number

  export function VK_VERSION_MINOR(minor: number): number

  export function VK_VERSION_PATCH(patch: number): number

  export function vkUseDevice(pDevice: VkDevice): void

  export function vkUseInstance(pInstance: VkInstance): void

  export var VK_API_VERSION_1_0: number

  export interface ResizeEvent {
    width: number
    height: number
  }
  export interface FocusEvent {
    focused: boolean
  }
  export interface CloseEvent {}
  export interface KeydownEvent {
    keyCode: number
  }
  export interface KeyupEvent {
    keyCode: number
  }
  export interface MousemoveEvent {
    x: number
    y: number
    movementX: number
    movementY: number
  }
  export interface MousewheelEvent {
    x: number
    y: number
    deltaX: number
    deltaY: number
  }
  export interface MousedownEvent {
    x: number
    y: number
    button: number
  }
  export interface MouseupEvent {
    x: number
    y: number
    button: number
  }
  export interface DropEvent {
    paths: string[]
  }

  export interface VulkanWindowInitializer {
    width: number
    height: number
    title?: string
    resizable?: boolean
  }

  declare var VulkanWindow: {
    prototype: VulkanWindow
    new (param: VulkanWindowInitializer): VulkanWindow
    width: number
    height: number
    frameBufferWidth: number
    frameBufferHeight: number
    title: string
    pollEvents(): void
    focus(): void
    close(): void
    shouldClose(): boolean
    createSurface(
      instance: VkInstance | null,
      pAllocator: null,
      surface: VkSurfaceKHR | null
    ): number
    getRequiredInstanceExtensions(): string[]
    onresize: ((ev: ResizeEvent) => any) | null
    onfocus: ((ev: FocusEvent) => any) | null
    onclose: ((ev: CloseEvent) => any) | null
    onkeydown: ((ev: KeydownEvent) => any) | null
    onkeyup: ((ev: KeyupEvent) => any) | null
    onmousemove: ((ev: MousemoveEvent) => any) | null
    onmousewheel: ((ev: MousewheelEvent) => any) | null
    onmousedown: ((ev: MousedownEvent) => any) | null
    onmouseup: ((ev: MouseupEvent) => any) | null
    ondrop: ((ev: DropEvent) => any) | null
  }

  export interface VulkanWindow {
    width: number
    height: number
    frameBufferWidth: number
    frameBufferHeight: number
    title: string
    pollEvents(): void
    focus(): void
    close(): void
    shouldClose(): boolean
    createSurface(
      instance: VkInstance | null,
      pAllocator: null,
      surface: VkSurfaceKHR | null
    ): number
    getRequiredInstanceExtensions(): string[]
    onresize: ((ev: ResizeEvent) => any) | null
    onfocus: ((ev: FocusEvent) => any) | null
    onclose: ((ev: CloseEvent) => any) | null
    onkeydown: ((ev: KeydownEvent) => any) | null
    onkeyup: ((ev: KeyupEvent) => any) | null
    onmousemove: ((ev: MousemoveEvent) => any) | null
    onmousewheel: ((ev: MousewheelEvent) => any) | null
    onmousedown: ((ev: MousedownEvent) => any) | null
    onmouseup: ((ev: MouseupEvent) => any) | null
    ondrop: ((ev: DropEvent) => any) | null
  }
}
